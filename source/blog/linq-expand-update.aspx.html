<!-- [info]

 - date: 2006-07-28T03:57:38.0000000
 - description: Article describes LINQ extension that adds support for returning rows that contain any or all of specified keywords in string column.
 - tags: c#
 - layout: post
 - title: LINQ extensions - Simplified keyword search
 - url: linq-expand-update.aspx

[/info] -->
<!-- [abstract]
<p>Recently, I came across interesting question at LINQ Forums (Dynamic conditions: How to achieve multiple "OR" conditions with LINQ? [<a href="#updlq">1</a>]).
  The question is whether LINQ (and especially LINQ to SQL) provides any simple way to return only records that contain one or more of 
  specified keywords in the name. The question looks simple, but it is simple only if you know the number of keywords that you want to 
  look for. In this case you can write following LINQ query:</p>
<pre>
  <span class="c">// Products that contain "kwd1" or "kwd2" in the name </span><br />
  <span class="k">var</span> q = <span class="k">from</span> p <span class="k">in</span> db.Products
    <span class="k">where</span> p.ProductName.Contains("kwd1") || p.ProductName.Contains("kwd2")
    <span class="k">select</span> p;
</pre>
<p>The problem with previous code is that you can't use it if the list of keywords is dynamically entered by user
  (and so its length may vary). Of course, if you want to run query on in-memory data, you can get very nice results by
  writing extension method called <code>ContainsAny</code> that performs test for keyword array, but if you 
  want to be able to translate query to SQL, the situation is a bit complicated.</p>
[/abstract] -->

<h1>LINQ extensions - Simplified keyword search</h1>


<p>Recently, I came across interesting question at LINQ Forums (Dynamic conditions: How to achieve multiple "OR" conditions with LINQ? [<a href="#updlq">1</a>]).
  The question is whether LINQ (and especially LINQ to SQL) provides any simple way to return only records that contain one or more of 
  specified keywords in the name. The question looks simple, but it is simple only if you know the number of keywords that you want to 
  look for. In this case you can write following LINQ query:</p>
<pre>
  <span class="c">// Products that contain "kwd1" or "kwd2" in the name </span><br />
  <span class="k">var</span> q = <span class="k">from</span> p <span class="k">in</span> db.Products
    <span class="k">where</span> p.ProductName.Contains("kwd1") || p.ProductName.Contains("kwd2")
    <span class="k">select</span> p;
</pre>
<p>The problem with previous code is that you can't use it if the list of keywords is dynamically entered by user
  (and so its length may vary). Of course, if you want to run query on in-memory data, you can get very nice results by
  writing extension method called <code>ContainsAny</code> that performs test for keyword array, but if you 
  want to be able to translate query to SQL, the situation is a bit complicated.</p>

<h2>Building expression tree</h2>
<p>The first solution is to build the whole expression tree that is used for filtering (in the <code>where</code> clause)
  using <code>Expression</code> object. The code that builds expression tree is much longer, because it must generate
  expression for calling method <code>Contains</code> for every keyword in the array. The following example shows how
  to build test for only two keywords for simplicity:</p>
<pre>
<span class="c">// build as many conditions as you need</span>
Expression t1 = Expression.CallVirtual(
   <span class="k">typeof</span>(<span class="k">string</span>).GetMethod("Contains"),
   Expression.Property(p, typeof(Product).GetProperty("ProductName")),
   <span class="k">new</span> Expression[] { Expression.Constant("Chef") });
Expression t2 = Expression.CallVirtual(
   <span class="k">typeof</span>(<span class="k">string</span>).GetMethod("Contains"), 
   Expression.Property(p, typeof(Product).GetProperty("ProductName")),
   <span class="k">new</span> Expression[] { Expression.Constant("Sir") });

<span class="c">// merge conditions using Expression.Or</span>
<br /><span class="k">var</span> test = Expression.Lambda&lt;Func&lt;Product, bool&gt;&gt;
  (Expression.Or(t1, t2), <span class="k">new</span> ParameterExpression[] { p });
<span class="k">var</span> filter = Queryable.Where(db.Products, test);

<span class="c">// Execute the query</span><br />
<span class="k">var</span> q = <span class="k">from</span> prod <span class="k">in</span> filter
   <span class="k">select</span> prod;
</pre>

<p>You might also think of using <code>Queryable.Union</code> method that returns union of results
  from several queries. Generating query using this method is possible and the code is less
  complicated, but the resulting SQL command generated by the LINQ to SQL is very poor and 
  it would be obviously slower. That's definitely not an issue in LINQ, because the query created using
  <code>Union</code> is very far from natural query that you would normally use.</p>

<h2>Better solution</h2>
<p>The previous solution can be used for generating any expression tree, so there will be always 
  certain situations, when this would be the only possible way, however I think that these two methods
  (<code>ContainsAny</code> and <code>ContainsAll</code>) will be used very often. I already wrote
  an extension to LINQ that allows you to 'call' expression tree in query [<a href="#updlq">3</a>], so I used this project
  and I added support for the following two methods:</p>
<pre>
<span class="k">using</span> EeekSoft.Query;

<span class="c">// Select products, that conain one of values from array in their name</span><br />
<span class="k">var</span> q1 = <span class="k">from</span> p <span class="k">in</span> db.Products.<b>ToExpandable()</b><br />
    <span class="k">where</span> p.ProductName.<b>ContainsAny("Sir", "Chef")</b><br />
    <span class="k">select new</span> { p.ProductName };

<span class="c">// Select products, that conain all of values from array in their name</span><br />
<span class="k">var</span> q1 = <span class="k">from</span> p <span class="k">in</span> db.Products.<b>ToExpandable()</b><br />
    <span class="k">where</span> p.ProductName.<b>ContainsAll("Gu", "Ca")</b><br />
    <span class="k">select new</span> { p.ProductName };
</pre>
<p>To be able to write this code, you have to download the library <code>EeekSoft.Query</code> first. [See <a href="#updlq">Downloads</a>]</p>

<h2>How does it work?</h2>
<p>I already described the method that I used here for extending the LINQ in my previous article [<a href="#updlq">3</a>], so 
  you can refer to it for more details. The important point is the call to the <code>ToExpandable</code> extension method.
  This method returns <code>IQueryable</code> wrapper around the original data source (data table in this case).
  When query is executed, this wrapper is called and it modifies the expression tree before it is passed to LINQ to SQL
  converter, so the methods like <code>ContainsAny</code> are replaced with some other expression that the LINQ to SQL 
  can understand.</p>

<h2>References and downloads<a name="updlq"></a></h2>
<ul class="ref">
  <li><a href="http://tomasp.net/articles/linq-expand-update/demos.zip">Download code samples</a> (29kB)</li>
</ul>
<ul class="ref">
  <li>[1] <a href="http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=582495">Dynamic conditions: How to achieve multiple "OR" conditions with LINQ?</a>
    [<a href="http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=582495" target="_blank">^</a>] - LINQ Project General - MSDN Forums (by marcioesteves)</li>  
  <li>[2] <a href="http://msdn.microsoft.com/data/ref/linq/">The LINQ Project</a>
    [<a href="http://msdn.microsoft.com/data/ref/linq/" target="_blank">^</a>] - Microsoft.com</li>
  <li>[3] <a href="http://tomasp.net/blog/linq-expand.aspx">Calling functions in LINQ queries</a>
    [<a href="http://tomasp.net/blog/linq-expand.aspx" target="_blank">^</a>] - Tomasp.net</li>
</ul>