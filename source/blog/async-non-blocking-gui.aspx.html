<!-- [info]

 - date: 2011-06-10T23:36:16.0000000
 - description: F# asynchronous workflows are mainly used for non-blocking I/O and concurrency, but they provide nice abstraction for writing user interface interactions. This article shows how to avoid blocking the user-interface when performing CPU-intensive processing.
 - tags: research,asynchronous,f#,functional
 - layout: post
 - title: Writing non-blocking user-interfaces in F#
 - url: async-non-blocking-gui.aspx

[/info] -->
<!-- [abstract]
<img src="http://tomasp.net/articles/async-non-blocking-calls/screen.png" style="float:right; margin:0px 0px 0px 15px;" />

<p>F# asynchronous workflows are best known as a way to write efficient I/O operations
  or as an underlying mechanism of F# agent-based programming (using the <code>MailboxProcessor</code>
  type). However, they are also very useful for user-interface programming. I think this is 
  a very interesting and important area, so I already wrote and talked about this topic - 
  it is covered in <a href="http://manning.com/petricek/">Chapter 16 of my book</a> (there
  is a <a href="http://dotnetslackers.com/articles/net/Programming-user-interfaces-using-f-sharp-workflows.aspx">free excerpt</a>)
  and I <a href="http://tomasp.net/blog/reactive-talk.aspx">talked about it</a> at F#unctional Londoners
  meeting.</p>

<p>Many applications combine user-interface programming (such as waiting for an event asynchronously)
  with some CPU-intensive tasks. This article looks at an example of such application and I'll explain 
  how to avoid blocking the user-interface when doing the CPU-intensive task. 
  The article starts with an example that is wrong and blocks the user-interface when doing data processing.
  Then I'll show you two options for fixing the problem. The three most important
  functions from the standard F# library that I'll discuss are <code>Async.StartChild</code> and 
  <code>Async.SwitchTo&#173;ThreadPool</code> with <code>Async.SwitchToContext</code>.</p>

<p>This is the first article of a mini-series. In the next article, I'll demonstrate a simple
  wrapper for F# <code>async</code> that makes it more difficult to write <em>wrong</em> 
  programs. The wrapper keeps the desired thread (GUI or background) in the type of the 
  computations and code that would block the user interface will not type-check. But first,
  let's look at the example...</p>
[/abstract] -->

<h1>Writing non-blocking user-interfaces in F#</h1>
<img src="http://tomasp.net/articles/async-non-blocking-calls/screen.png" style="float:right; margin:0px 0px 0px 15px;" />

<p>F# asynchronous workflows are best known as a way to write efficient I/O operations
  or as an underlying mechanism of F# agent-based programming (using the <code>MailboxProcessor</code>
  type). However, they are also very useful for user-interface programming. I think this is 
  a very interesting and important area, so I already wrote and talked about this topic - 
  it is covered in <a href="http://manning.com/petricek/">Chapter 16 of my book</a> (there
  is a <a href="http://dotnetslackers.com/articles/net/Programming-user-interfaces-using-f-sharp-workflows.aspx">free excerpt</a>)
  and I <a href="http://tomasp.net/blog/reactive-talk.aspx">talked about it</a> at F#unctional Londoners
  meeting.</p>

<p>Many applications combine user-interface programming (such as waiting for an event asynchronously)
  with some CPU-intensive tasks. This article looks at an example of such application and I'll explain 
  how to avoid blocking the user-interface when doing the CPU-intensive task. 
  The article starts with an example that is wrong and blocks the user-interface when doing data processing.
  Then I'll show you two options for fixing the problem. The three most important
  functions from the standard F# library that I'll discuss are <code>Async.StartChild</code> and 
  <code>Async.SwitchTo&#173;ThreadPool</code> with <code>Async.SwitchToContext</code>.</p>

<p>This is the first article of a mini-series. In the next article, I'll demonstrate a simple
  wrapper for F# <code>async</code> that makes it more difficult to write <em>wrong</em> 
  programs. The wrapper keeps the desired thread (GUI or background) in the type of the 
  computations and code that would block the user interface will not type-check. But first,
  let's look at the example...</p>

<h2>Showing stock prices in Silverlight</h2>
<p>The sample application is shown in a screenshot above (and you can get complete source 
  code from GitHub link at the end of the article). It consists of a client-side (Silverlight)
  application and simple server-side proxy that returns stock prices from Yahoo Finance.
  The client-side application generates buttons for a few stocks. When a button is clicked, 
  the application connects to the server and downloads the data (asynchronously).
  Then it does some CPU-intensive processing (currently just parse the data and then call
  <code>Thread.Sleep</code> for some time). Finally, it generates a chart and adds it to the
  user-interface.</p>

<h3>Processing data and creating charts</h3>
<p>Looking at the complete source is beyond the scope of the article, but this section shows
  the two most important helper functions that are both wrapped inside an asynchronous workflow.
  The <code>extractPrices</code> function gets the input data (as a string), does some processing
  and returns the result as an array of floats. It is CPU-bounded, so it will block the 
  executing thread for some time. To make this more obvious, I added <code>Thread.Sleep</code>
  (Note that <code>Async.Sleep</code> would behave differently, because that wouldn't block
  the thread). </p>
<p>The <code>displayChart</code> function is quite simple. It constructs user interface (using
  <code>createChart</code> not shown in the snippet) and then adds it to some existing <code>Canvas</code>
  object. The function is also written as an asynchronous workflow. This is not necessary now, 
  but it will make more sense in the next article.</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="c">///</span><span class="c"> </span><span class="c">Parse</span><span class="c"> </span><span class="c">downloaded</span><span class="c"> </span><span class="c">data</span><span class="c"> </span><span class="c">set.</span><span class="c"> </span><span class="c">This</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">a</span><span class="c"> </span><span class="c">CPU-expensive</span><span class="c"> </span>
<span class="l"> 2: </span><span class="c">///</span><span class="c"> </span><span class="c">computation</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">should</span><span class="c"> </span><span class="c">not</span><span class="c"> </span><span class="c">block</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">user-interface.</span>
<span class="l"> 3: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fstips1', 1)" onmouseover="showTip(event, 'fstips1', 1)" class="i">extractStockPrices</span> (<span onmouseout="hideTip(event, 'fstips2', 2)" onmouseover="showTip(event, 'fstips2', 2)" class="i">data</span><span class="o">:</span><span onmouseout="hideTip(event, 'fstips3', 3)" onmouseover="showTip(event, 'fstips3', 3)" class="i">string</span>) <span onmouseout="hideTip(event, 'fstips4', 4)" onmouseover="showTip(event, 'fstips4', 4)" class="i">count</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips5', 5)" onmouseover="showTip(event, 'fstips5', 5)" class="i">async</span> {
<span class="l"> 4: </span>  <span class="k">let</span> <span onmouseout="hideTip(event, 'fstips6', 6)" onmouseover="showTip(event, 'fstips6', 6)" class="i">dataLines</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips7', 7)" onmouseover="showTip(event, 'fstips7', 7)" class="omitted">(...)</span>
<span class="l"> 5: </span>  <span class="k">let</span> <span onmouseout="hideTip(event, 'fstips8', 8)" onmouseover="showTip(event, 'fstips8', 8)" class="i">data</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips9', 9)" onmouseover="showTip(event, 'fstips9', 9)" class="omitted">(...)</span>
<span class="l"> 6: </span>  <span class="c">//</span><span class="c"> </span><span class="c">Additional</span><span class="c"> </span><span class="c">CPU-bound</span><span class="c"> </span><span class="c">data</span><span class="c"> </span><span class="c">processing</span>
<span class="l"> 7: </span>  <span onmouseout="hideTip(event, 'fstips10', 10)" onmouseover="showTip(event, 'fstips10', 10)" class="i">Thread</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips11', 11)" onmouseover="showTip(event, 'fstips11', 11)" class="i">Sleep</span>(<span class="n">5000</span>)
<span class="l"> 8: </span>  <span class="k">return</span> <span onmouseout="hideTip(event, 'fstips8', 12)" onmouseover="showTip(event, 'fstips8', 12)" class="i">data</span> }
<span class="l"> 9: </span>
<span class="l">10: </span><span class="c">///</span><span class="c"> </span><span class="c">Create</span><span class="c"> </span><span class="c">&amp;</span><span class="c"> </span><span class="c">display</span><span class="c"> </span><span class="c">chart.</span><span class="c"> </span><span class="c">The</span><span class="c"> </span><span class="c">function</span><span class="c"> </span><span class="c">needs</span><span class="c"> </span><span class="c">to</span><span class="c"> </span>
<span class="l">11: </span><span class="c">///</span><span class="c"> </span><span class="c">access</span><span class="c"> </span><span class="c">user</span><span class="c"> </span><span class="c">interface</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">should</span><span class="c"> </span><span class="c">run</span><span class="c"> </span><span class="c">on</span><span class="c"> </span><span class="c">GUI</span><span class="c"> </span><span class="c">thread.</span>
<span class="l">12: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fstips12', 13)" onmouseover="showTip(event, 'fstips12', 13)" class="i">displayChart</span> <span onmouseout="hideTip(event, 'fstips13', 14)" onmouseover="showTip(event, 'fstips13', 14)" class="i">color</span> <span onmouseout="hideTip(event, 'fstips14', 15)" onmouseover="showTip(event, 'fstips14', 15)" class="i">prices</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips5', 16)" onmouseover="showTip(event, 'fstips5', 16)" class="i">async</span> {
<span class="l">13: </span>  <span class="k">let</span> <span onmouseout="hideTip(event, 'fstips15', 17)" onmouseover="showTip(event, 'fstips15', 17)" class="i">chart</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips16', 18)" onmouseover="showTip(event, 'fstips16', 18)" class="i">createChart</span> <span class="n">600.0</span> <span class="n">200.0</span> <span onmouseout="hideTip(event, 'fstips13', 19)" onmouseover="showTip(event, 'fstips13', 19)" class="i">color</span> <span onmouseout="hideTip(event, 'fstips14', 20)" onmouseover="showTip(event, 'fstips14', 20)" class="i">prices</span>
<span class="l">14: </span>  <span onmouseout="hideTip(event, 'fstips15', 21)" onmouseover="showTip(event, 'fstips15', 21)" class="i">chart</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips17', 22)" onmouseover="showTip(event, 'fstips17', 22)" class="i">SetValue</span>(<span onmouseout="hideTip(event, 'fstips18', 23)" onmouseover="showTip(event, 'fstips18', 23)" class="i">Canvas</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips19', 24)" onmouseover="showTip(event, 'fstips19', 24)" class="i">LeftProperty</span>, <span class="n">100.0</span>)
<span class="l">15: </span>  <span onmouseout="hideTip(event, 'fstips15', 25)" onmouseover="showTip(event, 'fstips15', 25)" class="i">chart</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips17', 26)" onmouseover="showTip(event, 'fstips17', 26)" class="i">SetValue</span>(<span onmouseout="hideTip(event, 'fstips18', 27)" onmouseover="showTip(event, 'fstips18', 27)" class="i">Canvas</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips20', 28)" onmouseover="showTip(event, 'fstips20', 28)" class="i">TopProperty</span>, <span class="n">100.0</span>)
<span class="l">16: </span>  <span onmouseout="hideTip(event, 'fstips21', 29)" onmouseover="showTip(event, 'fstips21', 29)" class="i">holder</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips22', 30)" onmouseover="showTip(event, 'fstips22', 30)" class="i">Children</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips23', 31)" onmouseover="showTip(event, 'fstips23', 31)" class="i">Clear</span>()
<span class="l">17: </span>  <span onmouseout="hideTip(event, 'fstips21', 32)" onmouseover="showTip(event, 'fstips21', 32)" class="i">holder</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips22', 33)" onmouseover="showTip(event, 'fstips22', 33)" class="i">Children</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips24', 34)" onmouseover="showTip(event, 'fstips24', 34)" class="i">Add</span>(<span onmouseout="hideTip(event, 'fstips15', 35)" onmouseover="showTip(event, 'fstips15', 35)" class="i">chart</span>) }</pre>

<p>The snippet shows fairly simple F# code. However, the important point is made in the 
  comments of the two functions. The <code>extractStockPrices</code> function should be executed
  on a background thread, because it blocks the thread and we don't want to make the
  user-interface non-responsive. The <code>displayChart</code> function must be executed
  on the GUI thread, because it accesses user-interface elements, which is only allowed
  from the GUI thread.</p>

<p>The desired threading model is an important thing to keep in mind when using asynchronous
  workflows. Of course, when this is written just as a comment, it is easy to make a mistake.
  In the next article, I'll show how to correct that and put this information into the
  <em>type</em> of the computation. First, let's look at the main workflow of the application 
  that calls both functions from the GUI thread.</p>

<h3>Running the application</h3>

<p>The application is implemented as an asynchronous workflow that contains a <code>while</code>
  loop that repeatedly waits for the user input (clicking on a button) and performs some reaction 
  (download &amp; process data and display chart). The body of the loop waits for the mouse click
  using <code>AwaitObservable</code>. After that, it downloads the data using <code>AsyncDownloadString</code>
  and then calls the two helper functions from the previous section. As mentioned earlier, this version 
  is wrong, because it runs the CPU-intensive function <code>extractStockPrices</code> on the GUI 
  thread. This means that it <strong>hangs the user-interface</strong>. The rest of the article
  shows two ways to fix this.</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fstips25', 36)" onmouseover="showTip(event, 'fstips25', 36)" class="i">main</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips5', 37)" onmouseover="showTip(event, 'fstips5', 37)" class="i">async</span> {
<span class="l"> 2: </span>  <span class="c">//</span><span class="c"> </span><span class="c">Construct</span><span class="c"> </span><span class="c">event</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">occurs</span><span class="c"> </span><span class="c">when</span><span class="c"> </span><span class="c">stock</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">selected</span>
<span class="l"> 3: </span>  <span class="k">let</span> <span onmouseout="hideTip(event, 'fstips26', 38)" onmouseover="showTip(event, 'fstips26', 38)" class="i">stockClicked</span> <span class="o">=</span>
<span class="l"> 4: </span>    [ <span class="k">for</span> <span onmouseout="hideTip(event, 'fstips27', 39)" onmouseover="showTip(event, 'fstips27', 39)" class="i">stock</span>, <span onmouseout="hideTip(event, 'fstips28', 40)" onmouseover="showTip(event, 'fstips28', 40)" class="i">btn</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fstips29', 41)" onmouseover="showTip(event, 'fstips29', 41)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips30', 42)" onmouseover="showTip(event, 'fstips30', 42)" class="i">zip</span> <span onmouseout="hideTip(event, 'fstips31', 43)" onmouseover="showTip(event, 'fstips31', 43)" class="i">stocks</span> <span onmouseout="hideTip(event, 'fstips32', 44)" onmouseover="showTip(event, 'fstips32', 44)" class="i">buttons</span> <span class="k">-&gt;</span>
<span class="l"> 5: </span>        <span onmouseout="hideTip(event, 'fstips28', 45)" onmouseover="showTip(event, 'fstips28', 45)" class="i">btn</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips33', 46)" onmouseover="showTip(event, 'fstips33', 46)" class="i">Click</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fstips34', 47)" onmouseover="showTip(event, 'fstips34', 47)" class="i">Observable</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips35', 48)" onmouseover="showTip(event, 'fstips35', 48)" class="i">map</span> (<span class="k">fun</span> _ <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fstips27', 49)" onmouseover="showTip(event, 'fstips27', 49)" class="i">stock</span>) ]
<span class="l"> 6: </span>    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fstips36', 50)" onmouseover="showTip(event, 'fstips36', 50)" class="i">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips37', 51)" onmouseover="showTip(event, 'fstips37', 51)" class="i">reduce</span> <span onmouseout="hideTip(event, 'fstips34', 52)" onmouseover="showTip(event, 'fstips34', 52)" class="i">Observable</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips38', 53)" onmouseover="showTip(event, 'fstips38', 53)" class="i">merge</span>
<span class="l"> 7: </span>  
<span class="l"> 8: </span>  <span class="c">//</span><span class="c"> </span><span class="c">The</span><span class="c"> </span><span class="c">main</span><span class="c"> </span><span class="c">application</span><span class="c"> </span><span class="c">loop</span>
<span class="l"> 9: </span>  <span class="k">while</span> <span class="k">true</span> <span class="k">do</span> 
<span class="l">10: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Wait</span><span class="c"> </span><span class="c">until</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">user</span><span class="c"> </span><span class="c">selects</span><span class="c"> </span><span class="c">stock</span><span class="c"> </span><span class="c">(GUI</span><span class="c"> </span><span class="c">operation)</span>
<span class="l">11: </span>    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fstips13', 54)" onmouseover="showTip(event, 'fstips13', 54)" class="i">color</span>, <span onmouseout="hideTip(event, 'fstips39', 55)" onmouseover="showTip(event, 'fstips39', 55)" class="i">stock</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips40', 56)" onmouseover="showTip(event, 'fstips40', 56)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips41', 57)" onmouseover="showTip(event, 'fstips41', 57)" class="i">AwaitObservable</span>(<span onmouseout="hideTip(event, 'fstips26', 58)" onmouseover="showTip(event, 'fstips26', 58)" class="i">stockClicked</span>)
<span class="l">12: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Download</span><span class="c"> </span><span class="c">data</span><span class="c"> </span><span class="c">for</span><span class="c"> </span><span class="c">stock</span><span class="c"> </span><span class="c">(non-blocking</span><span class="c"> </span><span class="c">operation)</span>
<span class="l">13: </span>    <span class="k">let</span> <span onmouseout="hideTip(event, 'fstips42', 59)" onmouseover="showTip(event, 'fstips42', 59)" class="i">wc</span> <span class="o">=</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fstips43', 60)" onmouseover="showTip(event, 'fstips43', 60)" class="i">WebClient</span>()
<span class="l">14: </span>    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fstips2', 61)" onmouseover="showTip(event, 'fstips2', 61)" class="i">data</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips42', 62)" onmouseover="showTip(event, 'fstips42', 62)" class="i">wc</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips44', 63)" onmouseover="showTip(event, 'fstips44', 63)" class="i">AsyncDownloadString</span>(<span onmouseout="hideTip(event, 'fstips45', 64)" onmouseover="showTip(event, 'fstips45', 64)" class="i">Uri</span>(<span onmouseout="hideTip(event, 'fstips46', 65)" onmouseover="showTip(event, 'fstips46', 65)" class="i">root</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fstips39', 66)" onmouseover="showTip(event, 'fstips39', 66)" class="i">stock</span>))    
<span class="l">15: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Process</span><span class="c"> </span><span class="c">data</span><span class="c"> </span><span class="c">(CPU-bound</span><span class="c"> </span><span class="c">operation)</span>
<span class="l">16: </span>    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fstips47', 67)" onmouseover="showTip(event, 'fstips47', 67)" class="i">prices</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips1', 68)" onmouseover="showTip(event, 'fstips1', 68)" class="i">extractStockPrices</span> <span onmouseout="hideTip(event, 'fstips2', 69)" onmouseover="showTip(event, 'fstips2', 69)" class="i">data</span> <span class="n">500</span>
<span class="l">17: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Create</span><span class="c"> </span><span class="c">&amp;</span><span class="c"> </span><span class="c">display</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">chart</span><span class="c"> </span><span class="c">(GUI</span><span class="c"> </span><span class="c">operation)</span>
<span class="l">18: </span>    <span class="k">do!</span> <span onmouseout="hideTip(event, 'fstips12', 70)" onmouseover="showTip(event, 'fstips12', 70)" class="i">displayChart</span> <span onmouseout="hideTip(event, 'fstips13', 71)" onmouseover="showTip(event, 'fstips13', 71)" class="i">color</span> <span onmouseout="hideTip(event, 'fstips47', 72)" onmouseover="showTip(event, 'fstips47', 72)" class="i">prices</span> }
<span class="l">19: </span>
<span class="l">20: </span><span class="c">//</span><span class="c"> </span><span class="c">Start</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">workflow</span><span class="c"> </span><span class="c">immediately</span><span class="c"> </span><span class="c">(on</span><span class="c"> </span><span class="c">GUI</span><span class="c"> </span><span class="c">thread)</span>
<span class="l">21: </span><span class="k">do</span> <span onmouseout="hideTip(event, 'fstips25', 73)" onmouseover="showTip(event, 'fstips25', 73)" class="i">main</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fstips40', 74)" onmouseover="showTip(event, 'fstips40', 74)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips48', 75)" onmouseover="showTip(event, 'fstips48', 75)" class="i">StartImmediate</span></pre>

<p>The construction of <code>stockClicked</code> event is quite interesting. It uses two collections 
  containing names of stocks with associated color (<code>stocks</code>) and button objects (<code>buttons</code>). Then
  it zips them and generates a list of events <code>IObservable&lt;Color * string&gt;</code>. Finally,
  it uses <code>List.reduce</code> with <code>Observable.merge</code> as an argument to create
  a single event that occurs whenever any of the events occur.</p>

<p>The rest of the workflow in the <code>while</code> loop is quite straightforward. The workflow is 
  started (on the GUI thread) using the <code>Async.StartImmedaite</code> function and all of the
  asynchronous operations return back to the GUI thread. In Silverlight, <code>WebClient</code> 
  automatically behaves like this, but the F# wrappers for other asynchronous operations guarantee
  the same behavior. This means that any part of the workflow can safely access the user-interface,
  but calling a CPU-intensive operation in the workflow causes the application to hang. To 
  correct this, we need to call <code>extractStockPrices</code> function differently...</p>

<h2>Processing data in background</h2>

<p>The standard F# library provides two options for running an asynchronous workflow 
  without blocking the current thread. One option is to start a workflow as a child 
  (on another thread) and asynchronously wait until it completes. The second option is
  to switch the current workflow to another thread, do the heavy computation and then
  switch back. The following examples show both of the options.</p>

<h3>Starting child workflow</h3>
<p>The <code>Async.StartChild</code> operation has a type <code>Async&lt;'T&gt; -&gt; Async&lt;Async&lt;'T&gt;&gt;</code>.
  It creates a new asynchronous workflow that, when started, runs the work on some background thread and returns
  a "token" (of type <code>Async&lt;'T&gt;</code>) that can be used to wait until the operation completes.
  This waiting is done without blocking the current thread, so it is safe to do it on the GUI thread.
  The main workflow of the application can be written like this:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fstips49', 76)" onmouseover="showTip(event, 'fstips49', 76)" class="i">main</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips5', 77)" onmouseover="showTip(event, 'fstips5', 77)" class="i">async</span> {
<span class="l"> 2: </span>  <span onmouseout="hideTip(event, 'fstips50', 78)" onmouseover="showTip(event, 'fstips50', 78)" class="omitted">(Initialization omitted)</span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>  <span class="c">//</span><span class="c"> </span><span class="c">The</span><span class="c"> </span><span class="c">main</span><span class="c"> </span><span class="c">application</span><span class="c"> </span><span class="c">loop</span>
<span class="l"> 5: </span>  <span class="k">while</span> <span class="k">true</span> <span class="k">do</span> 
<span class="l"> 6: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Wait</span><span class="c"> </span><span class="c">until</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">user</span><span class="c"> </span><span class="c">selects</span><span class="c"> </span><span class="c">stock</span><span class="c"> </span><span class="c">(GUI</span><span class="c"> </span><span class="c">operation)</span>
<span class="l"> 7: </span>    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fstips13', 79)" onmouseover="showTip(event, 'fstips13', 79)" class="i">color</span>, <span onmouseout="hideTip(event, 'fstips39', 80)" onmouseover="showTip(event, 'fstips39', 80)" class="i">stock</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips40', 81)" onmouseover="showTip(event, 'fstips40', 81)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips41', 82)" onmouseover="showTip(event, 'fstips41', 82)" class="i">AwaitObservable</span>(<span onmouseout="hideTip(event, 'fstips26', 83)" onmouseover="showTip(event, 'fstips26', 83)" class="i">stockClicked</span>)
<span class="l"> 8: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Download</span><span class="c"> </span><span class="c">data</span><span class="c"> </span><span class="c">for</span><span class="c"> </span><span class="c">stock</span><span class="c"> </span><span class="c">(non-blocking</span><span class="c"> </span><span class="c">operation)</span>
<span class="l"> 9: </span>    <span class="k">let</span> <span onmouseout="hideTip(event, 'fstips42', 84)" onmouseover="showTip(event, 'fstips42', 84)" class="i">wc</span> <span class="o">=</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fstips43', 85)" onmouseover="showTip(event, 'fstips43', 85)" class="i">WebClient</span>()
<span class="l">10: </span>    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fstips2', 86)" onmouseover="showTip(event, 'fstips2', 86)" class="i">data</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips42', 87)" onmouseover="showTip(event, 'fstips42', 87)" class="i">wc</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips44', 88)" onmouseover="showTip(event, 'fstips44', 88)" class="i">AsyncDownloadString</span>(<span onmouseout="hideTip(event, 'fstips45', 89)" onmouseover="showTip(event, 'fstips45', 89)" class="i">Uri</span>(<span onmouseout="hideTip(event, 'fstips46', 90)" onmouseover="showTip(event, 'fstips46', 90)" class="i">root</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fstips39', 91)" onmouseover="showTip(event, 'fstips39', 91)" class="i">stock</span>))    
<span class="l">11: </span>    
<span class="l">12: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Process</span><span class="c"> </span><span class="c">data</span><span class="c"> </span><span class="c">(CPU-bound</span><span class="c"> </span><span class="c">operation)</span>
<span class="l">13: </span>    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fstips51', 92)" onmouseover="showTip(event, 'fstips51', 92)" class="i">token</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips40', 93)" onmouseover="showTip(event, 'fstips40', 93)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips52', 94)" onmouseover="showTip(event, 'fstips52', 94)" class="i">StartChild</span>(<span onmouseout="hideTip(event, 'fstips1', 95)" onmouseover="showTip(event, 'fstips1', 95)" class="i">extractStockPrices</span> <span onmouseout="hideTip(event, 'fstips2', 96)" onmouseover="showTip(event, 'fstips2', 96)" class="i">data</span> <span class="n">500</span>)
<span class="l">14: </span>    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fstips47', 97)" onmouseover="showTip(event, 'fstips47', 97)" class="i">prices</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips51', 98)" onmouseover="showTip(event, 'fstips51', 98)" class="i">token</span>
<span class="l">15: </span>
<span class="l">16: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Create</span><span class="c"> </span><span class="c">&amp;</span><span class="c"> </span><span class="c">display</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">chart</span><span class="c"> </span><span class="c">(GUI</span><span class="c"> </span><span class="c">operation)</span>
<span class="l">17: </span>    <span class="k">do!</span> <span onmouseout="hideTip(event, 'fstips12', 99)" onmouseover="showTip(event, 'fstips12', 99)" class="i">displayChart</span> <span onmouseout="hideTip(event, 'fstips13', 100)" onmouseover="showTip(event, 'fstips13', 100)" class="i">color</span> <span onmouseout="hideTip(event, 'fstips47', 101)" onmouseover="showTip(event, 'fstips47', 101)" class="i">prices</span> }</pre>

<p>The only change is on the lines 13 and 14. The first line starts the computation 
  as a child (in the background) by using <code>let!</code> on the result of 
  <code>StartChild</code>. This completes immediately and the workflow can then 
  continue doing some other work (e.g. spawn more background tasks to implement
  parallelism). The example in this article doesn't need to do anything else - it 
  just needs to (asynchronously) wait until the task completes, which is 
  done using the second <code>let!</code> construct.</p>

<p>The <code>StartChild</code> operation from the previous section can be used to implement
  parallelism. It can be used (by using two subsequent <code>let!</code>) to delegate long-running 
  CPU-intensive computations to another thread, but that's probably not the main use.</p>

<h3>Switching between threads</h3>

<p>The other way to avoid running a part of the workflow on the current (GUI) thread is to 
  switch from the GUI thread to a background thread and then back. This can be done using
  two standard operations of the <code>Async</code> type, namely <code>SwitchToThreadPool</code>
  and <code>SwitchToContext</code>. The only thing that the operations do is that they
  resume the workflow (run the continuation) on a different thread. The following snippet
  shows how to use the two operations to rewrite the main workflow of the example:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fstips53', 102)" onmouseover="showTip(event, 'fstips53', 102)" class="i">main</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips5', 103)" onmouseover="showTip(event, 'fstips5', 103)" class="i">async</span> {
<span class="l"> 2: </span>  <span onmouseout="hideTip(event, 'fstips50', 104)" onmouseover="showTip(event, 'fstips50', 104)" class="omitted">(Initialization omitted)</span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>  <span class="c">//</span><span class="c"> </span><span class="c">The</span><span class="c"> </span><span class="c">main</span><span class="c"> </span><span class="c">application</span><span class="c"> </span><span class="c">loop</span>
<span class="l"> 5: </span>  <span class="k">while</span> <span class="k">true</span> <span class="k">do</span> 
<span class="l"> 6: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Wait</span><span class="c"> </span><span class="c">until</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">user</span><span class="c"> </span><span class="c">selects</span><span class="c"> </span><span class="c">stock</span><span class="c"> </span><span class="c">(GUI</span><span class="c"> </span><span class="c">operation)</span>
<span class="l"> 7: </span>    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fstips13', 105)" onmouseover="showTip(event, 'fstips13', 105)" class="i">color</span>, <span onmouseout="hideTip(event, 'fstips39', 106)" onmouseover="showTip(event, 'fstips39', 106)" class="i">stock</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips40', 107)" onmouseover="showTip(event, 'fstips40', 107)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips41', 108)" onmouseover="showTip(event, 'fstips41', 108)" class="i">AwaitObservable</span>(<span onmouseout="hideTip(event, 'fstips26', 109)" onmouseover="showTip(event, 'fstips26', 109)" class="i">stockClicked</span>)
<span class="l"> 8: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Download</span><span class="c"> </span><span class="c">data</span><span class="c"> </span><span class="c">for</span><span class="c"> </span><span class="c">stock</span><span class="c"> </span><span class="c">(non-blocking</span><span class="c"> </span><span class="c">operation)</span>
<span class="l"> 9: </span>    <span class="k">let</span> <span onmouseout="hideTip(event, 'fstips42', 110)" onmouseover="showTip(event, 'fstips42', 110)" class="i">wc</span> <span class="o">=</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fstips43', 111)" onmouseover="showTip(event, 'fstips43', 111)" class="i">WebClient</span>()
<span class="l">10: </span>    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fstips2', 112)" onmouseover="showTip(event, 'fstips2', 112)" class="i">data</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips42', 113)" onmouseover="showTip(event, 'fstips42', 113)" class="i">wc</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips44', 114)" onmouseover="showTip(event, 'fstips44', 114)" class="i">AsyncDownloadString</span>(<span onmouseout="hideTip(event, 'fstips45', 115)" onmouseover="showTip(event, 'fstips45', 115)" class="i">Uri</span>(<span onmouseout="hideTip(event, 'fstips46', 116)" onmouseover="showTip(event, 'fstips46', 116)" class="i">root</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fstips39', 117)" onmouseover="showTip(event, 'fstips39', 117)" class="i">stock</span>))    
<span class="l">11: </span>
<span class="l">12: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Process</span><span class="c"> </span><span class="c">data</span><span class="c"> </span><span class="c">(CPU-bound</span><span class="c"> </span><span class="c">operation)</span>
<span class="l">13: </span>    <span class="k">let</span> <span onmouseout="hideTip(event, 'fstips54', 118)" onmouseover="showTip(event, 'fstips54', 118)" class="i">ctx</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips55', 119)" onmouseover="showTip(event, 'fstips55', 119)" class="i">SynchronizationContext</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips56', 120)" onmouseover="showTip(event, 'fstips56', 120)" class="i">Current</span>
<span class="l">14: </span>    <span class="k">do!</span> <span onmouseout="hideTip(event, 'fstips40', 121)" onmouseover="showTip(event, 'fstips40', 121)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips57', 122)" onmouseover="showTip(event, 'fstips57', 122)" class="i">SwitchToThreadPool</span>()
<span class="l">15: </span>    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fstips47', 123)" onmouseover="showTip(event, 'fstips47', 123)" class="i">prices</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fstips1', 124)" onmouseover="showTip(event, 'fstips1', 124)" class="i">extractStockPrices</span> <span onmouseout="hideTip(event, 'fstips2', 125)" onmouseover="showTip(event, 'fstips2', 125)" class="i">data</span> <span class="n">500</span>
<span class="l">16: </span>    <span class="k">do!</span> <span onmouseout="hideTip(event, 'fstips40', 126)" onmouseover="showTip(event, 'fstips40', 126)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fstips58', 127)" onmouseover="showTip(event, 'fstips58', 127)" class="i">SwitchToContext</span>(<span onmouseout="hideTip(event, 'fstips54', 128)" onmouseover="showTip(event, 'fstips54', 128)" class="i">ctx</span>)
<span class="l">17: </span>
<span class="l">18: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Create</span><span class="c"> </span><span class="c">&amp;</span><span class="c"> </span><span class="c">display</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">chart</span><span class="c"> </span><span class="c">(GUI</span><span class="c"> </span><span class="c">operation)</span>
<span class="l">19: </span>    <span class="k">do!</span> <span onmouseout="hideTip(event, 'fstips12', 129)" onmouseover="showTip(event, 'fstips12', 129)" class="i">displayChart</span> <span onmouseout="hideTip(event, 'fstips13', 130)" onmouseover="showTip(event, 'fstips13', 130)" class="i">color</span> <span onmouseout="hideTip(event, 'fstips47', 131)" onmouseover="showTip(event, 'fstips47', 131)" class="i">prices</span> }</pre>

<p>The new behavior is implemented on lines 13 - 16. The workflow first needs to store the current synchronization context,
  which is obtained using <code>SynchronizationContext.Current</code> while the workflow still runs on the main GUI thread.
  Next, the snippet calls the <code>SwitchToThreadPool</code> operation. The return type of the method is 
  <code>Async&lt;unit&gt;</code>, which means that it can be called using the <code>do!</code> syntax. The result of the
  call is that the rest of the workflow (starting on line 15) is executed on a thread pool thread. Then the snippet can
  safely run the CPU-intensive processing using <code>extractStockPrices</code>. Once the CPU-intensive computation 
  completes, the workflow switches back to the GUI thread using <code>SwitchToContext</code> with the original
  context as an argument.</p>

<h2>Summary</h2>

<p>The approach based on switching is slightly longer, but it has an interesting advantage - the values that
  were declared on another thread (line 15) are still available after returning back to the original thread.
  This is safe, because the entire computation is sequential, so the variables are always accessed from just
  a single thread. When using <code>Async.StartChild</code>, all results need to be explicitly returned as the
  result of the child workflow and then assigned to some variables (using <code>let!</code>), so the 
  code can become more complex.</p>

<p>One possible disadvantage of the second approach is that it is easier to make a mistake. If we forgot the
  call to <code>Async.SwitchToContext</code> (line 16) then the program would compile, but it would fail
  at runtime, because it would attempt to access the user-interface elements (in the <code>displayChart</code>
  function) from a thread-pool thread. The <code>Async&lt;'T&gt;</code> can be extended to catch this
  kind of errors at compile time and I'll cover that in the next article.</p>

<h3>Downloads &amp; Source code</h3>
<ul>
  <li>Browse <a href="http://github.com/tpetricek/Documents/tree/master/Blog%202011/AsyncNonBlocking">the source code on GitHub</a></li>
  <li>Download <a href="http://github.com/tpetricek/Documents/raw/master/Blog%202011/AsyncNonBlocking/stockdata.zip">the source code</a> (ZIP)</li>
</ul>






<!-- HTML code for ToolTips -->
<div class="tip" id="fstips1">val extractStockPrices : string -&gt; int -&gt; Async&lt;float []&gt;<br /><br />Full name: Demo.StandardAsync.extractStockPrices
<br /><br /><em>Parse downloaded data set. This is a CPU-expensive <br />&#160;computation that should not block the user-interface.</em><br /></div>
<div class="tip" id="fstips2">val data : string<br /><br />&#160;&#160;type: string<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;string&gt;<br />&#160;&#160;implements: seq&lt;char&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;implements: IEquatable&lt;string&gt;<br /></div>
<div class="tip" id="fstips3">Multiple items
<br />val string : &#39;T -&gt; string<br /><br />Full name: Microsoft.FSharp.Core.Operators.string
<br /><br />--------------------<br />
<br />type string = String<br /><br />Full name: Microsoft.FSharp.Core.string<br /><br />&#160;&#160;type: string<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;string&gt;<br />&#160;&#160;implements: seq&lt;char&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;implements: IEquatable&lt;string&gt;<br /></div>
<div class="tip" id="fstips4">val count : int<br /><br />&#160;&#160;type: int<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: IFormattable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;int&gt;<br />&#160;&#160;implements: IEquatable&lt;int&gt;<br />&#160;&#160;inherits: ValueType<br /></div>
<div class="tip" id="fstips5">val async : AsyncBuilder<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.async<br /></div>
<div class="tip" id="fstips6">val dataLines : string []<br /><br />&#160;&#160;type: string []<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: Collections.IList<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: Collections.Generic.IList&lt;string&gt;<br />&#160;&#160;implements: Collections.Generic.ICollection&lt;string&gt;<br />&#160;&#160;implements: seq&lt;string&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;inherits: Array<br /></div>
<div class="tip" id="fstips7">data.Split([| &#39;\n&#39; |], StringSplitOptions.RemoveEmptyEntries) <br /></div>
<div class="tip" id="fstips8">val data : float []<br /><br />&#160;&#160;type: float []<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: Collections.IList<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: Collections.Generic.IList&lt;float&gt;<br />&#160;&#160;implements: Collections.Generic.ICollection&lt;float&gt;<br />&#160;&#160;implements: seq&lt;float&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;inherits: Array<br /></div>
<div class="tip" id="fstips9">[| for line in dataLines |&gt; Seq.skip 1 do<br />&#160;&#160;&#160;&#160;&#160;let infos = line.Split(&#39;,&#39;)<br />&#160;&#160;&#160;&#160;&#160;yield float infos.[1] |]<br />|&gt; Seq.take count |&gt; Array.ofSeq |&gt; Array.rev <br /></div>
<div class="tip" id="fstips10">type Thread =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;inherit System.Runtime.ConstrainedExecution.CriticalFinalizerObject<br />&#160;&#160;&#160;&#160;new : System.Threading.ThreadStart -&gt; System.Threading.Thread<br />&#160;&#160;&#160;&#160;new : System.Threading.ThreadStart * int -&gt; System.Threading.Thread<br />&#160;&#160;&#160;&#160;new : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread<br />&#160;&#160;&#160;&#160;new : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread<br />&#160;&#160;&#160;&#160;member Abort : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Abort : obj -&gt; unit<br />&#160;&#160;&#160;&#160;member ApartmentState : System.Threading.ApartmentState with get, set<br />&#160;&#160;&#160;&#160;member CurrentCulture : System.Globalization.CultureInfo with get, set<br />&#160;&#160;&#160;&#160;member CurrentUICulture : System.Globalization.CultureInfo with get, set<br />&#160;&#160;&#160;&#160;member DisableComObjectEagerCleanup : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member ExecutionContext : System.Threading.ExecutionContext<br />&#160;&#160;&#160;&#160;member GetApartmentState : unit -&gt; System.Threading.ApartmentState<br />&#160;&#160;&#160;&#160;member GetCompressedStack : unit -&gt; System.Threading.CompressedStack<br />&#160;&#160;&#160;&#160;member GetHashCode : unit -&gt; int<br />&#160;&#160;&#160;&#160;member Interrupt : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member IsAlive : bool<br />&#160;&#160;&#160;&#160;member IsBackground : bool with get, set<br />&#160;&#160;&#160;&#160;member IsThreadPoolThread : bool<br />&#160;&#160;&#160;&#160;member Join : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Join : int -&gt; bool<br />&#160;&#160;&#160;&#160;member Join : System.TimeSpan -&gt; bool<br />&#160;&#160;&#160;&#160;member ManagedThreadId : int<br />&#160;&#160;&#160;&#160;member Name : string with get, set<br />&#160;&#160;&#160;&#160;member Priority : System.Threading.ThreadPriority with get, set<br />&#160;&#160;&#160;&#160;member Resume : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member SetApartmentState : System.Threading.ApartmentState -&gt; unit<br />&#160;&#160;&#160;&#160;member SetCompressedStack : System.Threading.CompressedStack -&gt; unit<br />&#160;&#160;&#160;&#160;member Start : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Start : obj -&gt; unit<br />&#160;&#160;&#160;&#160;member Suspend : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member ThreadState : System.Threading.ThreadState<br />&#160;&#160;&#160;&#160;member TrySetApartmentState : System.Threading.ApartmentState -&gt; bool<br />&#160;&#160;&#160;&#160;static member AllocateDataSlot : unit -&gt; System.LocalDataStoreSlot<br />&#160;&#160;&#160;&#160;static member AllocateNamedDataSlot : string -&gt; System.LocalDataStoreSlot<br />&#160;&#160;&#160;&#160;static member BeginCriticalRegion : unit -&gt; unit<br />&#160;&#160;&#160;&#160;static member BeginThreadAffinity : unit -&gt; unit<br />&#160;&#160;&#160;&#160;static member CurrentContext : System.Runtime.Remoting.Contexts.Context<br />&#160;&#160;&#160;&#160;static member CurrentPrincipal : System.Security.Principal.IPrincipal with get, set<br />&#160;&#160;&#160;&#160;static member CurrentThread : System.Threading.Thread<br />&#160;&#160;&#160;&#160;static member EndCriticalRegion : unit -&gt; unit<br />&#160;&#160;&#160;&#160;static member EndThreadAffinity : unit -&gt; unit<br />&#160;&#160;&#160;&#160;static member FreeNamedDataSlot : string -&gt; unit<br />&#160;&#160;&#160;&#160;static member GetData : System.LocalDataStoreSlot -&gt; obj<br />&#160;&#160;&#160;&#160;static member GetDomain : unit -&gt; System.AppDomain<br />&#160;&#160;&#160;&#160;static member GetDomainID : unit -&gt; int<br />&#160;&#160;&#160;&#160;static member GetNamedDataSlot : string -&gt; System.LocalDataStoreSlot<br />&#160;&#160;&#160;&#160;static member MemoryBarrier : unit -&gt; unit<br />&#160;&#160;&#160;&#160;static member ResetAbort : unit -&gt; unit<br />&#160;&#160;&#160;&#160;static member SetData : System.LocalDataStoreSlot * obj -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sleep : int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sleep : System.TimeSpan -&gt; unit<br />&#160;&#160;&#160;&#160;static member SpinWait : int -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileRead : System.Byte -&gt; System.Byte<br />&#160;&#160;&#160;&#160;static member VolatileRead : int16 -&gt; int16<br />&#160;&#160;&#160;&#160;static member VolatileRead : int -&gt; int<br />&#160;&#160;&#160;&#160;static member VolatileRead : int64 -&gt; int64<br />&#160;&#160;&#160;&#160;static member VolatileRead : System.SByte -&gt; System.SByte<br />&#160;&#160;&#160;&#160;static member VolatileRead : uint16 -&gt; uint16<br />&#160;&#160;&#160;&#160;static member VolatileRead : uint32 -&gt; uint32<br />&#160;&#160;&#160;&#160;static member VolatileRead : System.IntPtr -&gt; System.IntPtr<br />&#160;&#160;&#160;&#160;static member VolatileRead : System.UIntPtr -&gt; System.UIntPtr<br />&#160;&#160;&#160;&#160;static member VolatileRead : uint64 -&gt; uint64<br />&#160;&#160;&#160;&#160;static member VolatileRead : float32 -&gt; float32<br />&#160;&#160;&#160;&#160;static member VolatileRead : float -&gt; float<br />&#160;&#160;&#160;&#160;static member VolatileRead : obj -&gt; obj<br />&#160;&#160;&#160;&#160;static member VolatileWrite : System.Byte * System.Byte -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : int16 * int16 -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : int64 * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : System.SByte * System.SByte -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : uint16 * uint16 -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : uint32 * uint32 -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : System.IntPtr * System.IntPtr -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : System.UIntPtr * System.UIntPtr -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : uint64 * uint64 -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : float32 * float32 -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : float * float -&gt; unit<br />&#160;&#160;&#160;&#160;static member VolatileWrite : obj * obj -&gt; unit<br />&#160;&#160;&#160;&#160;static member Yield : unit -&gt; bool<br />&#160;&#160;end<br /><br />Full name: System.Threading.Thread<br /><br />&#160;&#160;type: Thread<br />&#160;&#160;implements: Runtime.InteropServices._Thread<br />&#160;&#160;inherits: Runtime.ConstrainedExecution.CriticalFinalizerObject<br /></div>
<div class="tip" id="fstips11">Multiple overloads
<br />Thread.Sleep(timeout: TimeSpan) : unit
<br />Thread.Sleep(millisecondsTimeout: int) : unit<br /></div>
<div class="tip" id="fstips12">val displayChart : Color -&gt; seq&lt;float&gt; -&gt; Async&lt;unit&gt;<br /><br />Full name: Demo.StandardAsync.displayChart
<br /><br /><em>Create &amp; display chart. The function needs to <br />&#160;access user interface and should run on GUI thread.</em><br /></div>
<div class="tip" id="fstips13">val color : Color<br /><br />&#160;&#160;type: Color<br />&#160;&#160;implements: IFormattable<br />&#160;&#160;inherits: ValueType<br /></div>
<div class="tip" id="fstips14">val prices : seq&lt;float&gt;<br /><br />&#160;&#160;type: seq&lt;float&gt;<br />&#160;&#160;inherits: Collections.IEnumerable<br /></div>
<div class="tip" id="fstips15">val chart : Canvas<br /><br />&#160;&#160;type: Canvas<br />&#160;&#160;implements: MS.Internal.IManagedPeer<br />&#160;&#160;implements: MS.Internal.IManagedPeerBase<br />&#160;&#160;implements: MS.Internal.INativeCoreTypeWrapper<br />&#160;&#160;implements: Automation.IAutomationElement<br />&#160;&#160;inherits: Panel<br />&#160;&#160;inherits: FrameworkElement<br />&#160;&#160;inherits: UIElement<br />&#160;&#160;inherits: DependencyObject<br /></div>
<div class="tip" id="fstips16">val createChart : float -&gt; float -&gt; Color -&gt; seq&lt;float&gt; -&gt; Canvas<br /><br />Full name: Demo.Core.createChart<br /></div>
<div class="tip" id="fstips17">DependencyObject.SetValue(dp: DependencyProperty, value: obj) : unit<br /></div>
<div class="tip" id="fstips18">type Canvas =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;inherit System.Windows.Controls.Panel<br />&#160;&#160;&#160;&#160;new : unit -&gt; System.Windows.Controls.Canvas<br />&#160;&#160;&#160;&#160;static val LeftProperty : System.Windows.DependencyProperty<br />&#160;&#160;&#160;&#160;static val TopProperty : System.Windows.DependencyProperty<br />&#160;&#160;&#160;&#160;static val ZIndexProperty : System.Windows.DependencyProperty<br />&#160;&#160;&#160;&#160;static member GetLeft : System.Windows.UIElement -&gt; float<br />&#160;&#160;&#160;&#160;static member GetTop : System.Windows.UIElement -&gt; float<br />&#160;&#160;&#160;&#160;static member GetZIndex : System.Windows.UIElement -&gt; int<br />&#160;&#160;&#160;&#160;static member SetLeft : System.Windows.UIElement * float -&gt; unit<br />&#160;&#160;&#160;&#160;static member SetTop : System.Windows.UIElement * float -&gt; unit<br />&#160;&#160;&#160;&#160;static member SetZIndex : System.Windows.UIElement * int -&gt; unit<br />&#160;&#160;end<br /><br />Full name: System.Windows.Controls.Canvas<br /><br />&#160;&#160;type: Canvas<br />&#160;&#160;implements: MS.Internal.IManagedPeer<br />&#160;&#160;implements: MS.Internal.IManagedPeerBase<br />&#160;&#160;implements: MS.Internal.INativeCoreTypeWrapper<br />&#160;&#160;implements: Automation.IAutomationElement<br />&#160;&#160;inherits: Panel<br />&#160;&#160;inherits: FrameworkElement<br />&#160;&#160;inherits: UIElement<br />&#160;&#160;inherits: DependencyObject<br /></div>
<div class="tip" id="fstips19">field Canvas.LeftProperty<br /></div>
<div class="tip" id="fstips20">field Canvas.TopProperty<br /></div>
<div class="tip" id="fstips21">val holder : Canvas<br /><br />Full name: Demo.Core.holder<br /><br />&#160;&#160;type: Canvas<br />&#160;&#160;implements: MS.Internal.IManagedPeer<br />&#160;&#160;implements: MS.Internal.IManagedPeerBase<br />&#160;&#160;implements: MS.Internal.INativeCoreTypeWrapper<br />&#160;&#160;implements: Automation.IAutomationElement<br />&#160;&#160;inherits: Panel<br />&#160;&#160;inherits: FrameworkElement<br />&#160;&#160;inherits: UIElement<br />&#160;&#160;inherits: DependencyObject<br /></div>
<div class="tip" id="fstips22">property Panel.Children: UIElementCollection<br /></div>
<div class="tip" id="fstips23">PresentationFrameworkCollection.Clear() : unit<br /></div>
<div class="tip" id="fstips24">PresentationFrameworkCollection.Add(value: UIElement) : unit<br /></div>
<div class="tip" id="fstips25">val main : Async&lt;unit&gt;<br /><br />Full name: Demo.StandardAsync.main<br /></div>
<div class="tip" id="fstips26">val stockClicked : IObservable&lt;Color * string&gt;<br /></div>
<div class="tip" id="fstips27">val stock : Color * string<br /></div>
<div class="tip" id="fstips28">val btn : Button<br /><br />&#160;&#160;type: Button<br />&#160;&#160;implements: MS.Internal.IManagedPeer<br />&#160;&#160;implements: MS.Internal.IManagedPeerBase<br />&#160;&#160;implements: MS.Internal.INativeCoreTypeWrapper<br />&#160;&#160;implements: Automation.IAutomationElement<br />&#160;&#160;inherits: Primitives.ButtonBase<br />&#160;&#160;inherits: ContentControl<br />&#160;&#160;inherits: Control<br />&#160;&#160;inherits: FrameworkElement<br />&#160;&#160;inherits: UIElement<br />&#160;&#160;inherits: DependencyObject<br /></div>
<div class="tip" id="fstips29">module Seq<br /><br />from Microsoft.FSharp.Collections<br /></div>
<div class="tip" id="fstips30">val zip : seq&lt;&#39;T1&gt; -&gt; seq&lt;&#39;T2&gt; -&gt; seq&lt;&#39;T1 * &#39;T2&gt;<br /><br />Full name: Microsoft.FSharp.Collections.Seq.zip<br /></div>
<div class="tip" id="fstips31">val stocks : (Color * string) list<br /><br />Full name: Demo.Core.stocks<br /><br />&#160;&#160;type: (Color * string) list<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: IComparable&lt;List&lt;Color * string&gt;&gt;<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.Generic.IEnumerable&lt;Color * string&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fstips32">val buttons : Button list<br /><br />Full name: Demo.StandardAsync.buttons<br /><br />&#160;&#160;type: Button list<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: IComparable&lt;List&lt;Button&gt;&gt;<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.Generic.IEnumerable&lt;Button&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fstips33">event Primitives.ButtonBase.Click: IEvent&lt;RoutedEventHandler,RoutedEventArgs&gt;<br /></div>
<div class="tip" id="fstips34">module Observable<br /><br />from Microsoft.FSharp.Control<br /></div>
<div class="tip" id="fstips35">val map : (&#39;T -&gt; &#39;U) -&gt; IObservable&lt;&#39;T&gt; -&gt; IObservable&lt;&#39;U&gt;<br /><br />Full name: Microsoft.FSharp.Control.Observable.map<br /></div>
<div class="tip" id="fstips36">Multiple items
<br />module List<br /><br />from Microsoft.FSharp.Collections
<br /><br />--------------------<br />
<br />type List&lt;&#39;T&gt; =<br />&#160;&#160;| ( [] )<br />&#160;&#160;| ( :: ) of &#39;T * &#39;T list<br />&#160;&#160;with<br />&#160;&#160;&#160;&#160;interface Collections.IEnumerable<br />&#160;&#160;&#160;&#160;interface Collections.Generic.IEnumerable&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member Head : &#39;T<br />&#160;&#160;&#160;&#160;member IsEmpty : bool<br />&#160;&#160;&#160;&#160;member Item : index:int -&gt; &#39;T with get<br />&#160;&#160;&#160;&#160;member Length : int<br />&#160;&#160;&#160;&#160;member Tail : &#39;T list<br />&#160;&#160;&#160;&#160;static member Cons : head:&#39;T * tail:&#39;T list -&gt; &#39;T list<br />&#160;&#160;&#160;&#160;static member Empty : &#39;T list<br />&#160;&#160;end<br /><br />Full name: Microsoft.FSharp.Collections.List&lt;_&gt;<br /><br />&#160;&#160;type: List&lt;&#39;T&gt;<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: IComparable&lt;List&lt;&#39;T&gt;&gt;<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.Generic.IEnumerable&lt;&#39;T&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fstips37">val reduce : (&#39;T -&gt; &#39;T -&gt; &#39;T) -&gt; &#39;T list -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Collections.List.reduce<br /></div>
<div class="tip" id="fstips38">val merge : IObservable&lt;&#39;T&gt; -&gt; IObservable&lt;&#39;T&gt; -&gt; IObservable&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Observable.merge<br /></div>
<div class="tip" id="fstips39">val stock : string<br /><br />&#160;&#160;type: string<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;string&gt;<br />&#160;&#160;implements: seq&lt;char&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;implements: IEquatable&lt;string&gt;<br /></div>
<div class="tip" id="fstips40">Multiple items
<br />type Async&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Async&lt;_&gt;
<br /><br />--------------------<br />
<br />type Async<br />with<br />&#160;&#160;static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)<br />&#160;&#160;static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)<br />&#160;&#160;static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />&#160;&#160;static member AwaitTask : task:Tasks.Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />&#160;&#160;static member CancelDefaultToken : unit -&gt; unit<br />&#160;&#160;static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;<br />&#160;&#160;static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromBeginEnd : arg:&#39;Arg1 * beginAction:(&#39;Arg1 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * beginAction:(&#39;Arg1 * &#39;Arg2 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * arg3:&#39;Arg3 * beginAction:(&#39;Arg1 * &#39;Arg2 * &#39;Arg3 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member Ignore : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member OnCancel : interruption:(unit -&gt; unit) -&gt; Async&lt;IDisposable&gt;<br />&#160;&#160;static member Parallel : computations:seq&lt;Async&lt;&#39;T&gt;&gt; -&gt; Async&lt;&#39;T []&gt;<br />&#160;&#160;static member RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:CancellationToken -&gt; &#39;T<br />&#160;&#160;static member Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member Start : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />&#160;&#160;static member StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:Tasks.TaskCreationOptions * ?cancellationToken:CancellationToken -&gt; Tasks.Task&lt;&#39;T&gt;<br />&#160;&#160;static member StartChild : computation:Async&lt;&#39;T&gt; * ?millisecondsTimeout:int -&gt; Async&lt;Async&lt;&#39;T&gt;&gt;<br />&#160;&#160;static member StartChildAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:Tasks.TaskCreationOptions -&gt; Async&lt;Tasks.Task&lt;&#39;T&gt;&gt;<br />&#160;&#160;static member StartImmediate : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />&#160;&#160;static member StartWithContinuations : computation:Async&lt;&#39;T&gt; * continuation:(&#39;T -&gt; unit) * exceptionContinuation:(exn -&gt; unit) * cancellationContinuation:(OperationCanceledException -&gt; unit) * ?cancellationToken:CancellationToken -&gt; unit<br />&#160;&#160;static member SwitchToContext : syncContext:SynchronizationContext -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member SwitchToNewThread : unit -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member TryCancelled : computation:Async&lt;&#39;T&gt; * compensation:(OperationCanceledException -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member CancellationToken : Async&lt;CancellationToken&gt;<br />&#160;&#160;static member DefaultCancellationToken : CancellationToken<br />end<br /><br />Full name: Microsoft.FSharp.Control.Async<br /></div>
<div class="tip" id="fstips41">static member Async.AwaitObservable : ev1:IObservable&lt;&#39;a&gt; -&gt; Async&lt;&#39;a&gt;<br /></div>
<div class="tip" id="fstips42">val wc : WebClient<br /></div>
<div class="tip" id="fstips43">type WebClient =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : unit -&gt; System.Net.WebClient<br />&#160;&#160;&#160;&#160;member AllowReadStreamBuffering : bool with get, set<br />&#160;&#160;&#160;&#160;member AllowWriteStreamBuffering : bool with get, set<br />&#160;&#160;&#160;&#160;member BaseAddress : string with get, set<br />&#160;&#160;&#160;&#160;member CancelAsync : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Credentials : System.Net.ICredentials with get, set<br />&#160;&#160;&#160;&#160;member DownloadStringAsync : System.Uri -&gt; unit<br />&#160;&#160;&#160;&#160;member DownloadStringAsync : System.Uri * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member Encoding : System.Text.Encoding with get, set<br />&#160;&#160;&#160;&#160;member Headers : System.Net.WebHeaderCollection with get, set<br />&#160;&#160;&#160;&#160;member IsBusy : bool<br />&#160;&#160;&#160;&#160;member OpenReadAsync : System.Uri -&gt; unit<br />&#160;&#160;&#160;&#160;member OpenReadAsync : System.Uri * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member OpenWriteAsync : System.Uri -&gt; unit<br />&#160;&#160;&#160;&#160;member OpenWriteAsync : System.Uri * string -&gt; unit<br />&#160;&#160;&#160;&#160;member OpenWriteAsync : System.Uri * string * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member ResponseHeaders : System.Net.WebHeaderCollection<br />&#160;&#160;&#160;&#160;member UploadStringAsync : System.Uri * string -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadStringAsync : System.Uri * string * string -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadStringAsync : System.Uri * string * string * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member UseDefaultCredentials : bool with get, set<br />&#160;&#160;end<br /><br />Full name: System.Net.WebClient<br /></div>
<div class="tip" id="fstips44">member WebClient.AsyncDownloadString : address:Uri -&gt; Async&lt;string&gt;<br /></div>
<div class="tip" id="fstips45">type Uri =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : string -&gt; System.Uri<br />&#160;&#160;&#160;&#160;new : string * bool -&gt; System.Uri<br />&#160;&#160;&#160;&#160;new : string * System.UriKind -&gt; System.Uri<br />&#160;&#160;&#160;&#160;new : System.Uri * string -&gt; System.Uri<br />&#160;&#160;&#160;&#160;new : System.Uri * string * bool -&gt; System.Uri<br />&#160;&#160;&#160;&#160;new : System.Uri * System.Uri -&gt; System.Uri<br />&#160;&#160;&#160;&#160;member AbsolutePath : string<br />&#160;&#160;&#160;&#160;member AbsoluteUri : string<br />&#160;&#160;&#160;&#160;member Authority : string<br />&#160;&#160;&#160;&#160;member DnsSafeHost : string<br />&#160;&#160;&#160;&#160;member Equals : obj -&gt; bool<br />&#160;&#160;&#160;&#160;member Fragment : string<br />&#160;&#160;&#160;&#160;member GetComponents : System.UriComponents * System.UriFormat -&gt; string<br />&#160;&#160;&#160;&#160;member GetHashCode : unit -&gt; int<br />&#160;&#160;&#160;&#160;member GetLeftPart : System.UriPartial -&gt; string<br />&#160;&#160;&#160;&#160;member Host : string<br />&#160;&#160;&#160;&#160;member HostNameType : System.UriHostNameType<br />&#160;&#160;&#160;&#160;member IsAbsoluteUri : bool<br />&#160;&#160;&#160;&#160;member IsBaseOf : System.Uri -&gt; bool<br />&#160;&#160;&#160;&#160;member IsDefaultPort : bool<br />&#160;&#160;&#160;&#160;member IsFile : bool<br />&#160;&#160;&#160;&#160;member IsLoopback : bool<br />&#160;&#160;&#160;&#160;member IsUnc : bool<br />&#160;&#160;&#160;&#160;member IsWellFormedOriginalString : unit -&gt; bool<br />&#160;&#160;&#160;&#160;member LocalPath : string<br />&#160;&#160;&#160;&#160;member MakeRelative : System.Uri -&gt; string<br />&#160;&#160;&#160;&#160;member MakeRelativeUri : System.Uri -&gt; System.Uri<br />&#160;&#160;&#160;&#160;member OriginalString : string<br />&#160;&#160;&#160;&#160;member PathAndQuery : string<br />&#160;&#160;&#160;&#160;member Port : int<br />&#160;&#160;&#160;&#160;member Query : string<br />&#160;&#160;&#160;&#160;member Scheme : string<br />&#160;&#160;&#160;&#160;member Segments : string []<br />&#160;&#160;&#160;&#160;member ToString : unit -&gt; string<br />&#160;&#160;&#160;&#160;member UserEscaped : bool<br />&#160;&#160;&#160;&#160;member UserInfo : string<br />&#160;&#160;&#160;&#160;static val UriSchemeFile : string<br />&#160;&#160;&#160;&#160;static val UriSchemeFtp : string<br />&#160;&#160;&#160;&#160;static val UriSchemeGopher : string<br />&#160;&#160;&#160;&#160;static val UriSchemeHttp : string<br />&#160;&#160;&#160;&#160;static val UriSchemeHttps : string<br />&#160;&#160;&#160;&#160;static val UriSchemeMailto : string<br />&#160;&#160;&#160;&#160;static val UriSchemeNews : string<br />&#160;&#160;&#160;&#160;static val UriSchemeNntp : string<br />&#160;&#160;&#160;&#160;static val UriSchemeNetTcp : string<br />&#160;&#160;&#160;&#160;static val UriSchemeNetPipe : string<br />&#160;&#160;&#160;&#160;static val SchemeDelimiter : string<br />&#160;&#160;&#160;&#160;static member CheckHostName : string -&gt; System.UriHostNameType<br />&#160;&#160;&#160;&#160;static member CheckSchemeName : string -&gt; bool<br />&#160;&#160;&#160;&#160;static member Compare : System.Uri * System.Uri * System.UriComponents * System.UriFormat * System.StringComparison -&gt; int<br />&#160;&#160;&#160;&#160;static member EscapeDataString : string -&gt; string<br />&#160;&#160;&#160;&#160;static member EscapeUriString : string -&gt; string<br />&#160;&#160;&#160;&#160;static member FromHex : char -&gt; int<br />&#160;&#160;&#160;&#160;static member HexEscape : char -&gt; string<br />&#160;&#160;&#160;&#160;static member HexUnescape : string * int -&gt; char<br />&#160;&#160;&#160;&#160;static member IsHexDigit : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsHexEncoding : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsWellFormedUriString : string * System.UriKind -&gt; bool<br />&#160;&#160;&#160;&#160;static member TryCreate : string * System.UriKind * System.Uri -&gt; bool<br />&#160;&#160;&#160;&#160;static member TryCreate : System.Uri * string * System.Uri -&gt; bool<br />&#160;&#160;&#160;&#160;static member TryCreate : System.Uri * System.Uri * System.Uri -&gt; bool<br />&#160;&#160;&#160;&#160;static member UnescapeDataString : string -&gt; string<br />&#160;&#160;end<br /><br />Full name: System.Uri<br /><br />&#160;&#160;type: Uri<br />&#160;&#160;implements: Runtime.Serialization.ISerializable<br /></div>
<div class="tip" id="fstips46">val root : string<br /><br />Full name: Demo.Core.root<br /><br />&#160;&#160;type: string<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;string&gt;<br />&#160;&#160;implements: seq&lt;char&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;implements: IEquatable&lt;string&gt;<br /></div>
<div class="tip" id="fstips47">val prices : float []<br /><br />&#160;&#160;type: float []<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: Collections.IList<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: Collections.Generic.IList&lt;float&gt;<br />&#160;&#160;implements: Collections.Generic.ICollection&lt;float&gt;<br />&#160;&#160;implements: seq&lt;float&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;inherits: Array<br /></div>
<div class="tip" id="fstips48">static member Async.StartImmediate : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br /></div>
<div class="tip" id="fstips49">val main : Async&lt;unit&gt;<br /><br />Full name: Demo.StandardAsync.StartChild.main<br /></div>
<div class="tip" id="fstips50">let stockClicked = <br />&#160;&#160;[ for stock, btn in Seq.zip stocks buttons -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;btn.Click |&gt; Observable.map (fun _ -&gt; stock) ]<br />&#160;&#160;|&gt; List.reduce Observable.merge<br /></div>
<div class="tip" id="fstips51">val token : Async&lt;float []&gt;<br /></div>
<div class="tip" id="fstips52">static member Async.StartChild : computation:Async&lt;&#39;T&gt; * ?millisecondsTimeout:int -&gt; Async&lt;Async&lt;&#39;T&gt;&gt;<br /></div>
<div class="tip" id="fstips53">val main : Async&lt;unit&gt;<br /><br />Full name: Demo.StandardAsync.Switching.main<br /></div>
<div class="tip" id="fstips54">val ctx : SynchronizationContext<br /></div>
<div class="tip" id="fstips55">type SynchronizationContext =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : unit -&gt; System.Threading.SynchronizationContext<br />&#160;&#160;&#160;&#160;member CreateCopy : unit -&gt; System.Threading.SynchronizationContext<br />&#160;&#160;&#160;&#160;member IsWaitNotificationRequired : unit -&gt; bool<br />&#160;&#160;&#160;&#160;member OperationCompleted : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member OperationStarted : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Post : System.Threading.SendOrPostCallback * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member Send : System.Threading.SendOrPostCallback * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member Wait : System.IntPtr [] * bool * int -&gt; int<br />&#160;&#160;&#160;&#160;static member Current : System.Threading.SynchronizationContext<br />&#160;&#160;&#160;&#160;static member SetSynchronizationContext : System.Threading.SynchronizationContext -&gt; unit<br />&#160;&#160;end<br /><br />Full name: System.Threading.SynchronizationContext<br /></div>
<div class="tip" id="fstips56">property SynchronizationContext.Current: SynchronizationContext<br /></div>
<div class="tip" id="fstips57">static member Async.SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;<br /></div>
<div class="tip" id="fstips58">static member Async.SwitchToContext : syncContext:SynchronizationContext -&gt; Async&lt;unit&gt;<br /></div>