<!-- [info]

 - date: 2010-10-27T11:12:08.0000000
 - description: In this article, we'll look at type that implements an (asynchronous) blocking queue using F# agents. This can be used, for example, when implementing the pipeline pattern as demonstrated in the previous article.
 - tags: functional,parallel,asynchronous,f#
 - layout: post
 - title: F# Parallel Extras (II.): Agent-based blocking queue
 - url: parallel-extra-blockingagent.aspx

[/info] -->
<!-- [abstract]
<p>In the <a href="http://tomasp.net/blog/parallel-extra-image-pipeline.aspx">previous article</a>, we 
  briefly introduced the <code>BlockingQueueAgent&lt;T&gt;</code> type and we used it to implement the
  pipeline pattern (from Chapter 7 of <a href="http://parallelpatterns.codeplex.com/" type="external">Parallel Programming with Microsoft .NET</a>)
  using asynchronous workflows. The type was used to represent intermediate buffers with a limited size.
  In this article we'll take a look at the implementation of the type. The type implements a very useful
  pattern in agent-based parallel programming, so you can use it in your work, but it could be also 
  interesting as a demonstration of the F# <code>Agent&lt;T&gt;</code> type (an recommended alias 
  for the <code>MailboxProcessor&lt;T&gt;</code> type).</p>
<p>The <code>BlockingQueueAgent&lt;T&gt;</code> type is similar to <code>BlockingCollection&lt;T&gt;</code> 
  from .NET 4.0. It has methods for adding and removing elements that block when the operation cannot be
  done (e.g. adding when the queue is full or removing when the queue is empty). The most important 
  difference is that it can be used <em>asynchronously</em>. This means that when we call its operations
  form F# asynchronous workflow (using <code>let!</code> and <code>do!</code>), the operation will block
  the calling workflow, but it will not block any physical thread. We start by looking at the overall
  structure of the agent and then look at the body of the agent which implements its behavior (using
  a state machine)...</p>
[/abstract] -->

<h1>F# Parallel Extras (II.): Agent-based blocking queue</h1>
<p>In the <a href="http://tomasp.net/blog/parallel-extra-image-pipeline.aspx">previous article</a>, we 
  briefly introduced the <code>BlockingQueueAgent&lt;T&gt;</code> type and we used it to implement the
  pipeline pattern (from Chapter 7 of <a href="http://parallelpatterns.codeplex.com/" type="external">Parallel Programming with Microsoft .NET</a>)
  using asynchronous workflows. The type was used to represent intermediate buffers with a limited size.
  In this article we'll take a look at the implementation of the type. The type implements a very useful
  pattern in agent-based parallel programming, so you can use it in your work, but it could be also 
  interesting as a demonstration of the F# <code>Agent&lt;T&gt;</code> type (an recommended alias 
  for the <code>MailboxProcessor&lt;T&gt;</code> type).</p>
<p>The <code>BlockingQueueAgent&lt;T&gt;</code> type is similar to <code>BlockingCollection&lt;T&gt;</code> 
  from .NET 4.0. It has methods for adding and removing elements that block when the operation cannot be
  done (e.g. adding when the queue is full or removing when the queue is empty). The most important 
  difference is that it can be used <em>asynchronously</em>. This means that when we call its operations
  form F# asynchronous workflow (using <code>let!</code> and <code>do!</code>), the operation will block
  the calling workflow, but it will not block any physical thread. We start by looking at the overall
  structure of the agent and then look at the body of the agent which implements its behavior (using
  a state machine)...</p>

<h2>Structure of the blocking agent</h2>
<p>An agent is simply an object that can receive messages of some type. The best way to represent messages
  is to use an F# discriminated union type which lists all the possible commands that the agent can 
  react to. To make the use of agent more convenient, it is quite common to wrap the agent in 
  a type declaration, so that the messages can be send just by calling a member.</p>

<h3>Defining the message type</h3>
<p>Let's start by defining a type alias <code>Agent&lt;T&gt;</code> and defining a message type for
  our agent. As you can see, the agent is surprisingly simple and it needs only two messages:</p>

<pre class="fssnip">
<span class="l">1: </span><span class="c">///</span><span class="c"> </span><span class="c">A</span><span class="c"> </span><span class="c">convenience</span><span class="c"> </span><span class="c">type</span><span class="c"> </span><span class="c">alias</span><span class="c"> </span><span class="c">for</span><span class="c"> </span><span class="c">'MailboxProcessor&lt;T&gt;'</span><span class="c"> </span><span class="c">type</span>
<span class="l">2: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fsbla1', 1)" onmouseover="showTip(event, 'fsbla1', 1)" class="i">Agent</span><span class="o">&lt;</span><span class="o">'</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla2', 2)" onmouseover="showTip(event, 'fsbla2', 2)" class="i">MailboxProcessor</span><span class="o">&lt;</span><span class="o">'</span><span class="i">T</span><span class="o">&gt;</span>
<span class="l">3: </span>
<span class="l">4: </span><span class="c">///</span><span class="c"> </span><span class="c">Type</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">messages</span><span class="c"> </span><span class="c">internally</span><span class="c"> </span><span class="c">used</span><span class="c"> </span><span class="c">by</span><span class="c"> </span><span class="c">'BlockingQueueAgent&lt;T&gt;'</span>
<span class="l">5: </span><span class="k">type</span> <span class="k">internal</span> <span onmouseout="hideTip(event, 'fsbla3', 3)" onmouseover="showTip(event, 'fsbla3', 3)" class="i">BlockingAgentMessage</span><span class="o">&lt;</span><span class="o">'</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">=</span> 
<span class="l">6: </span>  | <span onmouseout="hideTip(event, 'fsbla4', 4)" onmouseover="showTip(event, 'fsbla4', 4)" class="i">Add</span> <span class="k">of</span> <span class="o">'</span><span class="i">T</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fsbla5', 5)" onmouseover="showTip(event, 'fsbla5', 5)" class="i">AsyncReplyChannel</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fsbla6', 6)" onmouseover="showTip(event, 'fsbla6', 6)" class="i">unit</span><span class="o">&gt;</span> 
<span class="l">7: </span>  | <span onmouseout="hideTip(event, 'fsbla7', 7)" onmouseover="showTip(event, 'fsbla7', 7)" class="i">Get</span> <span class="k">of</span> <span onmouseout="hideTip(event, 'fsbla5', 8)" onmouseover="showTip(event, 'fsbla5', 8)" class="i">AsyncReplyChannel</span><span class="o">&lt;</span><span class="o">'</span><span class="i">T</span><span class="o">&gt;</span><a target="_blank" class="fssniplink" href="http://tomasp.net/fswebsnippets">F# Web Snippets</a>
</pre>

<p>The first message is used to add a new element to the blocking queue. It carries a value to be added and 
  a reply channel. The channel is used to notify the caller that the element was added (and so the caller can 
  continue producing more elements). The second message is used to read elements from the queue is using 
  asynchronous reply channel to send the obtained value to the caller. Now that we have the message type, we 
  can look at the structure of the wrapping type...</p>

<h3>Wrapping agent in a type</h3>
<p>The <code>BlockingQueueAgent&lt;T&gt;</code> type takes a maximal number of elements that can be stored
  in the queue as a constructor parameter. It has a single property <code>Count</code>, which returns the 
  current number of elements in the queue and it has two methods. The <code>AsyncAdd</code> method
  sends the <code>Add</code> message to the agent (and asynchronously waits for the reply) and the
  <code>AsyncGet</code> method does similar thing with the <code>Get</code> message. In addition, both of 
  the methods that an optional parameter <code>?timeout</code> that can be used to limit the waiting time.
  Let's now look at the structure and we'll discuss the private state of the agent as well as the 
  state machine that implements its behavior later:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="c">///</span><span class="c"> </span><span class="c">Agent</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">implements</span><span class="c"> </span><span class="c">an</span><span class="c"> </span><span class="c">asynchronous</span><span class="c"> </span><span class="c">blocking</span><span class="c"> </span><span class="c">queue</span>
<span class="l"> 2: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fsbla8', 9)" onmouseover="showTip(event, 'fsbla8', 9)" class="i">BlockingQueueAgent</span><span class="o">&lt;</span><span class="o">'</span><span class="i">T</span><span class="o">&gt;</span>(<span onmouseout="hideTip(event, 'fsbla9', 10)" onmouseover="showTip(event, 'fsbla9', 10)" class="i">maxLength</span>) <span class="o">=</span>
<span class="l"> 3: </span>  <span onmouseout="hideTip(event, 'fsbla10', 11)" onmouseover="showTip(event, 'fsbla10', 11)" class="omitted">(initialization and private state omitted)</span>
<span class="l"> 4: </span>  <span class="k">let</span> <span onmouseout="hideTip(event, 'fsbla11', 12)" onmouseover="showTip(event, 'fsbla11', 12)" class="i">agent</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla1', 13)" onmouseover="showTip(event, 'fsbla1', 13)" class="i">Agent</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla12', 14)" onmouseover="showTip(event, 'fsbla12', 14)" class="i">Start</span>(<span class="k">fun</span> <span onmouseout="hideTip(event, 'fsbla11', 15)" onmouseover="showTip(event, 'fsbla11', 15)" class="i">agent</span> <span class="k">-&gt;</span>
<span class="l"> 5: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Keeps</span><span class="c"> </span><span class="c">a</span><span class="c"> </span><span class="c">list</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">items</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">are</span><span class="c"> </span><span class="c">in</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">queue</span>
<span class="l"> 6: </span>    <span class="k">let</span> <span onmouseout="hideTip(event, 'fsbla13', 16)" onmouseover="showTip(event, 'fsbla13', 16)" class="i">queue</span> <span class="o">=</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fsbla14', 17)" onmouseover="showTip(event, 'fsbla14', 17)" class="i">Queue</span><span class="o">&lt;</span>_<span class="o">&gt;</span>()
<span class="l"> 7: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Keeps</span><span class="c"> </span><span class="c">a</span><span class="c"> </span><span class="c">list</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">blocked</span><span class="c"> </span><span class="c">callers</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">additional</span><span class="c"> </span><span class="c">values</span>
<span class="l"> 8: </span>    <span class="k">let</span> <span onmouseout="hideTip(event, 'fsbla15', 18)" onmouseover="showTip(event, 'fsbla15', 18)" class="i">pending</span> <span class="o">=</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fsbla14', 19)" onmouseover="showTip(event, 'fsbla14', 19)" class="i">Queue</span><span class="o">&lt;</span>_<span class="o">&gt;</span>()
<span class="l"> 9: </span>
<span class="l">10: </span>    <span class="c">//</span><span class="c"> </span><span class="c">State</span><span class="c"> </span><span class="c">machine</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">implements</span><span class="c"> </span><span class="c">agent's</span><span class="c"> </span><span class="c">behavior</span>
<span class="l">11: </span>    <span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'fsbla16', 20)" onmouseover="showTip(event, 'fsbla16', 20)" class="i">emptyQueue</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla17', 21)" onmouseover="showTip(event, 'fsbla17', 21)" class="omitted">(...)</span>
<span class="l">12: </span>    <span class="k">and</span> <span onmouseout="hideTip(event, 'fsbla18', 22)" onmouseover="showTip(event, 'fsbla18', 22)" class="i">nonEmptyQueue</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla19', 23)" onmouseover="showTip(event, 'fsbla19', 23)" class="omitted">(...)</span>
<span class="l">13: </span>
<span class="l">14: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Start</span><span class="c"> </span><span class="c">with</span><span class="c"> </span><span class="c">an</span><span class="c"> </span><span class="c">empty</span><span class="c"> </span><span class="c">queue</span>
<span class="l">15: </span>    <span onmouseout="hideTip(event, 'fsbla16', 24)" onmouseover="showTip(event, 'fsbla16', 24)" class="i">emptyQueue</span>() )
<span class="l">16: </span>
<span class="l">17: </span>  <span class="c">///</span><span class="c"> </span><span class="c">Returns</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">number</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">items</span><span class="c"> </span><span class="c">in</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">(immediately)</span>
<span class="l">18: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fsbla20', 25)" onmouseover="showTip(event, 'fsbla20', 25)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla21', 26)" onmouseover="showTip(event, 'fsbla21', 26)" class="i">Count</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla22', 27)" onmouseover="showTip(event, 'fsbla22', 27)" class="i">count</span>
<span class="l">19: </span>
<span class="l">20: </span>  <span class="c">///</span><span class="c"> </span><span class="c">Asynchronously</span><span class="c"> </span><span class="c">adds</span><span class="c"> </span><span class="c">item;</span><span class="c"> </span><span class="c">blocks</span><span class="c"> </span><span class="c">if</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">full</span>
<span class="l">21: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fsbla20', 28)" onmouseover="showTip(event, 'fsbla20', 28)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla23', 29)" onmouseover="showTip(event, 'fsbla23', 29)" class="i">AsyncAdd</span>(<span onmouseout="hideTip(event, 'fsbla24', 30)" onmouseover="showTip(event, 'fsbla24', 30)" class="i">v</span><span class="o">:</span><span class="o">'</span><span class="i">T</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fsbla25', 31)" onmouseover="showTip(event, 'fsbla25', 31)" class="i">timeout</span>) <span class="o">=</span> 
<span class="l">22: </span>    <span onmouseout="hideTip(event, 'fsbla11', 32)" onmouseover="showTip(event, 'fsbla11', 32)" class="i">agent</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla26', 33)" onmouseover="showTip(event, 'fsbla26', 33)" class="i">PostAndAsyncReply</span>((<span class="k">fun</span> <span onmouseout="hideTip(event, 'fsbla27', 34)" onmouseover="showTip(event, 'fsbla27', 34)" class="i">ch</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fsbla4', 35)" onmouseover="showTip(event, 'fsbla4', 35)" class="i">Add</span>(<span onmouseout="hideTip(event, 'fsbla24', 36)" onmouseover="showTip(event, 'fsbla24', 36)" class="i">v</span>, <span onmouseout="hideTip(event, 'fsbla27', 37)" onmouseover="showTip(event, 'fsbla27', 37)" class="i">ch</span>)), <span class="o">?</span><span onmouseout="hideTip(event, 'fsbla25', 38)" onmouseover="showTip(event, 'fsbla25', 38)" class="i">timeout</span><span class="o">=</span><span onmouseout="hideTip(event, 'fsbla25', 39)" onmouseover="showTip(event, 'fsbla25', 39)" class="i">timeout</span>)
<span class="l">23: </span>
<span class="l">24: </span>  <span class="c">///</span><span class="c"> </span><span class="c">Asynchronously</span><span class="c"> </span><span class="c">gets</span><span class="c"> </span><span class="c">item;</span><span class="c"> </span><span class="c">blocks</span><span class="c"> </span><span class="c">if</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">empty</span>
<span class="l">25: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fsbla20', 40)" onmouseover="showTip(event, 'fsbla20', 40)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla28', 41)" onmouseover="showTip(event, 'fsbla28', 41)" class="i">AsyncGet</span>(<span class="o">?</span><span onmouseout="hideTip(event, 'fsbla25', 42)" onmouseover="showTip(event, 'fsbla25', 42)" class="i">timeout</span>) <span class="o">=</span> 
<span class="l">26: </span>    <span onmouseout="hideTip(event, 'fsbla11', 43)" onmouseover="showTip(event, 'fsbla11', 43)" class="i">agent</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla26', 44)" onmouseover="showTip(event, 'fsbla26', 44)" class="i">PostAndAsyncReply</span>(<span onmouseout="hideTip(event, 'fsbla7', 45)" onmouseover="showTip(event, 'fsbla7', 45)" class="i">Get</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fsbla25', 46)" onmouseover="showTip(event, 'fsbla25', 46)" class="i">timeout</span><span class="o">=</span><span onmouseout="hideTip(event, 'fsbla25', 47)" onmouseover="showTip(event, 'fsbla25', 47)" class="i">timeout</span>)<a target="_blank" class="fssniplink" href="http://tomasp.net/fswebsnippets">F# Web Snippets</a>
</pre>
<p>The type contains a single private field that is marked as <code>VolatileFiled</code> and is used to track
  the number of elements in the queue. The value can be obtained using the <code>Count</code> member, which can 
  be safely accessed from multiple threads. Next, the queue creates an agent that is used to keep the state
  of the queue and handles the messages that we declared earlier.</p>

<p>Inside the agent, we use mutable state, because the mutable <code>Queue&lt;T&gt;</code> type from .NET libraries
  is faster than a functional implementation. Note that this is also perfectly safe because the body of the agent will never execute multiple times
  in parallel. We use two queues in the implementation of the agent. The first one is used to keep items that
  are currently in the queue (as the tool tips shows if you place mouse pointer over the <code>queue</code>
  identifier, it contains values of type <code>'T</code>). The second queue keeps a list of pending calls to the
  <code>Add</code> method - that is, calls that wanted to add some value, but couldn't finish, because the queue
  was full (as we'll see later, we'll add values together with reply channels to this queue when a call is done
  and the queue is full and we'll process the pending calls when an element is removed).</p>

<p>The body of the agent contains two functions (both implemented using asynchronous workflows) that implement
  the behavior of the agent. As the names suggest, the function <code>emptyQueue</code> represents a state when
  the queue is empty (and cannot handle <code>Get</code> messages) and the other function (<code>nonEmptyQueue</code>)
  is used when the queue contains some elements. I omitted the body of the functions in the previous snippet to 
  show the overall structure, but we'll look at the implementation next...</p>

<h2>Encoding agent's behavior</h2>
<p>Let's start with the function that implements an empty queue. As already mentioned, in this state we can
  only handle the <code>Add</code> message, so the implementation uses the <code>Scan</code> member of the
  mailbox to create computation that reacts only to some messages. The function passed to the <code>Scan</code>
  member returns <code>None</code> to ignore message and <code>Some</code> with some asynchronous workflow
  as an argument to handle a message:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="c">//</span><span class="c"> </span><span class="c">If</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">empty</span><span class="c"> </span><span class="c">we</span><span class="c"> </span><span class="c">handle</span><span class="c"> </span><span class="c">only</span><span class="c"> </span><span class="c">'Add'</span><span class="c"> </span><span class="c">message</span>
<span class="l"> 2: </span><span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'fsbla16', 48)" onmouseover="showTip(event, 'fsbla16', 48)" class="i">emptyQueue</span>() <span class="o">=</span> 
<span class="l"> 3: </span>  <span onmouseout="hideTip(event, 'fsbla11', 49)" onmouseover="showTip(event, 'fsbla11', 49)" class="i">agent</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla29', 50)" onmouseover="showTip(event, 'fsbla29', 50)" class="i">Scan</span>(<span class="k">fun</span> <span onmouseout="hideTip(event, 'fsbla30', 51)" onmouseover="showTip(event, 'fsbla30', 51)" class="i">msg</span> <span class="k">-&gt;</span>
<span class="l"> 4: </span>    <span class="k">match</span> <span onmouseout="hideTip(event, 'fsbla30', 52)" onmouseover="showTip(event, 'fsbla30', 52)" class="i">msg</span> <span class="k">with</span> 
<span class="l"> 5: </span>    | <span onmouseout="hideTip(event, 'fsbla4', 53)" onmouseover="showTip(event, 'fsbla4', 53)" class="i">Add</span>(<span onmouseout="hideTip(event, 'fsbla31', 54)" onmouseover="showTip(event, 'fsbla31', 54)" class="i">value</span>, <span onmouseout="hideTip(event, 'fsbla32', 55)" onmouseover="showTip(event, 'fsbla32', 55)" class="i">reply</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fsbla33', 56)" onmouseover="showTip(event, 'fsbla33', 56)" class="i">Some</span> <span class="o">&lt;|</span> <span onmouseout="hideTip(event, 'fsbla34', 57)" onmouseover="showTip(event, 'fsbla34', 57)" class="i">async</span> {
<span class="l"> 6: </span>        <span onmouseout="hideTip(event, 'fsbla13', 58)" onmouseover="showTip(event, 'fsbla13', 58)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla35', 59)" onmouseover="showTip(event, 'fsbla35', 59)" class="i">Enqueue</span>(<span onmouseout="hideTip(event, 'fsbla31', 60)" onmouseover="showTip(event, 'fsbla31', 60)" class="i">value</span>)
<span class="l"> 7: </span>        <span onmouseout="hideTip(event, 'fsbla22', 61)" onmouseover="showTip(event, 'fsbla22', 61)" class="i">count</span> <span class="o">&lt;-</span> <span onmouseout="hideTip(event, 'fsbla13', 62)" onmouseover="showTip(event, 'fsbla13', 62)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 63)" onmouseover="showTip(event, 'fsbla36', 63)" class="i">Count</span>
<span class="l"> 8: </span>        <span onmouseout="hideTip(event, 'fsbla32', 64)" onmouseover="showTip(event, 'fsbla32', 64)" class="i">reply</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla37', 65)" onmouseover="showTip(event, 'fsbla37', 65)" class="i">Reply</span>()
<span class="l"> 9: </span>        <span class="k">return!</span> <span onmouseout="hideTip(event, 'fsbla18', 66)" onmouseover="showTip(event, 'fsbla18', 66)" class="i">nonEmptyQueue</span>() }
<span class="l">10: </span>    | _ <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fsbla38', 67)" onmouseover="showTip(event, 'fsbla38', 67)" class="i">None</span> )<a target="_blank" class="fssniplink" href="http://tomasp.net/fswebsnippets">F# Web Snippets</a>
</pre>

<p>When we receive the <code>Add</code> message, we return a workflow that adds the value to a queue, 
  updates the number of elements in the queue and sends reply to the caller (as a notification that the 
  value was added). Consequently, the queue is no longer empty, so it switches to the other state.
  Note that any <code>Get</code> messages that are sent to the agent while in the <code>emptyQueue</code>
  state will be automatically buffered by the agent and will be processed when the agent switches the state.</p>

<p>The second function (<code>nonEmptyQueue</code>) can handle both of the messages, so we can implement
  it as an asynchronous workflow that awaits the first message (using <code>Receive</code> method of the
  agent) and then reacts to the message. When adding a value, we need to handle a case when the 
  queue is already full. When removing a value, we then check if there are any pending calls that
  have been blocked while attempting to add a value. These blocked calls are stored in the <code>pending</code>
  queue:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="c">//</span><span class="c"> </span><span class="c">If</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">non-empty,</span><span class="c"> </span><span class="c">we</span><span class="c"> </span><span class="c">can</span><span class="c"> </span><span class="c">handle</span><span class="c"> </span><span class="c">all</span><span class="c"> </span><span class="c">messages</span>
<span class="l"> 2: </span><span class="k">and</span> <span onmouseout="hideTip(event, 'fsbla18', 68)" onmouseover="showTip(event, 'fsbla18', 68)" class="i">nonEmptyQueue</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla34', 69)" onmouseover="showTip(event, 'fsbla34', 69)" class="i">async</span> {
<span class="l"> 3: </span>  <span class="k">let!</span> <span onmouseout="hideTip(event, 'fsbla30', 70)" onmouseover="showTip(event, 'fsbla30', 70)" class="i">msg</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla11', 71)" onmouseover="showTip(event, 'fsbla11', 71)" class="i">agent</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla39', 72)" onmouseover="showTip(event, 'fsbla39', 72)" class="i">Receive</span>()
<span class="l"> 4: </span>  <span class="k">match</span> <span class="i">msg</span> <span class="k">with</span> 
<span class="l"> 5: </span>  | <span onmouseout="hideTip(event, 'fsbla4', 73)" onmouseover="showTip(event, 'fsbla4', 73)" class="i">Add</span>(<span onmouseout="hideTip(event, 'fsbla31', 74)" onmouseover="showTip(event, 'fsbla31', 74)" class="i">value</span>, <span onmouseout="hideTip(event, 'fsbla32', 75)" onmouseover="showTip(event, 'fsbla32', 75)" class="i">reply</span>) <span class="k">-&gt;</span> 
<span class="l"> 6: </span>      <span class="c">//</span><span class="c"> </span><span class="c">Add</span><span class="c"> </span><span class="c">immediately</span><span class="c"> </span><span class="c">if</span><span class="c"> </span><span class="c">possibley,</span><span class="c"> </span><span class="c">otherwise</span><span class="c"> </span><span class="c">block</span><span class="c"> </span><span class="c">caller</span>
<span class="l"> 7: </span>      <span class="k">if</span> <span onmouseout="hideTip(event, 'fsbla13', 76)" onmouseover="showTip(event, 'fsbla13', 76)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 77)" onmouseover="showTip(event, 'fsbla36', 77)" class="i">Count</span> <span class="o">&lt;</span> <span onmouseout="hideTip(event, 'fsbla9', 78)" onmouseover="showTip(event, 'fsbla9', 78)" class="i">maxLength</span> <span class="k">then</span> 
<span class="l"> 8: </span>        <span onmouseout="hideTip(event, 'fsbla13', 79)" onmouseover="showTip(event, 'fsbla13', 79)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla35', 80)" onmouseover="showTip(event, 'fsbla35', 80)" class="i">Enqueue</span>(<span onmouseout="hideTip(event, 'fsbla31', 81)" onmouseover="showTip(event, 'fsbla31', 81)" class="i">value</span>)
<span class="l"> 9: </span>        <span onmouseout="hideTip(event, 'fsbla22', 82)" onmouseover="showTip(event, 'fsbla22', 82)" class="i">count</span> <span class="o">&lt;-</span> <span onmouseout="hideTip(event, 'fsbla13', 83)" onmouseover="showTip(event, 'fsbla13', 83)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 84)" onmouseover="showTip(event, 'fsbla36', 84)" class="i">Count</span>
<span class="l">10: </span>        <span onmouseout="hideTip(event, 'fsbla32', 85)" onmouseover="showTip(event, 'fsbla32', 85)" class="i">reply</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla37', 86)" onmouseover="showTip(event, 'fsbla37', 86)" class="i">Reply</span>()
<span class="l">11: </span>      <span class="k">else</span> 
<span class="l">12: </span>        <span onmouseout="hideTip(event, 'fsbla15', 87)" onmouseover="showTip(event, 'fsbla15', 87)" class="i">pending</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla40', 88)" onmouseover="showTip(event, 'fsbla40', 88)" class="i">Enqueue</span>(<span onmouseout="hideTip(event, 'fsbla31', 89)" onmouseover="showTip(event, 'fsbla31', 89)" class="i">value</span>, <span onmouseout="hideTip(event, 'fsbla32', 90)" onmouseover="showTip(event, 'fsbla32', 90)" class="i">reply</span>) 
<span class="l">13: </span>      <span class="k">return!</span> <span onmouseout="hideTip(event, 'fsbla18', 91)" onmouseover="showTip(event, 'fsbla18', 91)" class="i">nonEmptyQueue</span>()
<span class="l">14: </span>  | <span onmouseout="hideTip(event, 'fsbla7', 92)" onmouseover="showTip(event, 'fsbla7', 92)" class="i">Get</span>(<span onmouseout="hideTip(event, 'fsbla41', 93)" onmouseover="showTip(event, 'fsbla41', 93)" class="i">reply</span>) <span class="k">-&gt;</span> 
<span class="l">15: </span>      <span class="k">let</span> <span onmouseout="hideTip(event, 'fsbla42', 94)" onmouseover="showTip(event, 'fsbla42', 94)" class="i">item</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla13', 95)" onmouseover="showTip(event, 'fsbla13', 95)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla43', 96)" onmouseover="showTip(event, 'fsbla43', 96)" class="i">Dequeue</span>()
<span class="l">16: </span>      <span class="c">//</span><span class="c"> </span><span class="c">Unblock</span><span class="c"> </span><span class="c">some</span><span class="c"> </span><span class="c">blocked</span><span class="c"> </span><span class="c">callers</span><span class="c"> </span><span class="c">as</span><span class="c"> </span><span class="c">we</span><span class="c"> </span><span class="c">have</span><span class="c"> </span><span class="c">some</span><span class="c"> </span><span class="c">space</span><span class="c"> </span><span class="c">now</span>
<span class="l">17: </span>      <span class="k">while</span> <span onmouseout="hideTip(event, 'fsbla13', 97)" onmouseover="showTip(event, 'fsbla13', 97)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 98)" onmouseover="showTip(event, 'fsbla36', 98)" class="i">Count</span> <span class="o">&lt;</span> <span onmouseout="hideTip(event, 'fsbla9', 99)" onmouseover="showTip(event, 'fsbla9', 99)" class="i">maxLength</span> <span class="o">&amp;&amp;</span> <span onmouseout="hideTip(event, 'fsbla15', 100)" onmouseover="showTip(event, 'fsbla15', 100)" class="i">pending</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 101)" onmouseover="showTip(event, 'fsbla36', 101)" class="i">Count</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="k">do</span>
<span class="l">18: </span>        <span class="k">let</span> <span onmouseout="hideTip(event, 'fsbla44', 102)" onmouseover="showTip(event, 'fsbla44', 102)" class="i">itm</span>, <span onmouseout="hideTip(event, 'fsbla45', 103)" onmouseover="showTip(event, 'fsbla45', 103)" class="i">caller</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla15', 104)" onmouseover="showTip(event, 'fsbla15', 104)" class="i">pending</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla46', 105)" onmouseover="showTip(event, 'fsbla46', 105)" class="i">Dequeue</span>()
<span class="l">19: </span>        <span onmouseout="hideTip(event, 'fsbla13', 106)" onmouseover="showTip(event, 'fsbla13', 106)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla35', 107)" onmouseover="showTip(event, 'fsbla35', 107)" class="i">Enqueue</span>(<span onmouseout="hideTip(event, 'fsbla44', 108)" onmouseover="showTip(event, 'fsbla44', 108)" class="i">itm</span>)
<span class="l">20: </span>        <span onmouseout="hideTip(event, 'fsbla45', 109)" onmouseover="showTip(event, 'fsbla45', 109)" class="i">caller</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla37', 110)" onmouseover="showTip(event, 'fsbla37', 110)" class="i">Reply</span>()
<span class="l">21: </span>      <span onmouseout="hideTip(event, 'fsbla22', 111)" onmouseover="showTip(event, 'fsbla22', 111)" class="i">count</span> <span class="o">&lt;-</span> <span onmouseout="hideTip(event, 'fsbla13', 112)" onmouseover="showTip(event, 'fsbla13', 112)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 113)" onmouseover="showTip(event, 'fsbla36', 113)" class="i">Count</span>
<span class="l">22: </span>      <span onmouseout="hideTip(event, 'fsbla41', 114)" onmouseover="showTip(event, 'fsbla41', 114)" class="i">reply</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla37', 115)" onmouseover="showTip(event, 'fsbla37', 115)" class="i">Reply</span>(<span onmouseout="hideTip(event, 'fsbla42', 116)" onmouseover="showTip(event, 'fsbla42', 116)" class="i">item</span>)
<span class="l">23: </span>      <span class="c">//</span><span class="c"> </span><span class="c">If</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">empty</span><span class="c"> </span><span class="c">then</span><span class="c"> </span><span class="c">switch</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">state,</span><span class="c"> </span><span class="c">otherwise</span><span class="c"> </span><span class="c">loop</span>
<span class="l">24: </span>      <span class="k">if</span> <span onmouseout="hideTip(event, 'fsbla13', 117)" onmouseover="showTip(event, 'fsbla13', 117)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 118)" onmouseover="showTip(event, 'fsbla36', 118)" class="i">Count</span> <span class="o">=</span> <span class="n">0</span> <span class="k">then</span> <span class="k">return!</span> <span onmouseout="hideTip(event, 'fsbla16', 119)" onmouseover="showTip(event, 'fsbla16', 119)" class="i">emptyQueue</span>()
<span class="l">25: </span>      <span class="k">else</span> <span class="k">return!</span> <span onmouseout="hideTip(event, 'fsbla18', 120)" onmouseover="showTip(event, 'fsbla18', 120)" class="i">nonEmptyQueue</span>() }<a target="_blank" class="fssniplink" href="http://tomasp.net/fswebsnippets">F# Web Snippets</a>
</pre>

<p>When adding a value to a queue that is not full, we can immediately add the element using <code>queue.Enqueue</code>,
  update the number of elements and notify the caller that a value was successfully added. When the 
  queue is empty, we store the request in the <code>pending</code> queue, which keeps both a value
  to be added and a reply channel that can be later used to notify the caller.</p>
<p>When removing an element, we can always pick an element using the <code>queue.Dequeue</code> method,
  because we're in a state when the queue is not empty. After removing an element, we check if there
  are any pending calls. We use a loop that runs until the queue becomes full or until we process 
  all pending calls. In the body of the loop, we remove one pending call, add value to the queue and
  unblock the caller by replying to the asynchronous reply channel. Finally, we update <code>count</code>
  and send value to the original sender of the <code>Get</code> message. Then we continue in one
  of the two states, depending on whether the queue is now empty or not. </p>

<h2>Summary</h2>
<p>In this article, we looked at the implementation of an F# agent that implements a blocking queue
  that has a maximal number of elements. When getting an element from an empty queue or adding an 
  element to a full queue, the caller will be blocked until an element becomes available or an element
  is removed, respectively. The <code>BlockingQueueAgent&lt;T&gt;</code> type can be quite useful in 
  parallel programming using asynchronous workflows. I demonstrated how to work with the type
  <a href="http://tomasp.net/blog/parallel-extra-image-pipeline.html">another article</a>, which 
  uses it to implement an image processing pipeline. However, the agent can be useful in many
  parallel patterns other than pipeline processing.</p>
<p>Finally, the article is also a good demonstration of message-based parallelism using agents in 
  F#. We've seen a common overall structure of an agent encapsulated in a type. We used two 
  operations for receiving messages (<code>Scan</code> and <code>Receive</code>) and we also 
  used mutually recursive functions to encode a state machine that implements the behavior of an agent.</p>


<h2>Source Code</h2>
<ul>
  <li>Download <a href="http://tomasp.net/articles/parallel-extra/parallelextras.zip">F# Parallel Extras samples</a> (ZIP)</li>
  <li>Get the latest version of samples from <a href="http://fsharpsamples.codeplex.com/" type="external">F# Community Samples</a> at CodePlex</li></ul>

<!-- HTML code for ToolTips -->
<!-- HTML code for ToolTips -->
<div class="tip" id="fsbla1">type Agent&lt;'T&gt; = MailboxProcessor&lt;'T&gt;<br /><br />Full name: Untitled.Agent&lt;_&gt;<br /><br />&#160;&#160;type: Agent&lt;'T&gt;<br />&#160;&#160;implements: IDisposable<br />
<br /><br /><em>A convenience type alias for 'MailboxProcessor&lt;T&gt;' type</em><br /></div>
<div class="tip" id="fsbla2">type MailboxProcessor&lt;'Msg&gt; =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;interface IDisposable<br />&#160;&#160;&#160;&#160;new : body:(MailboxProcessor&lt;'Msg&gt; -&gt; Async&lt;unit&gt;) * ?cancellationToken:CancellationToken -&gt; MailboxProcessor&lt;'Msg&gt;<br />&#160;&#160;&#160;&#160;member Post : message:'Msg -&gt; unit<br />&#160;&#160;&#160;&#160;member PostAndAsyncReply : buildMessage:(AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg) * ?timeout:int -&gt; Async&lt;'Reply&gt;<br />&#160;&#160;&#160;&#160;member PostAndReply : buildMessage:(AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg) * ?timeout:int -&gt; 'Reply<br />&#160;&#160;&#160;&#160;member PostAndTryAsyncReply : buildMessage:(AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg) * ?timeout:int -&gt; Async&lt;'Reply option&gt;<br />&#160;&#160;&#160;&#160;member Receive : ?timeout:int -&gt; Async&lt;'Msg&gt;<br />&#160;&#160;&#160;&#160;member Scan : scanner:('Msg -&gt; Async&lt;'T&gt; option) * ?timeout:int -&gt; Async&lt;'T&gt;<br />&#160;&#160;&#160;&#160;member Start : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member TryPostAndReply : buildMessage:(AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg) * ?timeout:int -&gt; 'Reply option<br />&#160;&#160;&#160;&#160;member TryReceive : ?timeout:int -&gt; Async&lt;'Msg option&gt;<br />&#160;&#160;&#160;&#160;member TryScan : scanner:('Msg -&gt; Async&lt;'T&gt; option) * ?timeout:int -&gt; Async&lt;'T option&gt;<br />&#160;&#160;&#160;&#160;member add_Error : Handler&lt;Exception&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;member CurrentQueueLength : int<br />&#160;&#160;&#160;&#160;member DefaultTimeout : int<br />&#160;&#160;&#160;&#160;member Error : IEvent&lt;Exception&gt;<br />&#160;&#160;&#160;&#160;member remove_Error : Handler&lt;Exception&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;member DefaultTimeout : int with set<br />&#160;&#160;&#160;&#160;static member Start : body:(MailboxProcessor&lt;'Msg&gt; -&gt; Async&lt;unit&gt;) * ?cancellationToken:CancellationToken -&gt; MailboxProcessor&lt;'Msg&gt;<br />&#160;&#160;end<br /><br />Full name: Microsoft.FSharp.Control.MailboxProcessor&lt;_&gt;<br /><br />&#160;&#160;type: MailboxProcessor&lt;'Msg&gt;<br />&#160;&#160;implements: IDisposable<br /></div>
<div class="tip" id="fsbla3">type internal BlockingAgentMessage&lt;'T&gt; =<br />&#160;&#160;| Add of 'T * AsyncReplyChannel&lt;unit&gt;<br />&#160;&#160;| Get of AsyncReplyChannel&lt;'T&gt;<br /><br />Full name: Untitled.BlockingAgentMessage&lt;_&gt;<br /><br />&#160;&#160;type: BlockingAgentMessage&lt;'T&gt;<br />&#160;&#160;implements: IEquatable&lt;BlockingAgentMessage&lt;'T&gt;&gt;<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />
<br /><br /><em>Type of messages internally used by 'BlockingQueueAgent&lt;T&gt;'</em><br /></div>
<div class="tip" id="fsbla4">union case BlockingAgentMessage.Add: 'T * AsyncReplyChannel&lt;unit&gt; -&gt; BlockingAgentMessage&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla5">type AsyncReplyChannel&lt;'Reply&gt;<br />with<br />&#160;&#160;member Reply : value:'Reply -&gt; unit<br />end<br /><br />Full name: Microsoft.FSharp.Control.AsyncReplyChannel&lt;_&gt;<br /></div>
<div class="tip" id="fsbla6">type unit = Unit<br /><br />Full name: Microsoft.FSharp.Core.unit<br /><br />&#160;&#160;type: unit<br />&#160;&#160;implements: IComparable<br /></div>
<div class="tip" id="fsbla7">union case BlockingAgentMessage.Get: AsyncReplyChannel&lt;'T&gt; -&gt; BlockingAgentMessage&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla8">type BlockingQueueAgent&lt;'T&gt; =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : maxLength:int -&gt; BlockingQueueAgent&lt;'T&gt;<br />&#160;&#160;&#160;&#160;member AsyncAdd : v:'T * ?timeout:int -&gt; Async&lt;unit&gt;<br />&#160;&#160;&#160;&#160;member AsyncGet : ?timeout:int -&gt; Async&lt;'T&gt;<br />&#160;&#160;&#160;&#160;member Count : int<br />&#160;&#160;end<br /><br />Full name: Untitled.BlockingQueueAgent&lt;_&gt;
<br /><br /><em>Agent that implements an asynchronous blocking queue</em><br /></div>
<div class="tip" id="fsbla9">val maxLength : int<br /><br />&#160;&#160;type: int<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: IFormattable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;int&gt;<br />&#160;&#160;implements: IEquatable&lt;int&gt;<br />&#160;&#160;inherits: ValueType<br /></div>
<div class="tip" id="fsbla10">do <br />&#160;&#160;if maxLength &lt;= 0 then <br />&#160;&#160;&#160;&#160;invalidArg &quot;maxLenght&quot; &quot;Maximal length of the queue should be positive.&quot;<br /><br />// We keep the number of elements in the queue in a local field to<br />// make it immediately available (so that 'Count' property doesn't <br />// have to use messages - which would be a bit slower)<br />[&lt;VolatileField&gt;]<br />let mutable count = 0<br /></div>
<div class="tip" id="fsbla11">val agent : MailboxProcessor&lt;BlockingAgentMessage&lt;'T&gt;&gt;<br /><br />&#160;&#160;type: MailboxProcessor&lt;BlockingAgentMessage&lt;'T&gt;&gt;<br />&#160;&#160;implements: IDisposable<br /></div>
<div class="tip" id="fsbla12">static member MailboxProcessor.Start : body:(MailboxProcessor&lt;'Msg&gt; -&gt; Async&lt;unit&gt;) * ?cancellationToken:CancellationToken -&gt; MailboxProcessor&lt;'Msg&gt;<br /></div>
<div class="tip" id="fsbla13">val queue : Queue&lt;'T&gt;<br /><br />&#160;&#160;type: Queue&lt;'T&gt;<br />&#160;&#160;implements: seq&lt;'T&gt;<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fsbla14">type Queue&lt;'T&gt; =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : unit -&gt; System.Collections.Generic.Queue&lt;'T&gt;<br />&#160;&#160;&#160;&#160;new : int -&gt; System.Collections.Generic.Queue&lt;'T&gt;<br />&#160;&#160;&#160;&#160;new : System.Collections.Generic.IEnumerable&lt;'T&gt; -&gt; System.Collections.Generic.Queue&lt;'T&gt;<br />&#160;&#160;&#160;&#160;member Clear : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Contains : 'T -&gt; bool<br />&#160;&#160;&#160;&#160;member CopyTo : 'T [] * int -&gt; unit<br />&#160;&#160;&#160;&#160;member Count : int<br />&#160;&#160;&#160;&#160;member Dequeue : unit -&gt; 'T<br />&#160;&#160;&#160;&#160;member Enqueue : 'T -&gt; unit<br />&#160;&#160;&#160;&#160;member GetEnumerator : unit -&gt; Enumerator&lt;'T&gt;<br />&#160;&#160;&#160;&#160;member Peek : unit -&gt; 'T<br />&#160;&#160;&#160;&#160;member ToArray : unit -&gt; 'T []<br />&#160;&#160;&#160;&#160;member TrimExcess : unit -&gt; unit<br />&#160;&#160;&#160;&#160;type Enumerator =<br />&#160;&#160;&#160;&#160;&#160;&#160;struct<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;member Current : 'T<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;member Dispose : unit -&gt; unit<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;member MoveNext : unit -&gt; bool<br />&#160;&#160;&#160;&#160;&#160;&#160;end<br />&#160;&#160;end<br /><br />Full name: System.Collections.Generic.Queue&lt;_&gt;<br /><br />&#160;&#160;type: Queue&lt;'T&gt;<br />&#160;&#160;implements: seq&lt;'T&gt;<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fsbla15">val pending : Queue&lt;'T * AsyncReplyChannel&lt;unit&gt;&gt;<br /><br />&#160;&#160;type: Queue&lt;'T * AsyncReplyChannel&lt;unit&gt;&gt;<br />&#160;&#160;implements: seq&lt;'T * AsyncReplyChannel&lt;unit&gt;&gt;<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fsbla16">val emptyQueue : (unit -&gt; Async&lt;'a&gt;)<br /></div>
<div class="tip" id="fsbla17">agent.Scan(fun msg -&gt;<br />&#160;&#160;match msg with <br />&#160;&#160;| Add(value, reply) -&gt; Some &lt;| async {<br />&#160;&#160;&#160;&#160;&#160;&#160;queue.Enqueue(value)<br />&#160;&#160;&#160;&#160;&#160;&#160;count &lt;- queue.Count<br />&#160;&#160;&#160;&#160;&#160;&#160;reply.Reply()<br />&#160;&#160;&#160;&#160;&#160;&#160;return! nonEmptyQueue() }<br />&#160;&#160;| _ -&gt; None )<br /></div>
<div class="tip" id="fsbla18">val nonEmptyQueue : (unit -&gt; Async&lt;'a&gt;)<br /></div>
<div class="tip" id="fsbla19">async {<br />&#160;&#160;let! msg = agent.Receive()<br />&#160;&#160;match msg with <br />&#160;&#160;| Add(value, reply) -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;// Add immediately if possibley, otherwise block caller<br />&#160;&#160;&#160;&#160;&#160;&#160;if queue.Count &lt; maxLength then <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;queue.Enqueue(value)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count &lt;- queue.Count<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reply.Reply()<br />&#160;&#160;&#160;&#160;&#160;&#160;else <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pending.Enqueue(value, reply) <br />&#160;&#160;&#160;&#160;&#160;&#160;return! nonEmptyQueue()<br />&#160;&#160;| Get(reply) -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;let item = queue.Dequeue()<br />&#160;&#160;&#160;&#160;&#160;&#160;// Unblock some blocked callers as we have some space now<br />&#160;&#160;&#160;&#160;&#160;&#160;while queue.Count &lt; maxLength &amp;&amp; pending.Count &gt; 0 do<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let itm, caller = pending.Dequeue()<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;queue.Enqueue(itm)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;caller.Reply()<br />&#160;&#160;&#160;&#160;&#160;&#160;count &lt;- queue.Count<br />&#160;&#160;&#160;&#160;&#160;&#160;reply.Reply(item)<br />&#160;&#160;&#160;&#160;&#160;&#160;// If the queue is empty then switch the state, otherwise loop<br />&#160;&#160;&#160;&#160;&#160;&#160;if queue.Count = 0 then return! emptyQueue()<br />&#160;&#160;&#160;&#160;&#160;&#160;else return! nonEmptyQueue() }<br /></div>
<div class="tip" id="fsbla20">val x : BlockingQueueAgent&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla21">member BlockingQueueAgent.Count : int<br /><br />Full name: Untitled.BlockingQueueAgent`1.Count
<br /><br /><em>Returns the number of items in the queue (immediately)</em><br /></div>
<div class="tip" id="fsbla22">val mutable count : int<br /><br />&#160;&#160;type: int<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: IFormattable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;int&gt;<br />&#160;&#160;implements: IEquatable&lt;int&gt;<br />&#160;&#160;inherits: ValueType<br /></div>
<div class="tip" id="fsbla23">member BlockingQueueAgent.AsyncAdd : v:'T * ?timeout:int -&gt; Async&lt;unit&gt;<br /><br />Full name: Untitled.BlockingQueueAgent`1.AsyncAdd
<br /><br /><em>Asynchronously adds item; blocks if queue is full</em><br /></div>
<div class="tip" id="fsbla24">val v : 'T<br /></div>
<div class="tip" id="fsbla25">val timeout : int option<br /><br />&#160;&#160;type: int option<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: IComparable&lt;Option&lt;int&gt;&gt;<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: Collections.IStructuralComparable<br /></div>
<div class="tip" id="fsbla26">member MailboxProcessor.PostAndAsyncReply : buildMessage:(AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg) * ?timeout:int -&gt; Async&lt;'Reply&gt;<br /></div>
<div class="tip" id="fsbla27">val ch : AsyncReplyChannel&lt;unit&gt;<br /></div>
<div class="tip" id="fsbla28">member BlockingQueueAgent.AsyncGet : ?timeout:int -&gt; Async&lt;'T&gt;<br /><br />Full name: Untitled.BlockingQueueAgent`1.AsyncGet
<br /><br /><em>Asynchronously gets item; blocks if queue is empty</em><br /></div>
<div class="tip" id="fsbla29">member MailboxProcessor.Scan : scanner:('Msg -&gt; Async&lt;'T&gt; option) * ?timeout:int -&gt; Async&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla30">val msg : BlockingAgentMessage&lt;'T&gt;<br /><br />&#160;&#160;type: BlockingAgentMessage&lt;'T&gt;<br />&#160;&#160;implements: IEquatable&lt;BlockingAgentMessage&lt;'T&gt;&gt;<br />&#160;&#160;implements: Collections.IStructuralEquatable<br /></div>
<div class="tip" id="fsbla31">val value : 'T<br /></div>
<div class="tip" id="fsbla32">val reply : AsyncReplyChannel&lt;unit&gt;<br /></div>
<div class="tip" id="fsbla33">union case Option.Some: 'T -&gt; Option&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla34">val async : AsyncBuilder<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.async<br /></div>
<div class="tip" id="fsbla35">Queue.Enqueue(item: 'T) : unit<br /></div>
<div class="tip" id="fsbla36">property Queue.Count: int<br /></div>
<div class="tip" id="fsbla37">member AsyncReplyChannel.Reply : value:'Reply -&gt; unit<br /></div>
<div class="tip" id="fsbla38">union case Option.None: Option&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla39">member MailboxProcessor.Receive : ?timeout:int -&gt; Async&lt;'Msg&gt;<br /></div>
<div class="tip" id="fsbla40">Queue.Enqueue(item: 'T * AsyncReplyChannel&lt;unit&gt;) : unit<br /></div>
<div class="tip" id="fsbla41">val reply : AsyncReplyChannel&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla42">val item : 'T<br /></div>
<div class="tip" id="fsbla43">Queue.Dequeue() : 'T<br /></div>
<div class="tip" id="fsbla44">val itm : 'T<br /></div>
<div class="tip" id="fsbla45">val caller : AsyncReplyChannel&lt;unit&gt;<br /></div>
<div class="tip" id="fsbla46">Queue.Dequeue() : 'T * AsyncReplyChannel&lt;unit&gt;<br /></div>