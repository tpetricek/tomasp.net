<rss version="2.0">
  <channel>
    <title>Tomas Petricek - Languages and tools, open-source, philosophy of science and F# coding</title>
    <link>http://tomasp.net</link>
    <description>Tomas is a computer scientist, open-source developer and an occasional philosopher of science. I'm working on tools for data-driven storytelling, contribute to a number of F# projects and I run trainings and offer consulting via fsharpWorks.</description>
    <item>
      <title>Choose Your Own Adventure Calculus</title>
      <guid>http://tomasp.net/blog/2025/adventure-calculus/</guid>
      <link>http://tomasp.net/blog/2025/adventure-calculus/</link>
      <pubDate>Sun, 02 Feb 2025 13:52:03 GMT</pubDate>
      <description>&lt;p&gt;The rule of three suggests that if you encounter the same pattern for the third time in your
code, you should refactor it into a reusable abstraction. The same thing applies in programming
language theory. When you find that you are doing the same thing for the third time, it is
probably a good idea to stop and think - is there a general pattern?&lt;/p&gt;
&lt;div class="rdecor" style="max-width:400px;text-align:center"&gt;
&lt;img src="https://tomasp.net/blog/2025/adventure-calculus/olympics.png" style="width:100%" /&gt;
&lt;p&gt;&lt;strong&gt;Figure 1.&lt;/strong&gt; Auto-completion list showing possible operations in The Gamma&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;In my &lt;a href="https://tomasp.net/academic/theses/coeffects/" title="Tomas Petricek (2017). Context-aware programming languages"&gt;PhD thesis on context-aware computations&lt;/a&gt;, I did exactly this. When we realised
that liveness analysis, resource tracking and checking of data-flow computations all require
type system with similar structure, we came up with the idea of &lt;em&gt;coeffects&lt;/em&gt;, which is an
abstraction that can capture all three (and so, you only need to add one mechanism for
tracking context into your language).&lt;/p&gt;
&lt;p&gt;Recently, the same thing happened to me again. A lot of my work has been around interaction
with &lt;a href="https://tomasp.net/techdims/" title="Joel Jakubovic, Jonathan Edwards, Tomas Petricek (2023). Technical dimensions of programming systems"&gt;programming systems&lt;/a&gt;. I am interested in looking not just at the programming
languages, but also the stateful, interactive systems they are part of - and how programs are
created through interactive editor tools, gradually revised in notebook systems or how proofs
are created in interactive proof assistants. And interestingly, in three recent collaborations
around those ideas, we ended up finding a very similar pattern.&lt;/p&gt;
&lt;p&gt;In multiple different systems, we encountered a pattern where the programming system
iteratively offers the user (programmer, data scientist, proof theoretician) a choice of
options that the user can choose from to construct or refine their program (see Figure 1).
In all systems, the user can also edit the code in other ways, but a lot (sometimes
everything!) can be done just by choosing options.&lt;/p&gt;
&lt;p&gt;I now have three examples, so it is time to describe the general pattern. Earlier,
we called this (jokingly) dot-driven development, (seriously) AI assistants and (foolishly)
iterative prompting. For the lack of a better name, I will refer to the abstraction
as the &lt;em&gt;choose-your-own-adventure calculus&lt;/em&gt;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>What can routers at Centre Pompidou teach us about software evolution?</title>
      <guid>http://tomasp.net/blog/2023/pompidou/</guid>
      <link>http://tomasp.net/blog/2023/pompidou/</link>
      <pubDate>Thu, 07 Dec 2023 17:30:00 GMT</pubDate>
      <description>&lt;p&gt;Back in June, I was in Paris for the &lt;a href="https://ncrafts.io/"&gt;NewCrafts conference&lt;/a&gt; to talk about
&lt;a href="https://vimeopro.com/newcrafts/newcrafts/video/842234359"&gt;the growing opacity of software systems&lt;/a&gt;.
This was fun, partly because NewCrafts is a fantastic conference (you can already &lt;a href="https://ncrafts.io/"&gt;get your
tickets&lt;/a&gt; for 2024!) and also partly because my talk (arguing against many
established "good engineering" practices) was in many ways arguing for the exact opposite than
one of the keynotes, leading to many interesting conversations.&lt;/p&gt;
&lt;p&gt;While in Paris, I also visited the &lt;a href="https://www.centrepompidou.fr/en/"&gt;famous Centre Pompidou&lt;/a&gt;.
Perhaps to the dismay of many modern art lovers, I spent a lot of time staring at the ceiling
looking for routers.&lt;/p&gt;
&lt;div class="wdecor" style="text-align:center;margin-bottom:50px"&gt;
&lt;img src="https://tomasp.net/blog/2023/pompidou/router1.jpg" style="margin:10px; max-width:30%;border:solid 4px black" /&gt;&lt;/a&gt;
&lt;img src="https://tomasp.net/blog/2023/pompidou/router2.jpg" style="margin:10px; max-width:30%;border:solid 4px black" /&gt;&lt;/a&gt;
&lt;img src="https://tomasp.net/blog/2023/pompidou/router3.jpg" style="margin:10px; max-width:30%;border:solid 4px black" /&gt;&lt;/a&gt;
&lt;p&gt;Spot the routers at Centre Pompidou!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    <item>
      <title>Where programs live? Vague spaces and software systems</title>
      <guid>http://tomasp.net/blog/2023/vague-spaces/</guid>
      <link>http://tomasp.net/blog/2023/vague-spaces/</link>
      <pubDate>Fri, 10 Feb 2023 22:44:19 GMT</pubDate>
      <description>&lt;p&gt;Architecture and urban planning have been a useful source of ideas for thinking about programming.
I have written &lt;a href="https://tomasp.net/blog/tag/design/"&gt;various blog posts&lt;/a&gt; and a paper
&lt;a href="https://tomasp.net/academic/papers/metaphors/"&gt;Programming as Architecture, Design, and Urban Planning&lt;/a&gt;
that argue why and explore some of those ideas. Like urban planning and architecture, the design of
any interesting software system deals with complex problems that can rarely be analysed in full and
with structures that will continue to evolve in unexpected ways after they are created.&lt;/p&gt;
&lt;p&gt;My most recent reading on cities was a book &lt;a href="https://www.academia.cz/mesto-naruby-2-dotisk--haluzik-radan--academia--2021"&gt;The City Inside Out&lt;/a&gt;
(Czech only, unfortunately) that explore places referred to as &lt;a href="https://www.atributosurbanos.es/en/terms/terrain-vague/"&gt;terrain vague&lt;/a&gt;.
This term refers to unused and abandoned spaces that have lost their purpose or
do not have a clear use, but are used in various ways nevertheless. For various historical
reasons, there seem to be quite a few of such places in Prague (Figure 1) and, more generally,
Central European cities, which is the focus of the book.&lt;/p&gt;
&lt;p&gt;The book is an interesting inspiration for thinking about programming in many ways.
It uses an inter-disciplinary approach ranging from history and philosophy to
&lt;a href="https://en.wikipedia.org/wiki/Paleoethnobotany"&gt;archaeobotany&lt;/a&gt;, which is much needed for thinking
about programming too. (Not archeobotany, but inter-disciplinary thinking certainly!)
More specifically, it makes you think about the concept of a &lt;em&gt;space&lt;/em&gt; in
which cities and programs exist, how the spaces inhabited by the two differ, what would it look
like if they were different and what structures get created in those spaces as a result of
social and technical forces.&lt;/p&gt;
&lt;div class="wdecor" style="text-align:center"&gt;
&lt;a href="https://iprpraha.cz/projekt/120/nakladove-nadrazi-zizkov"&gt;&lt;img src="http://tomasp.net/blog/2023/vague-spaces/zizkov.jpg" style="max-width:100%;border:solid 4px black" /&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;Figure 1.&lt;/strong&gt; Nákladové nádraží (freight railway station) Žižkov - an example of a large&lt;br /&gt;
space in Prague that no longer serves its original purpose (&lt;a href="https://hotelove.cz/nakladove-nadrazi-zizkov/"&gt;photo source&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    <item>
      <title>The Timeless Way of Programming</title>
      <guid>http://tomasp.net/blog/2022/timeless-way/</guid>
      <link>http://tomasp.net/blog/2022/timeless-way/</link>
      <pubDate>Thu, 01 Sep 2022 00:03:53 GMT</pubDate>
      <description>&lt;div class="rdecor" style="text-align:center"&gt;
&lt;img src="http://tomasp.net/blog/2022/timeless-way/timeless.jpg" style="max-width:260px" /&gt;
&lt;p style="max-width:260px"&gt;&lt;b&gt;Figure 1.&lt;/b&gt; The Timeless Way of Building - Christopher Alexander&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Many programmers know the name of the architect Christopher Alexander for his work on
&lt;em&gt;design patterns&lt;/em&gt; that has been adapted into the world of programming. A lot of people
know of the, sometimes ridiculed, patterns like strategy (functions!) or visitor (pattern
matching!) and some have read the &lt;a href="https://amzn.to/3Cd7sBv" title="Design Patterns: Elements of Reusable Object-Oriented Software - Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides"&gt;Gang of Four design patterns book&lt;/a&gt; that introduced them.
A few people know of the &lt;a href="https://dreamsongs.com/Files/PatternsOfSoftware.pdf" title="Patterns of Software: Tales from the Software Community - Richard P. Gabriel"&gt;Patterns of Software&lt;/a&gt; book by Richard P. Gabriel, which is a much more
profound reflection on software inspired by the work of Christopher Alexander. And almost
nobody has actually read Christopher Alexander's books. (Thanks in advance for reminding me
on &lt;a href="http://twitter.com/tomaspetricek"&gt;Twitter&lt;/a&gt; that I am mistaken...)&lt;/p&gt;
&lt;p&gt;I read Alexander's &lt;a href="https://amzn.to/3bZw1Y2" title="Notes on the Synthesis of Form - Christopher Alexander"&gt;Notes on the Synthesis of Form&lt;/a&gt; a couple of years ago, and used
it as one of the sources for ideas in my recent Onward! essay on &lt;a href="http://tomasp.net/academic/papers/metaphors/" title="Programming as Architecture, Design, and Urban Planning - Tomas Petricek"&gt;architecture, design and urban
planning&lt;/a&gt;, but I did not know his other work. Only recently, after &lt;a href="https://www.theguardian.com/artanddesign/2022/mar/29/christopher-alexander-obituary"&gt;Christopher Alexander
died&lt;/a&gt;,
I finally ordered two books that are most directly about design patterns,
&lt;a href="https://amzn.to/3CeIrGe" title="The Timeless Way of Building - Christopher Alexander"&gt;The Timeless Way of Building&lt;/a&gt; and &lt;a href="https://amzn.to/3wecpGG" title="A Pattern Language: Towns, Buildings, Construction - Christopher Alexander"&gt;A Pattern Language&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This post is a somewhat unorganized collection of thoughts triggered by reading of The Timeless
Way of Building, including my understanding of Alexander's work, some critical thoughts
and on the applications of his ideas to software.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>No-code, no thought? Substrates for simple programming for all</title>
      <guid>http://tomasp.net/blog/2022/no-code-substrates/</guid>
      <link>http://tomasp.net/blog/2022/no-code-substrates/</link>
      <pubDate>Thu, 28 Apr 2022 09:37:00 GMT</pubDate>
      <description>&lt;div class="rdecor" style="text-align:center"&gt;
&lt;img src="http://tomasp.net/blog/2022/no-code-substrates/flow-matic.png" style="max-width:350px" /&gt;
&lt;p style="max-width:350px"&gt;&lt;strong&gt;Figure 1.&lt;/strong&gt; Virtually eliminates your coding load. FLOW-MATIC promotional
brochure (1957)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;No-code is a hot new topic for programming startups. The idea is to develop a system
that allows end-users to do the programming they need without the difficult task of writing
code. There are no-code systems for building mobile apps, analysing data and many more.&lt;/p&gt;
&lt;p&gt;It is perhaps not a surprise that "eliminating programming load" is not as new idea as some
people may think and there is an excellent blog series on &lt;a href="https://instadeq.com/blog/categories/history/" title="No-code history - Instadeq Blog - No-code Data Analysis &amp;amp; Interactive Visualizations"&gt;no-code history by Instadeq&lt;/a&gt;,
going back to 1959.&lt;/p&gt;
&lt;p&gt;Funnily enough, the 1957 &lt;a href="https://www.computerhistory.org/collections/catalog/102646140" title="Introducing a New Language for Automatic Programming Univac Flow-Matic"&gt;promotional brochure about FLOW-MATIC&lt;/a&gt;,
a predecessor to COBOL created by Grace Hopper, uses almost the same language that you will
find in startup pitch decks today (Figure 1). Of course, in 1957, coding referred to the
tedious process of transcribing the desired program to low-level assembler or (more often)
directly to machine code and "virtually eliminating your coding load" meant having a symbolic
high-level programming language so easy that a reasonably skilled mathematician would be able
to use it.&lt;/p&gt;
&lt;p&gt;So, is there really anything new about no-code systems? Is it really possible to "eliminate
your programming load"? And what would it really take to make some real progress in that direction?&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Pop-up from Hell: On the growing opacity of web programs</title>
      <guid>http://tomasp.net/blog/2021/popup-from-hell/</guid>
      <link>http://tomasp.net/blog/2021/popup-from-hell/</link>
      <pubDate>Fri, 08 Oct 2021 11:14:47 GMT</pubDate>
      <description>&lt;p&gt;I started to learn how to program in high school at the end of the 1990s using a mix of BASIC, Turbo
Pascal and HTML with JavaScript. The seed for this blog post comes from my experience with learning
how to program in JavaScript, without having much guidance or organized resources. This article continues
a theme that I started in my &lt;a href="http://tomasp.net/commodore64"&gt;interactive Commodore 64 article&lt;/a&gt;,
which is to look at past programming systems and see what interesting past ideas have been lost
in contemporary systems. Unlike with Commodore 64, which I first used in 2018 in the
Seattle Living Computers museum, my perspective on the Early Web may be biased by personal
experience. I will do my best to not make this post sound like a grumbling of an old nerd!
(I thought this only comes later, but I may have been wrong...)&lt;/p&gt;
&lt;div class="rdecor"&gt;&lt;img src="http://tomasp.net/blog/2021/popup-from-hell/close-me.gif" style="max-width:400px" /&gt;&lt;/div&gt;
&lt;p&gt;The 1990s, the web had a fair amount of quirky web pages, often created just for fun. The GeoCities
hosting service, which has &lt;a href="http://www.oocities.org"&gt;partly been archived&lt;/a&gt; is a witness of this
and there are even academic books, such as &lt;a href="https://amzn.to/2YiEUVe"&gt;Dot-Com Design&lt;/a&gt; documenting
this history.&lt;/p&gt;
&lt;p&gt;Some of the quirky things that you could do with JavaScript included creating roll-over effects
(making an image change when mouse pointer is over it), creating an animation that follows the
cursor as it moves and, of course, annoying the users with all sorts of pop-up windows for both
entertaining and advertising purposes. Annoying pop-ups will be the starting point for my blog
post, but I'll be using those to make a more general and interesting point about how programs
evolve to become more opaque.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This blog post is based on a talk &lt;a href="http://tpetricek.github.io/Talks/2021/popup-from-hell/"&gt;Popup from hell: Reflections on the most annoying 1990s
program&lt;/a&gt; that I did recently at an
(in person!) meeting of the &lt;a href="https://programme.hypotheses.org/"&gt;PROGRAMme project&lt;/a&gt;. Thanks to
everyone who attended for lively discussion and useful feedback!&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Software designers, not engineers: An interview from alternative universe</title>
      <guid>http://tomasp.net/blog/2021/software-designers/</guid>
      <link>http://tomasp.net/blog/2021/software-designers/</link>
      <pubDate>Mon, 19 Apr 2021 12:30:57 GMT</pubDate>
      <description>&lt;p&gt;While the physicists investigate the nature of the mysterious portal that has recently appeared in
North London, several human beings recently came through the portal, which appears to be a
gate into an alternative universe. As we understood from the last two people coming through the
portal, it seems to be a linked with a universe that is in many ways like ours, reached about the
same level of social and technological development, but differs in numerous curious details.
The paths through which people in this alternative universe reached similar results as our world
are often subtly different.&lt;/p&gt;
&lt;div class="rdecor"&gt;&lt;a href="https://amzn.to/3x0Ww5a"&gt;&lt;img src="http://tomasp.net/blog/2021/software-designers/ways.png" style="max-width:260px" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;The most recent visitor from the alternative universe is Ms Zaha Atkinson, who would most likely
be titled &lt;em&gt;software engineer&lt;/em&gt; in our world, although the title she uses in her home world is
&lt;em&gt;software designer&lt;/em&gt;. She is a well-known software designer and has been also titled using the
strange-sounding title &lt;em&gt;softwarenova&lt;/em&gt;, a label that we will soon say more about. As with other
technological and societal developments, the alternative universe seems to have arrived at very
similar results as our worlds. Software is eating the (alternative) world, but it is built in very
different ways. The interview with Ms Zaha Atkinson, presented below, reveals how very different
the world of software is when we think of programmers as software &lt;em&gt;designers&lt;/em&gt; rather than as
software &lt;em&gt;engineers&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This article is a work of fiction. Any resemblance to actual events or persons, living or dead,
may or may not be entirely coincidental. It has been largely inspired by the book
&lt;a href="https://amzn.to/3x0Ww5a"&gt;Designerly Ways of Knowing&lt;/a&gt; by Nigel Cross. Ms &lt;a href="https://en.wikipedia.org/wiki/Zaha%5FHadid"&gt;Zaha&lt;/a&gt;
&lt;a href="https://en.wikipedia.org/wiki/Bill%5FAtkinson"&gt;Atkinson&lt;/a&gt; also may or may not be entirely fictional.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Is deep learning a new kind of programming? Operationalistic look at programming</title>
      <guid>http://tomasp.net/blog/2020/learning-and-programming/</guid>
      <link>http://tomasp.net/blog/2020/learning-and-programming/</link>
      <pubDate>Wed, 07 Oct 2020 00:43:16 GMT</pubDate>
      <description>&lt;p&gt;In most discussions about how to make programming better, someone eventually says
something along the lines of &lt;em&gt;"we'll just have to wait until deep learning solves
the problem!"&lt;/em&gt; I think this is a &lt;a href="https://en.wikipedia.org/wiki/AI_winter"&gt;naively optimistic idea&lt;/a&gt;,
but it raises one interesting question: In what sense are programs created using deep
learning a &lt;em&gt;different kind&lt;/em&gt; of programs than those written by hand?&lt;/p&gt;
&lt;div class="rdecor"&gt;
&lt;img src="http://tomasp.net/blog/2020/learning-and-programming/bridgman.jpg" style="max-width:350px"/&gt;
&lt;/div&gt;
&lt;p&gt;This question recently arose in discussions that we have been having as part of the
&lt;a href="https://programme.hypotheses.org/"&gt;PROGRAMme project&lt;/a&gt;, which explores historical and
philosophical perspectives on the question "What is a (computer) program?" and so this
article owes much debt to &lt;a href="https://programme.hypotheses.org/members"&gt;others involved in the project&lt;/a&gt;,
especially Maël Pégny, Liesbeth De Mol and Nick Wiggershaus.&lt;/p&gt;
&lt;p&gt;Many people will intuitively think that, if you train a deep neural network to solve some
a problem, you get a different kind of program than if you manually write some logic to solve
the problem. But what exactly is the difference? In both cases, the program is a sequence of
instructions that are deterministically executed by a machine, one after another, to produce
the result.&lt;/p&gt;
&lt;p&gt;When reading the excellent book &lt;a href="https://amzn.to/2SvTwKT" title="Hasok Chang (2004). Inventing Temperature: Measurement and Scientific Progress"&gt;Inventing Temperature&lt;/a&gt; by Hasok
Chang recently, I came across the idea of &lt;a href="https://plato.stanford.edu/entries/operationalism/" title="Hasok Chang (2019). Operationalism, The Stanford Encyclopedia of Philosophy"&gt;operationalism&lt;/a&gt;,
which I believe provides a useful perspective for thinking about the issue of deep learning and
programming. The operationalist point of view was introduced by a physicist Percy Williams Bridgman. To
quote: &lt;em&gt;we mean by any concept nothing more than a set of operations; the concept is synonymous
with the corresponding set of operations&lt;/em&gt;. What does this tell us about deep learning and programming?&lt;/p&gt;


</description>
    </item>
    <item>
      <title>Creating interactive You Draw bar chart with Compost</title>
      <guid>http://tomasp.net/blog/2020/youdraw-compost-visualization/</guid>
      <link>http://tomasp.net/blog/2020/youdraw-compost-visualization/</link>
      <pubDate>Thu, 16 Jul 2020 21:20:16 GMT</pubDate>
      <description>&lt;p&gt;For a long time, I've been thinking about how to design a data visualization library that would
make it easier to compose charts from simple components. On the one hand, there are charting libraries
like &lt;a href="https://developers.google.com/chart"&gt;Google Charts&lt;/a&gt;, which offer a long list of pre-defined
charts. On the other hand, there are libraries like &lt;a href="https://d3js.org/"&gt;D3.js&lt;/a&gt;, which let you
construct any data visualization, but in a very low-level way. There is also &lt;a href="https://vega.github.io/vega/"&gt;Vega&lt;/a&gt;,
based the idea of &lt;em&gt;grammar of graphics&lt;/em&gt;, which is somewhere in between, but requires you to
specify charts in a fairly complex language including &lt;a href="https://vega.github.io/vega/docs/transforms/"&gt;a huge number of transformations&lt;/a&gt;
that you need to write in JSON.&lt;/p&gt;
&lt;p&gt;In the spirit of functional domain specific languages, I wanted to have a small number of
simple but powerful primitives that can be composed by writing code in a normal programming language
like F# or JavaScript, rather than using JSON.&lt;/p&gt;
&lt;p&gt;My final motivation for working on this was the &lt;a href="https://www.nytimes.com/interactive/2017/01/15/us/politics/you-draw-obama-legacy.html"&gt;You Draw It article series&lt;/a&gt;
by New York Times, which uses interactive charts where the reader first has to make their own guess
before seeing the actual data. I wanted to recreate this, but for bar charts, when working on
&lt;a href="http://turing.thegamma.net/expenditure/"&gt;visualizing government spending using The Gamma&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The code for this was somewhat hidden inside The Gamma, but last month, I finally extracted all
the functionality into a new stand-alone library &lt;a href="https://compostjs.github.io/compost/"&gt;Compost.js&lt;/a&gt;
with simple and clean &lt;a href="https://github.com/compostjs/compost"&gt;source code on GitHub&lt;/a&gt; and
an accompanying &lt;a href="https://compostjs.github.io/compost/paper.pdf"&gt;paper draft that describes it (PDF)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In this article, I will show how to use Compost.js to implement a "You Draw" bar chart inspired
by the NYT article. When loaded, all bars show the average value. You have to drag
the bars to positions that you believe represent the actual values. Once you do this, you can
click "Show me how I did" and the chart will animate to show the actual data, revealing how good
your guess was. Before looking at the code, you can have a look at the resulting interactive chart,
showing the top 5 areas from the 2015 UK budget (in % of GDP):&lt;/p&gt;


</description>
    </item>
    <item>
      <title>Data exploration calculus: Capturing the essence of exploratory data scripting</title>
      <guid>http://tomasp.net/blog/2020/data-exploration-calculus/</guid>
      <link>http://tomasp.net/blog/2020/data-exploration-calculus/</link>
      <pubDate>Tue, 21 Apr 2020 13:42:16 GMT</pubDate>
      <description>&lt;p&gt;Most real-world programming languages are too complex to be studied using formal methods.
For this reason, academics often work with simple theoretical languages instead. The &lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus"&gt;λ-calculus&lt;/a&gt;
is a simple formal language that is often used for talking about functional languages, the &lt;a href="https://en.wikipedia.org/wiki/%CE%A0-calculus"&gt;π-calculus&lt;/a&gt;
is a model of concurrent programming and there is an entire book, &lt;a href="https://link.springer.com/book/10.1007/978-1-4419-8598-9"&gt;A Theory of Objects&lt;/a&gt;
modelling various object-oriented systems.&lt;/p&gt;
&lt;div class="rdecor"&gt;&lt;img src="http://tomasp.net/blog/2020/data-exploration-calculus/ft.gif" style="width:360px"/&gt;&lt;br/&gt;&lt;p style="width:360px;line-height:20px;margin-top:10px;text-align:center;"&gt;&lt;small&gt;Animation from Financial Times article "Why the world's recycling system stopped working".&lt;/small&gt;&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;Those calculi try to capture the most interesting aspect of the programming language. This is
function application in functional programming, sending of messages in concurrent programming
and object construction with inheritance in object-oriented programming.&lt;/p&gt;
&lt;p&gt;Recently, I have been working on programming tools for data exploration.
In particular, I'm interested in the kind of programming that journalists need to do when
they work with data. A good example is the coding done for the
&lt;a href="https://www.ft.com/content/360e2524-d71a-11e8-a854-33d6f82e62f8"&gt;Why the world's recycling system stopped working&lt;/a&gt;
article by Financial Times, which is &lt;a href="https://github.com/ft-interactive/recycling-is-broken-notebooks"&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Although data journalists and other data scientists use regular programming languages like
Python, the kind of code they write is very different from the kind of code you need to write
when building a library or a web application in Python.&lt;/p&gt;
&lt;p&gt;In a paper &lt;a href="https://programming-journal.org/2020/4/8/"&gt;Foundations of a live data exploration environment&lt;/a&gt;
that was published in February 2020 in the open access &lt;a href="https://programming-journal.org/"&gt;Programming Journal&lt;/a&gt;,
I wanted to talk about some interesting work that I've been doing on live previews in
&lt;a href="http://thegamma.net"&gt;The Gamma&lt;/a&gt;. For this, I needed a small model of my programming language.&lt;/p&gt;
&lt;p&gt;In the end the most interesting aspect of the paper is the definition of the
&lt;em&gt;data exploration calculus&lt;/em&gt;, a small programming language that captures the kind of code
that data scientists write to explore data. This looks quite different from,
say, a λ-calculus and π-calculus. It should be interesting not only if you're planning to do
theoretical programming language research about data scripting, but also because
it captures some of the atypical properties of the programs that data scientists write...&lt;/p&gt;


</description>
    </item>
    <item>
      <title>On architecture, urban planning and software construction</title>
      <guid>http://tomasp.net/blog/2020/cities-and-programming/</guid>
      <link>http://tomasp.net/blog/2020/cities-and-programming/</link>
      <pubDate>Tue, 07 Apr 2020 22:13:16 GMT</pubDate>
      <description>&lt;p&gt;Despite having the term &lt;em&gt;science&lt;/em&gt; in its name, it is not always clear what kind of
discipline &lt;em&gt;computer science&lt;/em&gt; actually is. Research on programming is sometimes like
science, sometimes like mathematics, sometimes like engineering, sometimes like design
and sometimes like art. It also has a long tradition of importing ideas from a wide range
of other disciplines.&lt;/p&gt;
&lt;p&gt;In this article, I will look at ideas from architecture and urban planning. Architecture
has already been an inspiration for &lt;em&gt;design patterns&lt;/em&gt;, although some would say that we did
quite poor job and imported a trivialized (and not very useful) version of the idea. However,
there are many other interesting ideas in architecture and urban planning worth exploring.&lt;/p&gt;
&lt;div class="rdecor-sm"&gt;&lt;img src="http://tomasp.net/blog/2020/cities-and-programming/patterns.jpg" /&gt;&lt;/div&gt;
&lt;p&gt;To explain why learning from architecture and urban planning is a good idea, I will first
discuss similarities between problems solved by architects or urban planners and programmers.
I will then look at a number of concrete ideas that we can learn, mostly taking inspiration
from four books that I've read recently. There are two general areas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;First, writing about architecture and urban planning often uses interesting methodologies
that research on programming could adopt to gain new insights into systems, programming
and its problems.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Second, there are a number of more concrete ideas in architecture and urban planning that
might directly apply to software. For example, can programmers learn how to deal with complexity
of software by looking at how urban planners deal with the complexity of cities? Or, can we learn
about software maintenance by looking at how buildings evolve in time?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The nature of problems that programmers face are often more similar to the problems that
architects and urban planners have to deal with than, say, the problems that scientists, engineers
or mathematicians need to solve. We might not want to go all the way and completely rebuild
how we do programming to mirror architecture and urban planning, but treating the ideas from those
disciplines as equal to those from science or engineering will make programming richer and more
productive discipline.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>What to teach as the first programming language and why</title>
      <guid>http://tomasp.net/blog/2019/first-language/</guid>
      <link>http://tomasp.net/blog/2019/first-language/</link>
      <pubDate>Mon, 02 Dec 2019 16:48:25 GMT</pubDate>
      <description>&lt;p&gt;The number of Google search results for the phrase
&lt;a href="https://www.google.com/search?q=" title="choosing+the+first+programming+language"&gt;"choosing the first programming language"&lt;/a&gt;
at the time of writing is 15,800. This illustrates just how debated the issue of choosing the first
programming language is. In this blog post, I will not actually try to answer the question posed
in the title of the post. I will not discuss what language we should teach as the first one.
Instead, I will look at a more interesting question.&lt;/p&gt;
&lt;p&gt;I will investigate the arguments that are used in favour of or against particular programming
languages in computer science curriculum. I am more interested in the kind of argumentation that
is employed to support a particular choice than in the specific languages involved. This approach is
valuable for two reasons. First, by looking at the argumentation used, we can learn what educators
consider important about computer science. Second, understanding the motivations behind different
arguments allows us to make our own debates about the choice of a programming language more informed.&lt;/p&gt;
&lt;p&gt;The scope of this blog post is limited to the choice of the first programming language taught in an
undergraduate computer science programmes at universities. This means that I will not discuss other
important contexts such as choices at a primary or a secondary education level, choices for
independent learners and choices in other university degrees that might involve programming.&lt;/p&gt;
&lt;p&gt;Note that this blog post is adapted from an essay that I wrote as part of a
&lt;a href="https://www.kent.ac.uk/teaching/qualifications/pgche/"&gt;Postgrduate Certificate for Higher Education programme&lt;/a&gt;
at University of Kent, so it assumes less knowledge about programming than a typical reader of
my blog has. This makes it accessible to a broader audience thinking about education
though!&lt;/p&gt;


</description>
    </item>
    <item>
      <title>What should a Software Engineering course look like?</title>
      <guid>http://tomasp.net/blog/2019/software-engineering/</guid>
      <link>http://tomasp.net/blog/2019/software-engineering/</link>
      <pubDate>Fri, 08 Feb 2019 11:22:57 GMT</pubDate>
      <description>&lt;p&gt;When I joined the &lt;a href="https://www.cs.kent.ac.uk/"&gt;School of Computing&lt;/a&gt; at the &lt;a href="https://www.kent.ac.uk/"&gt;University of
Kent&lt;/a&gt;, I was asked what subjects I wanted to teach. One of the topics
I chose was &lt;em&gt;Software Engineering&lt;/em&gt;. I spent quite a lot of time reading about the history of
software engineering when working on my paper &lt;a href="/academic/papers/failures/index.html"&gt;on programming
errors&lt;/a&gt; and I go to a fair number of &lt;a href="http://github.com/tpetricek/Talks"&gt;professional
programming conferences&lt;/a&gt;, so I thought I can come up
with a good way of teaching it! Yet, I was not quite sure how to go about it or even what
&lt;em&gt;software engineering&lt;/em&gt; actually means.&lt;/p&gt;
&lt;p&gt;In this blog post, I share my thought process on deciding what to cover in my Software
Engineering module and also a rough list of topics. The introduction explaining &lt;em&gt;why&lt;/em&gt; I chose
these and &lt;em&gt;how&lt;/em&gt; I structure them is perhaps more important than the list itself, but it
is fairly long, so if you just want to see a list you can
&lt;a href="http://tomasp.net/blog/2019/software-engineering/#fund"&gt;skip ahead to Section 2&lt;/a&gt; (but please read the
introduction if you want to comment on the list!) I also add a brief reflection on why I think
this is a good approach, referencing a couple of ideas from philosophy of science in &lt;a href="#phil"&gt;Section 3&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Write your own Excel in 100 lines of F#</title>
      <guid>http://tomasp.net/blog/2018/write-your-own-excel/</guid>
      <link>http://tomasp.net/blog/2018/write-your-own-excel/</link>
      <pubDate>Mon, 12 Nov 2018 12:58:50 GMT</pubDate>
      <description>&lt;p&gt;I've been teaching F# for over seven years now, both in the public F# FastTrack course that we run
at SkillsMatter in London and in various custom trainings for private companies. Every time I teach
the F# FastTrack course, I modify the material in one way or another. I wrote about some of this
interesting history &lt;a href="#"&gt;last year in an fsharpWorks article&lt;/a&gt;. The course now has a stable half-day
introduction to the language and a stable focus on the ideas behind functional-first programming,
but there are always new examples and applications that illustrate this style of programming.&lt;/p&gt;
&lt;img src="http://tomasp.net/blog/2018/write-your-own-excel/logo.png" class="rdecor" /&gt;
&lt;p&gt;When we started, we mostly focused on teaching functional programming concepts that might be useful
even if you use C# and on building analytical components that your could integrate into a larger
.NET solution. Since then, the F# community has matured, established the &lt;a href="http://fsharp.org"&gt;F# Software Foundation&lt;/a&gt;,
but also built a number of mature end-to-end ecosystems that you can rely on such as &lt;a href="http://fable.io"&gt;Fable&lt;/a&gt;,
the F# to JavaScript compiler, and &lt;a href="https://safe-stack.github.io"&gt;SAFE Stack&lt;/a&gt; for full-stack web development.&lt;/p&gt;
&lt;p&gt;For the upcoming December course in London, I added a number of demos and hands-on tasks built
using Fable, partly because running F# in a browser is an easy way to illustrate many concepts
and partly because Fable has some amazing functional-first libraries.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;i class="fa fa-hand-o-right" style="font-size:110%;margin:0px 5px 0px 0px"&gt;&lt;/i&gt;&lt;/em&gt;
If you are interested in learning F# and attending our course, the next &lt;a href="https://skillsmatter.com/courses/473-tomas-petricek-phil-trelford-fast-track-to-fsharp"&gt;F# FastTrack&lt;/a&gt;
takes place on &lt;strong&gt;6-7 December&lt;/strong&gt; in London at SkillsMatter. We also offer custom
on-site trainings. Get in touch at &lt;a href="http://twitter.com/tomaspetricek"&gt;@tomaspetricek&lt;/a&gt;
or email &lt;a href="mailto:tomas@tomasp.net"&gt;tomas@tomasp.net&lt;/a&gt; for a 10% discount for the course.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;One of the new samples I want to show, which I also &lt;a href="https://vimeo.com/281241807"&gt;live coded at NDC 2018&lt;/a&gt;,
is building a simple web-based Excel-like spreadsheet application. The spreadsheet demonstrates
all the great F# features such as domain modeling with types, the power of compositionality
and also how functional-first approach can be amazingly powerful for building user interfaces.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Programming as interaction: A new perspective for programming language research</title>
      <guid>http://tomasp.net/blog/2018/programming-interaction/</guid>
      <link>http://tomasp.net/blog/2018/programming-interaction/</link>
      <pubDate>Mon, 08 Oct 2018 11:22:57 GMT</pubDate>
      <description>&lt;p&gt;In May, I joined the &lt;a href="https://www.cs.kent.ac.uk/"&gt;School of Computing&lt;/a&gt; at the &lt;a href="https://www.kent.ac.uk/"&gt;University of
Kent&lt;/a&gt; as a Lecturer (equivalent of Assistant Professor in some other countries).
When applying for the job, I spent a lot of time thinking about how to best explain the kind of
research that I would like to do. This blog post is a brief summary of my ideas. I'm interested
in way too many things, including &lt;a href="http://tomasp.net/blog/tag/philosophy/"&gt;philosophy and design&lt;/a&gt; and
&lt;a href="http://tomasp.net/blog/tag/data-journalism/"&gt;data journalism&lt;/a&gt;, but this post will be mainly about
programming language research. After all, I'm a member of the &lt;a href="https://www.cs.kent.ac.uk/research/groups/plas/"&gt;Programming Languages
and Systems group&lt;/a&gt;!&lt;/p&gt;
&lt;img src="http://tomasp.net/blog/2018/programming-interaction/kent.png" class="rdecor-sm" style="max-width:250px"/&gt;
&lt;p&gt;Unlike some of my &lt;a href="http://tomasp.net/blog/2016/thinking-unthinkable/"&gt;other posts about programming languages&lt;/a&gt;,
I won't try to convince you that we should be studying programming languages completely differently this
time. Instead, I want to describe &lt;em&gt;one simple trick that will make current programming language
research much more interesting&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;A lot of programming language papers today talk about programs and program properties. In
statically typed programming languages, we can check that a program &lt;span class="math"&gt;\(e\)&lt;/span&gt; has certain type &lt;span class="math"&gt;\(\tau\)&lt;/span&gt;,
which means that, when the program is run, it will only produce values of the type.
This is very nice, but it misses a fundamental thing about programming. How was this program
&lt;span class="math"&gt;\(e\)&lt;/span&gt; actually constructed?&lt;/p&gt;
&lt;p&gt;When programming, you spend most of your time working with programs that are &lt;em&gt;unfinished&lt;/em&gt;. This
means that they do not do what they are supposed to be (eventually) doing and, very often, they
are not well-typed or even syntactically invalid. However, that does not mean that we can afford
to ignore them. In many cases, programmers can even run those programs (using REPL or using a
notebook environment). In other words, programming language research should not study &lt;em&gt;programs&lt;/em&gt;,
but should instead study &lt;em&gt;programming&lt;/em&gt;!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;i class="fa fa-hand-o-right" style="font-size:110%;margin:0px 5px 0px 0px"&gt;&lt;/i&gt;&lt;/em&gt;
I'm also writing this because I'll soon be looking for collaborators and PhD students,
so if the ideas in this blog post sound interesting to you or if you've been working on
something related, please let me know! You can get in touch at &lt;a href="http://twitter.com/tomaspetricek"&gt;@tomaspetricek&lt;/a&gt;
or email &lt;a href="mailto:tomas@tomasp.net"&gt;tomas@tomasp.net&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We'll have funding for PhD students from September 2019 and I'm also working on getting money
for a post-doc position. All of these are open ended, so if the blog post made you curious
(and you wouldn't mind living in Canterbury or London), definitely reach out!&lt;/p&gt;
&lt;/blockquote&gt;


</description>
    </item>
    <item>
      <title>Would aliens understand lambda calculus?</title>
      <guid>http://tomasp.net/blog/2018/alien-lambda-calculus/</guid>
      <link>http://tomasp.net/blog/2018/alien-lambda-calculus/</link>
      <pubDate>Tue, 22 May 2018 09:27:00 GMT</pubDate>
      <description>&lt;p&gt;Unless you are a sci-fi author or some secret government agency, the question whether aliens
would understand lambda calculus is probably not your main practical concern. However, the question
is intriguing because it nicely vividly formulates a fundamental question about our formal mathematical
knowledge. Are mathematical theories and results about them &lt;em&gt;invented&lt;/em&gt;, i.e. constructed by
humans, or &lt;em&gt;discovered&lt;/em&gt;, i.e. are they eternal truths that exist regardless of whether there are
humans to know them?&lt;/p&gt;
&lt;img src="http://tomasp.net/blog/2018/alien-lambda-calculus/human.jpg" class="rdecor"
    style="width:40%;max-width:400px;margin-left:30px;margin-top:0px;margin-bottom:0px" /&gt;
&lt;p&gt;The question makes for a fantastic late night pub debate, but how can we go about answering it using
a more serious methodology? Is there a paper one can read to better understand the problem?
Occasionally, a &lt;a href="https://www.youtube.com/watch?list=PLcGKfGEEONaCIl5eU53uPBnRJ9rbIH32R&amp;amp;v=IOiZatlZtGU"&gt;talk&lt;/a&gt;
or an &lt;a href="https://www.quora.com/Do-aliens-have-LISP-or-Scheme"&gt;online comment&lt;/a&gt;
by a computer scientist comments on this question, but way too often, people miss the fact that
the nature of mathematical entities is one of the fundamental questions of &lt;em&gt;philosophy of
mathematics&lt;/em&gt;. Alas, all those discussions are carefully hidden in the humanities department!&lt;/p&gt;
&lt;p&gt;I believe that knowing a bit about philosophy of mathematics is important if we want to have a
meaningful debate about philosophical questions of mathematics (sic!) and so I did a talk
&lt;a href="https://www.youtube.com/watch?v=JoWH2jNlvQQ"&gt;on this very subject at CodeMesh 2017&lt;/a&gt;.
This article is slightly refined and hopefully
more polished version of the talk for those who, like me, prefer reading over watching.
Keep in mind that the question about the nature of mathematical entities is one of the fundamental
questions of an &lt;em&gt;entire academic discipline&lt;/em&gt;. As such, this article cannot possibly cover all the
relevant discussions. Compared to some other writings in this space, this article is, at least,
based on a couple of philosophical books that, I believe, have useful things to say on the subject!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>The design side of programming language design</title>
      <guid>http://tomasp.net/blog/2017/design-side-of-pl/</guid>
      <link>http://tomasp.net/blog/2017/design-side-of-pl/</link>
      <pubDate>Tue, 12 Sep 2017 16:42:38 GMT</pubDate>
      <description>&lt;div style="text-align:center"&gt;
&lt;a href="http://amzn.to/2gVxn8W"&gt;
  &lt;img src="http://tomasp.net/blog/2017/design-side-of-pl/parsons.jpg" class="rdecor"
    style="max-width:220px;margin-left:30px;margin-top:20px;margin-bottom:20px;width:75%" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;The word "design" is often used when talking about programming languages. In fact, it even made
it into the name of one of the most prestigious academic programming conferences, &lt;a href="http://www.sigplan.org/Conferences/PLDI/"&gt;Programming
Language Design and Implementation (PLDI)&lt;/a&gt;. Yet, it is
almost impossible to come across a paper about programming languages that uses design methods to
study its subject. We intuitively feel that "design" is an important aspect of programming
languages, but we never found a way to talk about it and instead treat programming languages as
mathematical puzzles or as engineering problems.&lt;/p&gt;
&lt;p&gt;This is a shame. Applying design thinking, in the sense used in applied arts, can let us talk
about, explore and answer important questions about programming languages that are ignored when
we limit ourselves to mathematical or engineering methods. I think the programming language
community is, perhaps unconsciously, aware of this - one of the reviews of &lt;a href="http://tomasp.net/academic/papers/fsharp-data/"&gt;my recent PLDI
paper&lt;/a&gt; said &lt;em&gt;"this is a nice, novel design paper,
and the community often wants more design papers in our conferences"&lt;/em&gt;. The problem is that we
we do not know how to write and evaluate work that follows design methodology.&lt;/p&gt;
&lt;p&gt;To better understand how design works, I recently read &lt;a href="http://amzn.to/2gVxn8W"&gt;The Philosophy of Design&lt;/a&gt;
by Glenn Parsons. The book perhaps did not answer many of my questions about design, but it did give
me a number of ideas about what design is, what questions it can explore and how those could be
relevant for the study of programming languages...&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Getting started with The Gamma just got easier</title>
      <guid>http://tomasp.net/blog/2017/thegamma-getting-started/</guid>
      <link>http://tomasp.net/blog/2017/thegamma-getting-started/</link>
      <pubDate>Wed, 14 Jun 2017 12:27:17 GMT</pubDate>
      <description>&lt;p&gt;Over the last year, I have been working on &lt;a href="http://thegamma.net/"&gt;The Gamma project&lt;/a&gt;, which aims
to make data-driven visualizations more trustworthy and to enable large number of people to
build visualizations backed by data. The Gamma makes it possible to create visualizations that
are built on trustworthy primary data sources such as the &lt;a href="http://data.worldbank.org"&gt;World Bank&lt;/a&gt;
and you can provide your own &lt;a href="http://thegamma.net/publishing/"&gt;data source by writing a REST service&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A great piece of feedback that I got when talking about The Gamma is that this is a nice ultimate
goal, but it makes it hard for people to start with The Gamma. If you do not want to use the World
Bank data and you're not a developer to write your own REST service, how do you get started?&lt;/p&gt;
&lt;a href="https://gallery.thegamma.net/create"&gt;
&lt;img src="http://tomasp.net/blog/2017/thegamma-getting-started/gallery.png" style="margin:10px 10% 20px 10%; width:80%"/&gt;
&lt;/a&gt;
&lt;p&gt;To make starting with The Gamma easier, the gallery now has a &lt;a href="https://gallery.thegamma.net/create"&gt;new four-step getting started page&lt;/a&gt;
where you can upload your data as a CSV file or paste it from Excel spreadsheet and create nice
visualizations that let your reader explore other aspects of the data.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gallery.thegamma.net/create"&gt;Head over to The Gamma Gallery to check it out&lt;/a&gt; or continue
reading to learn more about creating your first The Gamma visualization...&lt;/p&gt;


</description>
    </item>
    <item>
      <title>Papers we Scrutinize: How to critically read papers</title>
      <guid>http://tomasp.net/blog/2017/papers-we-scrutinize/</guid>
      <link>http://tomasp.net/blog/2017/papers-we-scrutinize/</link>
      <pubDate>Wed, 12 Apr 2017 13:05:48 GMT</pubDate>
      <description>&lt;p&gt;As someone who enjoys being at the intersection of the academic world and the world of
industry, I'm very happy to see any attempts at bridging this harmful gap. For this reason,
it is great to see that &lt;a href="http://michaelrbernste.in/2014/10/21/should-i-read-papers.html"&gt;more people are interested in reading academic
papers&lt;/a&gt; and that initiatives
like &lt;a href="http://paperswelove.org/"&gt;Papers We Love&lt;/a&gt; are there to help.&lt;/p&gt;
&lt;a href="http://paperswelove.org/"&gt;&lt;img src="http://tomasp.net/blog/2017/papers-we-scrutinize/pwl.png" class="rdecor" style="width:300px;"/&gt;&lt;/a&gt;
&lt;p&gt;There is one caveat with academic papers though. It is very easy to see academic papers
as containing eternal and unquestionable truths, rather than as something that the reader
should actively interact with. I &lt;a href="https://twitter.com/tomaspetricek/status/814600193643577344"&gt;recently remarked&lt;/a&gt;
about this saying that "reading papers" is too passive. I also mentioned one way of doing more
than just "reading", which is to write "critical reviews" – something that we recently tried
to do at the &lt;a href="http://2017.programmingconference.org/track/refuses-2017"&gt;Salon des Refusés&lt;/a&gt; workshop.
In this post, I would like to expand my remark.&lt;/p&gt;
&lt;p&gt;First of all, it is very easy to miss the context in which papers are written. The life of an academic
paper is not complete after it is published. Instead, it continues living its own life – people refer to it
in various contexts, give different meanings to entities that appear in the paper and may "love"
different parts of the paper than the author. This also means that there are different ways of
reading papers. You can try to reconstruct the original historical context, read it according to
the current main-stream interpretation or see it as an inspiration for your own ideas.&lt;/p&gt;
&lt;p&gt;I suspect that many people, both in academia and outside, read papers without worrying about
&lt;em&gt;how&lt;/em&gt; they are reading them. You can certainly "do science" or "read papers" without reflecting
on the process. That said, I think the philosophical reflection is important if we do not want to
get stuck in local maxima.&lt;/p&gt;


</description>
    </item>
    <item>
      <title>The mythology of programming language ideas</title>
      <guid>http://tomasp.net/blog/2017/programming-mythology/</guid>
      <link>http://tomasp.net/blog/2017/programming-mythology/</link>
      <pubDate>Tue, 07 Mar 2017 15:31:34 GMT</pubDate>
      <description>&lt;p&gt;If you read a about the history of science, you will no doubt be astonished by some of the
amazing theories that people used to believe. I recently finished reading &lt;a href="http://amzn.to/2mPjXtW"&gt;The Invention of Science
by David Wootton&lt;/a&gt;, which documents many of them (and is well worth reading,
not just because of this!) For example, did you know that if you put garlic on a magnet, the magnet
will stop working? Fortunately, you can recover the magnet by smearing goats blood on it. &lt;a href="https://en.wikipedia.org/wiki/Giambattista_della_Porta"&gt;Giambattista
della Porta&lt;/a&gt; tested this and concluded that it
was false, but &lt;a href="https://en.wikipedia.org/wiki/Alexander_Ross_(writer)"&gt;Alexander Ross&lt;/a&gt; argued that
our garlic is perhaps not so vigorous as those of ancient Greeks.&lt;/p&gt;
&lt;div style="text-align:center"&gt;&lt;a href="http://tomasp.net/blog/2017/programming-mythology/heliocentric.jpg"&gt;
  &lt;img src="http://tomasp.net/blog/2017/programming-mythology/heliocentric.jpg" class="rdecor"
    style="width:60%;max-width:400px;margin-left:30px;margin-top:0px;margin-bottom:20px" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;You can just laugh at these stories, but they can serve as interesting lessons for any scientist.
The lesson, however, is not the obvious one. Academics will &lt;a href="http://danghica.blogspot.co.uk/2016/09/what-else-are-we-getting-wrong.html"&gt;sometimes read those
stories&lt;/a&gt; and use them
to argue against something they do not consider scientific - arguing that it is like believing
that garlic break magnets.&lt;/p&gt;
&lt;p&gt;This is not how the analogy works. What is amazing about the old stories is that the conclusions
that now seem funny often had very solid reasoning behind them. If you believed in the basic
assumption of the time, then you could reach the same conclusions by following fairly sound
reasoning principles. In other words, the amazing theories were scientific and entirely reasonable.
The lesson is that what seems a completely reasonable idea now, may turn out to be wrong and quite
hilarious in retrospect.&lt;/p&gt;
&lt;p&gt;In this article, I will look at a couple of amazing theories that people believed in the past
and I will explain why they were reasonable given the way of thinking of the time.
Along the way, I will explore some of the ways of thinking that we use today about
programming and computer science and why they might appear silly in the future.&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>