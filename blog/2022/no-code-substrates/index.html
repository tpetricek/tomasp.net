<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <meta name=viewport content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Droid+Sans+Mono&family=Kreon:wght@300;400;500;600&family=PT+Sans:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha512-xh6O/CkQoPOWDdYTDqeRdPCVd1SpvCA9XXcUnZS2FmJNp1coAFzvtCN9BmamE+4aHK8yyUHUSCcJHgXloTyT2A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="alternate" type="application/rss+xml" title="Latest news from Tomas Petricek" href="/rss.xml" />
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <link href="/custom/style.css" rel="stylesheet">
  <link href="/custom/tooltips.css" rel="stylesheet">
  <script src="/custom/tooltips.js" type="text/javascript"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon-big.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/img/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/img/favicon-big.png">
  <meta name="msapplication-TileColor" content="#004C6B">
  <meta name="msapplication-TileImage" content="/img/favicon-big.png">
  <meta name="theme-color" content="#004C6B">
  
  <title>No-code, no thought? Substrates for simple programming for all - Tomas Petricek</title>

  <meta name="description" content=" Is it really possible to eliminate programming load? What would real
progress on making programming easier for all mean? In this article, I take a critical look
at no-code programming platforms using the technical dimensions framework and the idea
of a "programming substrate"." />
  <meta name="keywords" content="academic, research, programming languages, " />  
  <meta name="author" content="Tomas Petricek" />
  <meta name="copyright" content="Tomas Petricek" />
  
  <meta property="og:title" content="No-code, no thought? Substrates for simple programming for all" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://tomasp.net/blog/2022/no-code-substrates/" />
  <meta property="og:image" content="http://tomasp.net/blog/2022/no-code-substrates/card.png" />
  <meta property="og:description" content=" Is it really possible to eliminate programming load? What would real
progress on making programming easier for all mean? In this article, I take a critical look
at no-code programming platforms using the technical dimensions framework and the idea
of a "programming substrate"." />
  
  <meta name="twitter:card" content="summary_large_image">
  
  <meta name="twitter:site" content="@tomaspetricek">
  <meta name="twitter:creator" content="@tomaspetricek">  
  <meta name="twitter:title" content="No-code, no thought? Substrates for simple programming for all" />
  <meta name="twitter:image" content="http://tomasp.net/blog/2022/no-code-substrates/card.png" />
  <meta name="twitter:description" content=" Is it really possible to eliminate programming load? What would real
progress on making programming easier for all mean? In this article, I take a critical look
at no-code programming platforms using the technical dimensions framework and the idea
of a "programming substrate"." />
    
  <script type="application/ld+json">
  {
  	"@context": "http:\/\/schema.org",
  	"@type": "Article",
  	"name": "No-code, no thought? Substrates for simple programming for all",
    "headline": "No-code, no thought? Substrates for simple programming for all",
  	"description": " Is it really possible to eliminate programming load? What would real
progress on making programming easier for all mean? In this article, I take a critical look
at no-code programming platforms using the technical dimensions framework and the idea
of a "programming substrate".",
  	"url": "http://tomasp.net/blog/2022/no-code-substrates/",
  	"author": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	},
  	"creator": ["Tomas Petricek"],
  	"dateCreated": "2022-04-28T11:37:00.4275767+02:00",
  	"datePublished": "2022-04-28T11:37:00.4275767+02:00",
    "dateModified": "2022-04-28T11:37:00.4275767+02:00",
    "mainEntityOfPage": "http://tomasp.net/blog/2022/no-code-substrates/",
  	"image": "http://tomasp.net/blog/2022/no-code-substrates/card.png",
  	"thumbnailUrl": "http://tomasp.net/blog/2022/no-code-substrates/card.png",
  	"keywords": ["academic", "research", "programming languages",  "tomas", "petricek"],
  	"inLanguage": "en-us",
  	"publisher": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
      "logo": "http://tomasp.net/img/favicon-big.png",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	}
  }  
  </script>

</head>
<body class="default">
    
  <span class="tplink"><a href="/">TP</a></span>

  <article class='article''>
    <h1><span class="hmq">No-code, no thought</span><span class="hs"> Substrates for simple programming for all</span></h1>
<div class="rdecor" style="text-align:center">
<img src="http://tomasp.net/blog/2022/no-code-substrates/flow-matic.png" style="max-width:350px" />
<p style="max-width:350px"><strong>Figure 1.</strong> Virtually eliminates your coding load. FLOW-MATIC promotional
brochure (1957)</p>
</div>
<p>No-code is a hot new topic for programming startups. The idea is to develop a system
that allows end-users to do the programming they need without the difficult task of writing
code. There are no-code systems for building mobile apps, analysing data and many more.</p>
<p>It is perhaps not a surprise that "eliminating programming load" is not as new idea as some
people may think and there is an excellent blog series on <a href="https://instadeq.com/blog/categories/history/" title="No-code history - Instadeq Blog - No-code Data Analysis &amp; Interactive Visualizations">no-code history by Instadeq</a>,
going back to 1959.</p>
<p>Funnily enough, the 1957 <a href="https://www.computerhistory.org/collections/catalog/102646140" title="Introducing a New Language for Automatic Programming Univac Flow-Matic">promotional brochure about FLOW-MATIC</a>,
a predecessor to COBOL created by Grace Hopper, uses almost the same language that you will
find in startup pitch decks today (Figure 1). Of course, in 1957, coding referred to the
tedious process of transcribing the desired program to low-level assembler or (more often)
directly to machine code and "virtually eliminating your coding load" meant having a symbolic
high-level programming language so easy that a reasonably skilled mathematician would be able
to use it.</p>
<p>So, is there really anything new about no-code systems? Is it really possible to "eliminate
your programming load"? And what would it really take to make some real progress in that direction?</p>
<h2>1. Substrates for interaction</h2>
<p>If we look beyond buzzwords, what can no-code platforms really attempt to do? To understand this,
let me introduce the idea of <em>programming substrate</em>. The idea is that if you have any sort of
software system, you can interact with it at multiple levels through multiple different
substrates. If you are <em>building</em> a software, you will interact with it through a programming
language by modifying its source code. If you are <em>using</em> a software, you will interact with it
through some (structured) graphical interface. All of those - code in a language and interactions
with a graphical interface - are interactions with different (programming) substrates.</p>
<div class="rdecor" style="text-align:center">
<img src="substrate-accounting.png" style="max-width:520px;width:100%" />
<p style="max-width:520px"><strong>Figure 2.</strong> A hypothetical accounting system with substrates for
development (source code), configuration (graphical or textual) and use (user interface).</p>
</div>
<p>The idea of <em>programming substrates</em> is generalizing the usual distinction between programming a
software system and using a software system. This is useful, because there are often more than
two different substrates. It is also useful because we can analyze the different substrates in terms
of what kinds of change to the software they allow and what is the difficulty of using them.</p>
<p>For example, Figure 2 illustrates different substrates that a hypothetical software for accounting
might have. As a user, you interact ("use") with some graphical interface. This is easy, but it
only allows limited <em>"change"</em> - you can enter your invoices and get the tax return forms!
A more advanced user can also edit system configuration. This may also be graphical or a textual
config file. This is harder, but it lets you modify, for example, how the system calculates taxes.
Finally, you (or the company that develops the system) can modify the code of the system itself.
This is very hard, but it allows changing it in arbitrary ways. You may need this if the government
invents a new kind of tax calculation that nobody expected and so it cannot be added just through
configuration. This is a pretty obvious example, but it shows some important aspects of programming
substrates:</p>
<div class="rdecor" style="text-align:center">
<img src="substrate-excel.png" style="max-width:520px;width:100%"/>
<p style="max-width:520px"><strong>Figure 3.</strong> Excel has substrates for entering data (tables), writing
computations (equations), scripting (VBA macros) and source code for modifying the system
itself, accessible only to Excel developers.</p>
</div>
<ul>
<li>
<p>If there are multiple substrates, sooner or later, users who are familiar with one will hit
its limits and will need to invest into learning the next more powerful substrate. This may be
a large (or even unbridgeable) gap.</p>
</li>
<li>
<p>If you need to change system in complex ways, you will need a substrate that is sufficiently
expressive. In other words, the right bottom corner in the diagram will always be empty. This
is a point made by Fred Brooks in his <a href="https://amzn.to/38tvyLO" title="Fred Brooks - The Mythical Man-Month: Essays on Software Engineering">No Silver Bullet</a> essay -
no matter how much we reduce the <em>accidental complexity</em> caused by our poor tools, the
<em>essential complexity</em> of the problem remains.</p>
</li>
</ul>
<p>A system with a more interesting structure of substrates is Excel (Figure 3). Note that I separated
data entry from writing equations, because many people use it for just recording data. Thanks to
macros, Excel has a more expressive substrate that allows greater change, but is also more complex.
This also means there is a more notable gap - moving from writing equations to VBA scripting has a
non-trivial learning curve.</p>
<h2>2. Challenges for no-code</h2>
<p>I have two simple programming problems that I worked on recently that would, I imagine, ideally
be solvable by a suitable no-code framework. Looking at these illustrates some of the challenges
that no-code systems face.</p>
<h3>2.1. Case study: Managing Year in Computing admissions</h3>
<p>During the pandemic, I was responsible for managing <a href="https://www.kent.ac.uk/computing/about/year-in-computing">Year in Computing</a>
admissions in Kent. Students applied through Google Form, we checked their past studies in an
internal system, scheduled Zoom interview with them, sent them an email invitation and a result
after the interview. I also occasionally needed to get some report on how many students were
offered a place, accepted our offer etc.</p>
<p>Of course, I ended up writing an F# script (and a bit of JavaScript) to partly automate this,
but it would be a good case study for no-code, because it is mostly just an integration of existing
services (Google docs, email, Zoom). Many no-code automation tools provide integration with those.
But there are two problems.</p>
<ul>
<li>
<p>The first is that this may not scale. In March 2020, Zoom was still
newish and the API was changing, so the no-code platform developers would have to keep up with that
to make sure the integration works and exposes all that is needed.</p>
</li>
<li>
<p>The second problem are the exceptions. In my case, I had to get student marks from an internal
system, which was obscure (and was replaced the following year). I had a JavaScript hack to
extract the data that I could paste into a browser JavaScript console, which mostly worked.
But this was not a simple task of extracting numbers from a table - there are non-numerical marks
(Pass/Fail), repeated years, retaken exams and other exceptions.</p>
</li>
</ul>
<h3>2.2. Case study: Scraping charitable giving data</h3>
<p>Another project I was involved with was scraping data from crowdfunding platforms,
which we started to do during the pandemic and which resulted in a <a href="http://tomasp.net/academic/papers/covid-data/" title="Peter Taylor-Gooby, Tomas Petricek and Jack Cunliffe - Covid-19, Charitable Giving and Collectivism a data-harvesting approach. Journal of Social Policy, 2021">joint social policy paper</a> (Figure 5).</p>
<div class="rdecor" style="text-align:center">
<img src="fundraisers.png" style="max-width:520px;width:100%"/>
<p style="max-width:520px"><strong>Figure 5.</strong> Charts showing number of fundraisers and amount
donated to "foodbanks", following the Covid-19 outbreak. There was a major peak during the first
wave, but no significant increase for other waves (with the exception of Christmas period).</p>
</div>
<p>This is similarly conceptually simple task. You just need to search for various terms on the
platform, iterate over the results and fetch data about fundraiser details, dates and (when possible)
individual donations. In reality, it is not as easy:</p>
<ul>
<li>
<p>Some of the services just return HTML, but one loads all data dynamically through GraphQL,
so you either need to work at a browser level (simulating clicks) which is slow, or extract data
from different structures (funny HTML, funny JSON).</p>
</li>
<li>
<p>As always, there are unexpected changes. After about a year of running my script, one of the platforms
renamed some CSS classes; after a few more months, one page was collecting donations in Euros
(one in Dollars appeared later too). Two years after I started doing this, one page reported
raised amount in Portuguese. One government service was shut-down halfway through my project too.</p>
</li>
</ul>
<p>The question then is, what kind of programming substrates do we need if we want to be
able to solve the above problems, as easily as possible (with or without code)?</p>
<h2>3. Technical dimensions of no-code systems</h2>
<p>We know how to talk about programming languages and their features, but talking about
possibly visual, interactive, stateful programming systems has been a challenge. To make this
easier, Joel Jakubovic, Jonathan Edwards and myself recently came up with the
<a href="https://raw.githubusercontent.com/jdjakub/papers/master/prog-2022/prog22-master.pdf" title="Joel Jakubovic, Jonathan Edwards, Tomas Petricek - Technical Dimensions of Programming Systems. Submitted, 2022">Technical dimensions of programming systems</a> framework. This is a qualitative
framework that defines a number of <em>dimensions</em> that can be used to describe programming
systems. For example, the "feedback loops" dimension describes how a system provides
feedback to the developer or a user (in Excel, there is, for example, a live loop when editing
values in a sheet or a less immediate error checking when editing equations or VBA scripts).</p>
<p>Several technical dimensions are highly relevant for no-code systems:</p>
<ul>
<li>
<p><strong>Notational structure</strong> - <em>What are the different notations involved in programming and using
the system?</em> In conventional programming systems, there is a primary notation - the programming
language in which code is written - alongside with various secondary notations.</p>
<p>In no-code systems, the primary notation is typically a visual language or a user interface.
This may be complemented by some small DSL, e.g., for specifying conditions, and eventually
also a programming language (exposed or not), e.g., for writing extensions for integrating with
other platforms.</p>
</li>
<li>
<p><strong>Self-sustainability</strong> - <em>To what extent can the behaviour of a system be changed within itself?</em>
In Java or C#, this is limited to reflection, but Smalltalk or Lisp Machines make it possible to
modify the development environment from within itself.</p>
<p>The self-sustainability of no-code systems is typically very limited. They are closed-source and
largely written in another programming language and can be only used to build applications in
a particular domain. Even integration for other services has to be done outside of the
system.</p>
</li>
<li>
<p><strong>Degrees of automation</strong> - <em>What part of program logic does not need to be explicitly specified?</em>
In C# or Java, the only thing that is done automatic is garbage collection, but you can go
further. For example, Prolog and SQL automate evaluation and you need more declarative programs.</p>
<p>This is perhaps one way where no-code systems can meaningfully try to do something clever.
Some of the exceptions in my above examples could probably be handled by a <a href="https://cacm.acm.org/magazines/2012/8/153800-spreadsheet-data-manipulation-using-examples/fulltext" title="Sumit Gulwani, William R. Harris, Rishabh Singh - Spreadsheet Data Manipulation Using Examples. Communications of ACM, 2012">programming-by-example</a>
tool like FlashFill in Excel.</p>
</li>
</ul>
<p>You should check out our <a href="https://raw.githubusercontent.com/jdjakub/papers/master/prog-2022/prog22-master.pdf" title="Joel Jakubovic, Jonathan Edwards, Tomas Petricek - Technical Dimensions of Programming Systems. Submitted, 2022">Technical dimensions</a> framework for more ideas, but the three
dimensions above are a good structure for three thoughts I have on no-code programming platforms.</p>
<h3>3.1. Notational structure and HyperCard</h3>
<p>HyperCard is not a no-code platform, because it does let people write code in HyperTalk
(and besides, it was created some 30 years before no-code became a buzzword), but it has been
amazingly successful at allowing non-experts create programs. It also has a very clever way of
structuring its programming substrate. In HyperCard, you design your cards in a WYSIWYG editor
and you can attach behaviour to elements. You can specify that a button links to another card
without coding, but more advanced interactions require HyperTalk.</p>
<p>There are still two substrates. The software itself is written in another language (it is not
self-sustainable, except for its documentation which is a HyperCard stack) and there is the
visual HyperCard environment itself. However, the visual environment is structured in terms
of several <em>user levels</em> (Figure 6) that gradually unlock more advanced features of the system.
These add further notations (like HyperTalk code), but they still live within a single substrate.</p>
<div class="wdecor" style="text-align:center">
<div class="wfig">
  <img src="hypercard.png" style="width:100%"/>
  <p><strong>Figure 6.</strong> Choosing a user level in HyperCard. Each level allows
    the user to access more advanced editing or programming features.</p>
</div>
<div class="wfig">
  <img src="substrate-hypercard.png" style="width:100%"/>
  <p><strong>Figure 7.</strong> Different user levels have different notations, but
    are accessible from a single substrate - the HyperCard user interface.</p>
</div>
</div>
<p>The nice aspect of this is that it makes the learning process gradual. As illustrated in Figure 7,
you start by browsing, move to editing text and design, then unlock capabilities for adding
new cards and only then move to writing code. This somewhat reduces the gap (as, e.g., between
the Excel substrates) that you need to bridge if you need more complex change, because you are
staying in the same substrate, albeit you get access to more complex features it provides. It
also means you do not get overwhelmed by all that is available, as more advanced features are
initially hidden. In the programming languages world, Racket follows the same model with its
<a href="https://docs.racket-lang.org/drracket/htdp-langs.html" title="How to Design Programs Teaching Languages - Racket">How to design programs teaching languages</a>.</p>
<h3>3.2. Self-sustainability and open systems</h3>
<p>Despite the interesting notational structure, HyperCard is not <em>self-sustainable</em> meaning that
it cannot be modified from itself. It is an application (apparently written in Apple Pascal!)
and if you want to change it, you have to modify its source code.</p>
<p>How is this relevant for no-code platforms? The more self-sustainable a system is, the
more you will be able to do from within itself. This may not matter much when you are
just integrating a couple of services. But as my case studies illustrated, there are always
exceptions and cases the platform developers couldn't have thought of. If the system can be
modified, it makes it possible for a user to gradually become programmer. (And also to develop
a shared <a href="https://www.shift-society.org/salon/papers/2017/revised/externalization.pdf" title="Colin Clark and Antranig Basman - Tracing a Paradigm for Externalization: Avatars and the GPII Nexus">open ecology of function</a> that takes care of the scaling issue I mentioned
earlier.)</p>
<p>The idea that the user can gradually become programmer exists, for example, in Smalltalk (from
<a href="https://archive.org/details/byte-magazine-1981-08" title="User-oriented Descriptions of Smalltalk Systems - Byte, August 1981">User-oriented Descriptions of Smalltalk Systems</a>):</p>
<blockquote>
<p>[T]the new user of a Smalltalk system is likely to begin by using its ready-made application
systems [...]. After a while, he may become curious as to how his system works. He should
then be able to "open up" the application object [...] The next thing the user might want
to do is to build new systems similar to the one has been using.
Finally, the expert user will want to make his own ["kits" for building such systems].</p>
</blockquote>
<p>The substrate for a fully self-sustainable system needs to allow making both small and large
changes. As discussed earlier, small changes can be easy, but large changes will inevitably
be hard to do. This is illustrated in Figure 8, which shows the possible range of programming
substrates and Figure 9, which shows what we would ideally like to get.</p>
<div class="wdecor" style="text-align:center">
<div class="wfig">
  <img src="substrate-possible.png" style="width:100%"/>
  <p><strong>Figure 8.</strong> Programming substrates can make small changes easy, but large changes will inevitably remain hard.</p>
</div>
<div class="wfig">
  <img src="substrate-ideal.png" style="width:100%"/>
  <p><strong>Figure 9.</strong> Ideal substrate makes sure that making a small change is easy rather than hard.</p>
</div>
</div>
<p>The issue with self-sustainable systems is that they are generally quite hard to use. In
Smalltalk or Lisp Machines, you have to master a real programming language before you can
do pretty much anything. In other words, the programming substrate is in the upper region
of my chart and making even a small change is hard. The point of no-code platforms is to make
smaller (to medium) changes easy. A perfect system would have a programming substrate shown in
Figure 9. This would make small changes easy by design, but allow gradual progression to
more complex ways of working that are necessary for larger changes. (I have no idea how to
do this, but HyperCard seems like an interesting option!)</p>
<h3>3.3. Limits of automation</h3>
<p>Systems like FLOW-MATIC that I opened this post with were called "automatic programming systems"
in the 1950s and 1960s. They eventually turned into programming languages, but the hope
at the time was that you could gradually automate programming to a greater and greater degree.
Today, this is again a hope of many who are trying to make programming "easier", especially
with the idea that machine learning can magically do our work.</p>
<p>There are certainly areas where this has worked well, like programming by example in the
case of Excel FlashFill. David Canfield Smith, who created the <a href="http://worrydream.com/refs/Smith%20-%20Pygmalion.pdf" title="PYGMALION: A Creative Programming Environment - David Canfield Smith">visual Pygmalion programming
environment</a> in 1975 is one of those who recognized the danger of this approach:</p>
<blockquote>
<p>[T]here is a danger in [automatic programming], if carried too far. By making the computer
into a "black box" that does the actual programming, the user has to think less about the
logical structure of the problem. [...]</p>
<p>If successful, automatic programming systems will replace some fairly high-level thinking
processes in humans. Instead of encouraging humans to do more and better thinking,
automatic programming may encourage humans to do less and poorer thinking.</p>
</blockquote>
<p>Pygmalion was an interesting system, because it tried to make programming simpler, but without
automating it. The approach - now known as "programming by demonstration" was to instruct
the computer how to complete task by showing the necessary steps that the computer would then
mechanically repeat.</p>
<h2>4. Research directions for no-code</h2>
<p>I introduced the idea of programming substrates and talked about our work on technical dimensions,
because these provide useful framework for thinking about the main question of this post -
what would it take to make some real progress towards making programming easer?</p>
<p>Now, I have not looked at every single no-code platform out there. There are certainly
many interesting and innovative ideas in the ones I looked at and I'm sure there are more in
those I do not know. But I also think that there are some fundamental limits.</p>
<ul>
<li>
<p>A system that is not self-sustainable will inevitably, sooner or later, make it impossible
for the user to do something they want to do. (The horror stories I sometimes hear about some
elaborate Excel uses in the finance sector are a proof of that.)</p>
</li>
<li>
<p>Automation can only help to a certain degree. Ultimately, programming is thinking about the
problem we are solving and trying to eliminate that would be a move in a wrong direction.
Finding ways to encourage clear high-level thinking (possibly using visual metaphor as attempted
by <a href="http://worrydream.com/refs/Smith%20-%20Pygmalion.pdf" title="PYGMALION: A Creative Programming Environment - David Canfield Smith">Pygmalion</a> or <a href="https://web.media.mit.edu/~mres/papers/boxer.pdf" title="BOXER: A Reconstructible Computational Medium - Andrea di Sessa, Harold Abelson">Boxer</a>) is more interesting approach!</p>
</li>
</ul>
<p>To conclude, I think the big open question is how to create a programming substrate that
is simple enough for small changes, but embodies the potential for large changes.</p>
<p>To a limited extent, HyperCard does this well by having all authoring tools embedded in an environment
that looks the same way as the running program. This makes it easy for users to gradually discover
more advanced capabilities of the system. Could something like this be more visual and more
self-sustainable?</p>
<p>I also think the issue with "code" is quite different than what people usually think. It is not
that "code" is somehow inherently complicated. People find it <em>scary</em> but if they actually try
it (and get decent user experience), they are able to work with code (at least, that was my
conclusion from some empirical experiments I did using <a href="https://thegamma.net/">The Gamma</a>).
The issue is that it is very difficult to connect code to what we actually see happening on
the screen. And this is a problem regardless of whether the code is textual or uses some visual
programming language.</p>
<h4>Acknowledgements</h4>
<p>Some of the ideas in this post are <a href="https://www.shift-society.org/salon/papers/2018/critiques/critique-anatomy-of-interaction.pdf" title="Critique of ‘An Anatomy of Interaction’ - Tomas Petricek">from a critique</a> of a paper <a href="https://hal.archives-ouvertes.fr/hal-01854418/document" title="An anatomy of interaction: co-occurrences and entanglements - Antranig Basman, Philip Tchernavskij, Simon Bates, Michel Beaudouin-Lafon">Anatomy of interaction</a>
by Antranig Basman, Philip Tchernavskij, Simon Bates and Michel Beaudouin-Lafon from Salon des
Refusés workshop. Discussions with Antranig, Philip and also Jonathan Edwards and Joel Jakubovic
contributed to the ideas here (but they would probably disagree with many things I'm writing!)
Parts about Pygmalion and Smalltalk were also influenced by ongoing work on notations as part of the
<a href="https://programme.hypotheses.org/">PROGRAMme</a> project, especially with Liesbeth De Mol.</p>
<p><style type="text/css">
.wfig {
width:45%;
display:inline-block;
margin:0px 2% 0px 2%
}
@media only screen and (max-width: 600px) {
.wfig { width:94%; }
}</p>
</style>
<h2>References</h2>
<ol>
<li><a href='https://instadeq.com/blog/categories/history/'>No-code history - Instadeq Blog - No-code Data Analysis & Interactive Visualizations</a></li>
<li><a href='https://www.computerhistory.org/collections/catalog/102646140'>Introducing a New Language for Automatic Programming Univac Flow-Matic</a></li>
<li><a href='https://amzn.to/38tvyLO'>Fred Brooks - The Mythical Man-Month: Essays on Software Engineering</a></li>
<li><a href='http://tomasp.net/academic/papers/covid-data/'>Peter Taylor-Gooby, Tomas Petricek and Jack Cunliffe - Covid-19, Charitable Giving and Collectivism a data-harvesting approach. Journal of Social Policy, 2021</a></li>
<li><a href='https://raw.githubusercontent.com/jdjakub/papers/master/prog-2022/prog22-master.pdf'>Joel Jakubovic, Jonathan Edwards, Tomas Petricek - Technical Dimensions of Programming Systems. Submitted, 2022</a></li>
<li><a href='https://cacm.acm.org/magazines/2012/8/153800-spreadsheet-data-manipulation-using-examples/fulltext'>Sumit Gulwani, William R. Harris, Rishabh Singh - Spreadsheet Data Manipulation Using Examples. Communications of ACM, 2012</a></li>
<li><a href='https://docs.racket-lang.org/drracket/htdp-langs.html'>How to Design Programs Teaching Languages - Racket</a></li>
<li><a href='https://www.shift-society.org/salon/papers/2017/revised/externalization.pdf'>Colin Clark and Antranig Basman - Tracing a Paradigm for Externalization: Avatars and the GPII Nexus</a></li>
<li><a href='https://archive.org/details/byte-magazine-1981-08'>User-oriented Descriptions of Smalltalk Systems - Byte, August 1981</a></li>
<li><a href='http://worrydream.com/refs/Smith%20-%20Pygmalion.pdf'>PYGMALION: A Creative Programming Environment - David Canfield Smith</a></li>
<li><a href='https://web.media.mit.edu/~mres/papers/boxer.pdf'>BOXER: A Reconstructible Computational Medium - Andrea di Sessa, Harold Abelson</a></li>
<li><a href='https://www.shift-society.org/salon/papers/2018/critiques/critique-anatomy-of-interaction.pdf'>Critique of ‘An Anatomy of Interaction’ - Tomas Petricek</a></li>
<li><a href='https://hal.archives-ouvertes.fr/hal-01854418/document'>An anatomy of interaction: co-occurrences and entanglements - Antranig Basman, Philip Tchernavskij, Simon Bates, Michel Beaudouin-Lafon</a></li>
</ol>


    <div class="info">
    <p class="share">
        <a target="_blank" href="https://twitter.com/intent/tweet?url=http%3a%2f%2ftomasp.net%2fblog%2f2022%2fno-code-substrates%2f&amp;text=No-code%2c+no+thought%3f+Substrates+for+simple+programming+for+allvia+%40tomaspetricek">
          <i class="fab fa-twitter-square"></i></a>
        <a target="_blank" href="https://www.facebook.com/sharer.php?u=http%3a%2f%2ftomasp.net%2fblog%2f2022%2fno-code-substrates%2f">
          <i class="fab fa-facebook-square"></i></a>
        <a href="http://www.reddit.com/submit?url=http%3a%2f%2ftomasp.net%2fblog%2f2022%2fno-code-substrates%2f&title=No-code%2c+no+thought%3f+Substrates+for+simple+programming+for+all">
          <i class="fab fa-reddit-square"></i></a>
        <a href="mailto:?subject=No-code%2c%20no%20thought%3f%20Substrates%20for%20simple%20programming%20for%20all&body=%20Is%20it%20really%20possible%20to%20eliminate%20programming%20load%3f%20What%20would%20real%0d%0aprogress%20on%20making%20programming%20easier%20for%20all%20mean%3f%20In%20this%20article%2c%20I%20take%20a%20critical%20look%0d%0aat%20no-code%20programming%20platforms%20using%20the%20technical%20dimensions%20framework%20and%20the%20idea%0d%0aof%20a%20%22programming%20substrate%22.%0a%0aSee%3a%20http%3a%2f%2ftomasp.net%2fblog%2f2022%2fno-code-substrates%2f">
          <i class="fa fa-envelope"></i></a>
    </p>
    <p class="details">
      <strong>Published:</strong> Thursday, 28 April 2022, 11:37 AM<br />
      <strong>Author:</strong> Tomas Petricek<br />
      <strong>Typos:</strong> <a href="http://github.com/tpetricek/tomasp.net">Send me a pull request</a>!<br />
      
        <strong>Tags:</strong> <a
          href="/blog/tag/academic/">academic</a>, <a
          href="/blog/tag/research/">research</a>, <a
          href="/blog/tag/programming-languages/">programming languages</a></span><br />
      
    </p>
    </div>
  </article>


  <footer>
  <div class="footer-body">
    <div class="fl70"><div class="fmr">
      <h4><a href="http://tomasp.net/rss.xml"><i class="fa fa-rss" style="margin-right:5px;"></i></a> Blog archives</h4>
      <p>
      
      <a href="/blog/archive/february_2025/">February 2025 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2023/">December 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2023/">February 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2022/">September 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2022/">April 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2021/">October 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2021/">April 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2020/">October 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2020/">July 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2020/">April 2020 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2019/">December 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2019/">February 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2018/">November 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2018/">October 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2018/">May 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2017/">September 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2017/">June 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2017/">April 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2017/">March 2017 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2017/">January 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2016/">October 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2016/">September 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/august_2016/">August 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2016/">July 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2016/">May 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2016/">April 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2015/">December 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2015/">November 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2015/">September 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2015/">July 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2015/">June 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2015/">May 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2015/">April 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2015/">March 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2015/">February 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2015/">January 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2014/">December 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2014/">May 2014 (3)</a>,&nbsp;
      
      <a href="/blog/archive/april_2014/">April 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2014/">March 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2014/">January 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2013/">December 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2013/">November 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2013/">October 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2013/">September 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2013/">August 2013 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2013/">May 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2013/">April 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2013/">March 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2013/">February 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2013/">January 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2012/">December 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/october_2012/">October 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2012/">August 2012 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2012/">June 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2012/">April 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2012/">March 2012 (4)</a>,&nbsp;
      
      <a href="/blog/archive/february_2012/">February 2012 (5)</a>,&nbsp;
      
      <a href="/blog/archive/january_2012/">January 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2011/">November 2011 (5)</a>,&nbsp;
      
      <a href="/blog/archive/august_2011/">August 2011 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2011/">July 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/june_2011/">June 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2011/">May 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2011/">March 2011 (4)</a>,&nbsp;
      
      <a href="/blog/archive/december_2010/">December 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2010/">November 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2010/">October 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/september_2010/">September 2010 (4)</a>,&nbsp;
      
      <a href="/blog/archive/july_2010/">July 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2010/">June 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2010/">May 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2010/">February 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2010/">January 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/december_2009/">December 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2009/">July 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2009/">June 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2009/">May 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2009/">April 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2009/">March 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2009/">February 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2008/">December 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2008/">November 2008 (5)</a>,&nbsp;
      
      <a href="/blog/archive/october_2008/">October 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2008/">September 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2008/">June 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2008/">March 2008 (3)</a>,&nbsp;
      
      <a href="/blog/archive/february_2008/">February 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2007/">December 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2007/">November 2007 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2007/">October 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2007/">September 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2007/">August 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2007/">July 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2007/">April 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2007/">March 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2007/">February 2007 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2007/">January 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2006/">November 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2006/">October 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/august_2006/">August 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/july_2006/">July 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2006/">June 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2006/">May 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2006/">April 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2005/">December 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2005/">July 2005 (4)</a>,&nbsp;
      
      <a href="/blog/archive/june_2005/">June 2005 (5)</a>,&nbsp;
      
      <a href="/blog/archive/may_2005/">May 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2005/">April 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2005/">March 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2005/">January 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2004/">December 2004 (3)</a>,&nbsp;
      
      <a href="/blog/archive/november_2004/">November 2004 (2)</a>,&nbsp;
      
      </p>
    </div></div>
    <div class="fr30"><div class="fmr">
      <h4>License and about</h4>
      <p>All articles on this site are licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share Alike</a>.
        All source code samples are licensed under the MIT License.
      </p>
      <p>This site is hosted on GitHub and is generated using <a href="https://github.com/tpetricek/FSharp.Formatting">F# Formatting</a>
        and <a href="http://dotliquidmarkup.org/">DotLiquid</a>.
        For more info, see the <a href="https://github.com/tpetricek/tomasp.net">website source on GitHub</a>.
      </p>
      <p>Please submit issues &amp; corrections on GitHub. Use pull requests for minor corrections only.</p>
      <ul>
        <li><i class="fab fa-twitter"></i> Twitter: <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a></li>
        <li><i class="fab fa-github"></i> GitHub: <a href="https://github.com/tpetricek">@tpetricek</a></li>
        <li><i class="fa fa-envelope"></i> Email: <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a></li>
      </ul>
      <p style="text-align:center;margin-top:15px;"><img src="https://tomasp.net/img/cc-sa.png" alt="CC License logo" /></p>
    </div></div>
  </div>
  </footer>

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-1561220-1']);
    _gaq.push(['_trackPageview']);
    (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</body>
</html>
