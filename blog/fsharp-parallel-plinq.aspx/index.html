<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <meta name=viewport content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Droid+Sans+Mono&family=Kreon:wght@300;400;500;600&family=PT+Sans:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha512-xh6O/CkQoPOWDdYTDqeRdPCVd1SpvCA9XXcUnZS2FmJNp1coAFzvtCN9BmamE+4aHK8yyUHUSCcJHgXloTyT2A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="alternate" type="application/rss+xml" title="Latest news from Tomas Petricek" href="/rss.xml" />
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <link href="/custom/style.css" rel="stylesheet">
  <link href="/custom/tooltips.css" rel="stylesheet">
  <script src="/custom/tooltips.js" type="text/javascript"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon-big.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/img/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/img/favicon-big.png">
  <meta name="msapplication-TileColor" content="#004C6B">
  <meta name="msapplication-TileImage" content="/img/favicon-big.png">
  <meta name="theme-color" content="#004C6B">
  
  <title>Parallel Programming in F# (II.): Using PLINQ and Tasks - Tomas Petricek</title>

  <meta name="description" content=" In this article, we'll look at several F# samples from Chapters 2 and 3 of Parallel Programming with Microsoft .NET. We'll look at using Task Parallel Library (TPL) and Parallel LINQ from F#, including the PSeq module from F# PowerPack." />
  <meta name="keywords" content="functional, parallel, f#, " />  
  <meta name="author" content="Tomas Petricek" />
  <meta name="copyright" content="Tomas Petricek" />
  
  <meta property="og:title" content="Parallel Programming in F# (II.): Using PLINQ and Tasks" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://tomasp.net/blog/fsharp-parallel-plinq.aspx/" />
  <meta property="og:image" content="" />
  <meta property="og:description" content=" In this article, we'll look at several F# samples from Chapters 2 and 3 of Parallel Programming with Microsoft .NET. We'll look at using Task Parallel Library (TPL) and Parallel LINQ from F#, including the PSeq module from F# PowerPack." />
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:site" content="@tomaspetricek">
  <meta name="twitter:creator" content="@tomaspetricek">  
  <meta name="twitter:title" content="Parallel Programming in F# (II.): Using PLINQ and Tasks" />
  <meta name="twitter:image" content="" />
  <meta name="twitter:description" content=" In this article, we'll look at several F# samples from Chapters 2 and 3 of Parallel Programming with Microsoft .NET. We'll look at using Task Parallel Library (TPL) and Parallel LINQ from F#, including the PSeq module from F# PowerPack." />
    
  <script type="application/ld+json">
  {
  	"@context": "http:\/\/schema.org",
  	"@type": "Article",
  	"name": "Parallel Programming in F# (II.): Using PLINQ and Tasks",
    "headline": "Parallel Programming in F# (II.): Using PLINQ and Tasks",
  	"description": " In this article, we'll look at several F# samples from Chapters 2 and 3 of Parallel Programming with Microsoft .NET. We'll look at using Task Parallel Library (TPL) and Parallel LINQ from F#, including the PSeq module from F# PowerPack.",
  	"url": "http://tomasp.net/blog/fsharp-parallel-plinq.aspx/",
  	"author": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	},
  	"creator": ["Tomas Petricek"],
  	"dateCreated": "2010-09-06T10:10:00.0000000",
  	"datePublished": "2010-09-06T10:10:00.0000000",
    "dateModified": "2010-09-06T10:10:00.0000000",
    "mainEntityOfPage": "http://tomasp.net/blog/fsharp-parallel-plinq.aspx/",
  	"image": "",
  	"thumbnailUrl": "",
  	"keywords": ["functional", "parallel", "f#",  "tomas", "petricek"],
  	"inLanguage": "en-us",
  	"publisher": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
      "logo": "http://tomasp.net/img/favicon-big.png",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	}
  }  
  </script>

</head>
<body class="default">
    
  <span class="tplink"><a href="/">TP</a></span>

  <article class='article''>
    <h1>Parallel Programming in F# (II.): Using PLINQ and Tasks</h1>
<p>In this part of the Parallel Programming in F# series, we'll look at some basic examples of parallel 
  programming in F# that are available in <a href="http://parallelpatterns.codeplex.com/" type="external">Parallel 
  Programming with Microsoft .NET</a>. This is a guide that introduces common parallel programming patterns
  on .NET 4.0. The guide discusses the samples in C#, but it also contains an F# translation of the source
  code. Since the languages are different, the F# version deserves a brief explanation.</p>
  
<p>In this article, we'll discuss some of the F# examples and we'll look at a couple of aspects that
  are specific for F#. In particular, we'll look at working with Parallel LINQ (both directly and using
  <code>PSeq</code> module from F# PowerPack) and working with tasks. We'll also look at an interesting 
  example (using closures) where C# version doesn't behave as expected, but a literal translation in F# corrects the 
  problem.</p>

<p>For discussion about other F# examples from Parallel Programming with Microsoft .NET, 
  you can refer to other parts of this article series. So far, the series covers the following topics:</p>

<ul>
  <li><a href="http://tomasp.net/blog/fsharp-parallel-samples.aspx">Parallel Programming in F# (I.): Introducing the samples</a></li>
  <li><strong>Parallel Programming in F# (II.): Using PLINQ and Tasks</strong></li>
  <li><a href="http://tomasp.net/blog/fsharp-parallel-aggregate.aspx">Parallel Programming in F# (III.): Aggregating data</a></li>
  <li><a href="http://tomasp.net/blog/fsharp-parallel-adash.aspx">Parallel Programming in F# (IV.): Financial dashboard example</a></li>
</ul>

<h2>Working with Parallel LINQ</h2>

<p>We start by looking at examples from Chapter 2, which discusses parallel loops. This is a
  simple pattern for parallelization. It is useful when we have a loop (such as <code>for</code>) where
  the individual iterations of the loop are independent. This means that, for example, a result of the <em>n-th</em>
  iteration does not use the result of <em>(n-1)-th</em> iteration. In this case, we can run multiple
  iterations in parallel, because the order doesn't matter and they will not affect each other. When using
  .NET 4.0, there are several ways to implement this pattern. The following examples (from the
  "ParallelForExamples.fs" file in the "BasicParallelLoops" project) demonstrate some of the implementations.</p>

<h3>Imperative approach</h3>
<p>The first option is useful when the body of the loop performs some imperative action such as 
  mutating an element in an array (each iteration needs to mutate <em>different</em> element, so that
  they are independent). In this case, we can use <code>Parallel.For</code> or <code>Parallel.ForEach</code> 
  depending on which loop we're parallelizing. The following example takes an array of inputs named
  <code>source</code>, performs some work for each input element and stores the results in a new array:</p>

<pre>
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'tipplinq1', 1)" onmouseover="showTip(event, 'tipplinq1', 1)" class="i">result</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'tipplinq2', 2)" onmouseover="showTip(event, 'tipplinq2', 2)" class="i">Array</span><span class="o">.</span><span onmouseout="hideTip(event, 'tipplinq3', 3)" onmouseover="showTip(event, 'tipplinq3', 3)" class="i">zeroCreate</span> <span onmouseout="hideTip(event, 'tipplinq4', 4)" onmouseover="showTip(event, 'tipplinq4', 4)" class="i">source</span><span class="o">.</span><span onmouseout="hideTip(event, 'tipplinq5', 5)" onmouseover="showTip(event, 'tipplinq5', 5)" class="i">Length</span>
<span class="l">2: </span><span onmouseout="hideTip(event, 'tipplinq6', 6)" onmouseover="showTip(event, 'tipplinq6', 6)" class="i">Parallel</span><span class="o">.</span><span onmouseout="hideTip(event, 'tipplinq7', 7)" onmouseover="showTip(event, 'tipplinq7', 7)" class="i">ForEach</span>(<span onmouseout="hideTip(event, 'tipplinq4', 8)" onmouseover="showTip(event, 'tipplinq4', 8)" class="i">source</span>, <span class="k">fun</span> <span onmouseout="hideTip(event, 'tipplinq8', 9)" onmouseover="showTip(event, 'tipplinq8', 9)" class="i">i</span> <span class="k">-&gt;</span> 
<span class="l">3: </span>    <span onmouseout="hideTip(event, 'tipplinq1', 10)" onmouseover="showTip(event, 'tipplinq1', 10)" class="i">result</span><span class="o">.</span>[<span onmouseout="hideTip(event, 'tipplinq8', 11)" onmouseover="showTip(event, 'tipplinq8', 11)" class="i">i</span>] <span class="o">&lt;-</span> <span onmouseout="hideTip(event, 'tipplinq9', 12)" onmouseover="showTip(event, 'tipplinq9', 12)" class="i">doWork</span> <span onmouseout="hideTip(event, 'tipplinq10', 13)" onmouseover="showTip(event, 'tipplinq10', 13)" class="i">opts</span> <span onmouseout="hideTip(event, 'tipplinq8', 14)" onmouseover="showTip(event, 'tipplinq8', 14)" class="i">i</span> ) <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'tipplinq11', 15)" onmouseover="showTip(event, 'tipplinq11', 15)" class="i">ignore</span>
<span class="l">4: </span><span onmouseout="hideTip(event, 'tipplinq1', 16)" onmouseover="showTip(event, 'tipplinq1', 16)" class="i">result</span>
</pre>


<p>The usage looks very similar to C# thanks to the fact that F# automatically converts function
  values to delegates (meaning that we don't have to write <code>new Func&lt;_&gt;(...)</code>. The
  only notable difference is that the <code>ForEach</code> method returns some result (which can be used
  to implement and detect <code>break</code>), so we need to explicitly drop the result using
  the <code>ignore</code> function.</p>

<h3>Declarative approach</h3>
<p>Another option for implementing parallel loop is to use Parallel LINQ. It provides parallel versions
  of most of the LINQ query operators (such as <code>Select</code>, <code>Where</code> or even <code>GroupBy</code>).
  However, to implement parallel loop, we need just the <code>Select</code> operator.</p>
<p>Parallel LINQ has been designed to nicely work with the C# 3.0 query syntax. It exposes operators as
  extension methods (so we need to open the <code>System.Linq</code> namespace in order to see them). 
  When using Parallel LINQ from F#, we can either use the methods directly or we can use F# wrappers
  from the <code>PSeq</code> module. The following example shows the former option:</p>

<pre>
<span class="l">1: </span><span onmouseout="hideTip(event, 'tipplinq4', 17)" onmouseover="showTip(event, 'tipplinq4', 17)" class="i">source</span><span class="o">.</span><span onmouseout="hideTip(event, 'tipplinq12', 18)" onmouseover="showTip(event, 'tipplinq12', 18)" class="i">AsParallel</span>()
<span class="l">2: </span>      <span class="o">.</span><span class="i">AsOrdered</span>()
<span class="l">3: </span>      <span class="o">.</span><span class="i">Select</span>(<span onmouseout="hideTip(event, 'tipplinq9', 19)" onmouseover="showTip(event, 'tipplinq9', 19)" class="i">doWork</span> <span onmouseout="hideTip(event, 'tipplinq10', 20)" onmouseover="showTip(event, 'tipplinq10', 20)" class="i">opts</span>)
<span class="l">4: </span>      <span class="o">.</span><span class="i">ToArray</span>()
</pre>

<p>The example runs <code>AsParallel</code> immediately followed by <code>AsOrdered</code>. This configures
  the Parallel LINQ engine to preserve ordering when processing the data, so the <em>n-th</em> position in the
  returned array will correspond to the <em>n-th</em> position in the input array. Without this option, the
  query can (sometimes) run more efficiently, but the order may change. Next, we run the <code>Select</code>
  method and we use partial function application to supply its parameter. Finally, we call <code>ToArray</code>
  to force evaluation of the query.</p>

<p>The second way to write the example is to use the <code>PSeq</code> module which is distributed together
  with the samples ("PSeq.fs" file) and is also available in <a href="http://fsharppowerpack.codeplex.com/">F# PowerPack</a>
  (the local version contains a few changes that will eventually appear in PowerPack too). Using this module,
  we can write the processing in a more idiomatic functional style. As the following example shows, it looks
  just like list processing using functions such as <code>List.map</code> (the <code>PSeq</code> module uses
  standard F# names of functions where possible):  </p>

<pre>
<span class="l">1: </span><span onmouseout="hideTip(event, 'tipplinq4', 21)" onmouseover="showTip(event, 'tipplinq4', 21)" class="i">source</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'tipplinq13', 22)" onmouseover="showTip(event, 'tipplinq13', 22)" class="i">PSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'tipplinq14', 23)" onmouseover="showTip(event, 'tipplinq14', 23)" class="i">ordered</span>
<span class="l">2: </span>       <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'tipplinq13', 24)" onmouseover="showTip(event, 'tipplinq13', 24)" class="i">PSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'tipplinq15', 25)" onmouseover="showTip(event, 'tipplinq15', 25)" class="i">map</span> (<span onmouseout="hideTip(event, 'tipplinq9', 26)" onmouseover="showTip(event, 'tipplinq9', 26)" class="i">doWork</span> <span onmouseout="hideTip(event, 'tipplinq10', 27)" onmouseover="showTip(event, 'tipplinq10', 27)" class="i">opts</span>)
<span class="l">3: </span>       <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'tipplinq13', 28)" onmouseover="showTip(event, 'tipplinq13', 28)" class="i">PSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'tipplinq16', 29)" onmouseover="showTip(event, 'tipplinq16', 29)" class="i">toArray</span>
</pre>



<p>The example uses exactly the same steps as the previous version with the exception that we don't need to 
  call <code>AsParallel</code> explicitly. It is called automatically when we use the first function from the
  <code>PSeq</code> module. Syntactically, the snippet uses standard F# style and is written using the 
  pipelining operator. You'll find several other examples of parallel loops in the F# version of the sample
  source code. However, all examples of using Parallel LINQ are similar to those that we've just seen, so
  we can take a look at another topic...</p>

<h2>Working with tasks</h2>
<img src="http://tomasp.net/articles/fsharp-parallel-intro/koala.png" style="margin:5px 0px 10px 20px;float:right;" />
<p>The second way of writing parallel programs in .NET is to use the <code>Task</code> type. A task represents
  a (small) unit of work that can either return some result (in that case, we'll use <code>Task&lt;'T&gt;</code>)
  or it can perform some imperative action (non-generic type <code>Task</code>). In this section, we'll look at 
  a couple of basic examples of working with tasks, mainly from Chapter 3. A more complicated example that 
  is also created using tasks can be found in part IV. We'll also see how immutability in F# makes working 
  with tasks easier. However, let's start by a basic example that demonstrates the <code>Task&lt;'T&gt;</code>
  type. You can find it in "Processing.fs" file in the "ImageBlender" project. It takes two input images
  (<code>source1</code> and <code>source2</code>), turns one of them to gray-scale, rotates the other one
  and then blends the images (as the screenshot demonstrates):</p>

<pre>
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'tiptask1', 1)" onmouseover="showTip(event, 'tiptask1', 1)" class="i">toGray</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'tiptask2', 2)" onmouseover="showTip(event, 'tiptask2', 2)" class="i">Task</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask3', 3)" onmouseover="showTip(event, 'tiptask3', 3)" class="i">Factory</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask4', 4)" onmouseover="showTip(event, 'tiptask4', 4)" class="i">StartNew</span>(<span class="k">fun</span> () <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'tiptask5', 5)" onmouseover="showTip(event, 'tiptask5', 5)" class="i">setToGray</span> <span onmouseout="hideTip(event, 'tiptask6', 6)" onmouseover="showTip(event, 'tiptask6', 6)" class="i">source1</span> <span onmouseout="hideTip(event, 'tiptask7', 7)" onmouseover="showTip(event, 'tiptask7', 7)" class="i">layer1</span>)
<span class="l">2: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'tiptask8', 8)" onmouseover="showTip(event, 'tiptask8', 8)" class="i">rotate</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'tiptask2', 9)" onmouseover="showTip(event, 'tiptask2', 9)" class="i">Task</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask3', 10)" onmouseover="showTip(event, 'tiptask3', 10)" class="i">Factory</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask4', 11)" onmouseover="showTip(event, 'tiptask4', 11)" class="i">StartNew</span>(<span class="k">fun</span> () <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'tiptask9', 12)" onmouseover="showTip(event, 'tiptask9', 12)" class="i">rotate</span> <span onmouseout="hideTip(event, 'tiptask10', 13)" onmouseover="showTip(event, 'tiptask10', 13)" class="i">source2</span> <span onmouseout="hideTip(event, 'tiptask11', 14)" onmouseover="showTip(event, 'tiptask11', 14)" class="i">layer2</span>)
<span class="l">3: </span><span onmouseout="hideTip(event, 'tiptask2', 15)" onmouseover="showTip(event, 'tiptask2', 15)" class="i">Task</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask12', 16)" onmouseover="showTip(event, 'tiptask12', 16)" class="i">WaitAll</span>(<span onmouseout="hideTip(event, 'tiptask1', 17)" onmouseover="showTip(event, 'tiptask1', 17)" class="i">toGray</span>, <span onmouseout="hideTip(event, 'tiptask8', 18)" onmouseover="showTip(event, 'tiptask8', 18)" class="i">rotate</span>)
<span class="l">4: </span><span onmouseout="hideTip(event, 'tiptask13', 19)" onmouseover="showTip(event, 'tiptask13', 19)" class="i">blend</span> <span onmouseout="hideTip(event, 'tiptask7', 20)" onmouseover="showTip(event, 'tiptask7', 20)" class="i">layer1</span> <span onmouseout="hideTip(event, 'tiptask11', 21)" onmouseover="showTip(event, 'tiptask11', 21)" class="i">layer2</span> <span onmouseout="hideTip(event, 'tiptask14', 22)" onmouseover="showTip(event, 'tiptask14', 22)" class="i">blender</span>
</pre>

<p>When working with tasks from F#, the best option is to use the <code>Task</code> type directly
  (it is also possible to write a computation builder for this, but that's a topic for another blog
  post). To create a new task, we use the <code>Task.Factory</code> property, which gives us a factory
  object that can be used for creating and scheduling tasks.</p>
<p>The <code>StartNew</code> method has several overloads. We're using an overload that takes 
  a function that does not return a result (actually, the <code>Action</code> delegate). The functions
  we run draw the resulting image to <code>layer1</code> and <code>layer2</code> respectively. 
  Once we start our tasks, we need to wait until both of them complete, which can be done using
  the <code>Task.WaitAll</code> method. Once the method completes, we can continue and blend the two
  generated images.</p>
<p>The Task Parallel Library (TPL) from .NET 4.0 provides many other methods for composing and working
  with tasks. We can wait for any of several tasks, specify a task that should be run when another task
  completes, create child tasks and so on. However, the F# code is relatively simple (and very similar to
  C#), so you can find examples of these techniques in the F# source for <a href="http://parallelpatterns.codeplex.com/" type="external">Parallel Programming with Microsoft .NET</a>. 
  Instead, I'll write about one case where F# behaves differently than C#...</p>

<h3>Tasks and closures in C# and F#</h3>

<p>When using tasks together with the <code>for</code> loop in C#, we can easily get into a situation 
  that often causes confusion. he following example shows a snippet that creates an array of tasks
  and initializes the tasks in a loop. When creating the task, the loop variable <code>i</code> is
  used in the lambda function passed to the <code>StartNew</code> method. The variable is <em>captured
  in a closure</em>, which means that the lambda function keeps reference to it:</p>

<pre lang="csharp">
Task[] tasks = new Task[4];
for (int i = 0; i &lt; 4; i++) {
    tasks[i] = Task.Factory.StartNew(() =&gt; 
        Console.WriteLine(i));
}
Task.WaitAll(tasks);
</pre>
<p>At the first sight, it would appear that the code should print <code>1,2,3,4</code>, but that's not 
  the case! The problem is that the lambda function (body of the task) does not keep the <em>current value</em>
  of the variable but a <em>reference to the variable</em> (allocated on a heap). The behavior of the 
  program is non-deterministic, because we don't know when the tasks will be scheduled. In practice, the
  tasks typically run after the <code>for</code> loop completes, so it will print <code>4,4,4,4</code>.</p>

<p>The problem is that <code>i</code> is a single variable that is mutated as the loop iterates. In order
  to fix the program in C#, we would need to declare a new variable (e.g. <code>var temp = i</code>) inside the
  body of the loop. This would declare a new variable each time the body is executed and so it will allocate
  new heap location (to store the value) for each iteration. Let's now look at the same example translated 
  to F#:</p>
<pre>
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'tiptask15', 23)" onmouseover="showTip(event, 'tiptask15', 23)" class="i">tasks</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'tiptask16', 24)" onmouseover="showTip(event, 'tiptask16', 24)" class="i">Array</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask17', 25)" onmouseover="showTip(event, 'tiptask17', 25)" class="i">zeroCreate</span> <span class="n">4</span>
<span class="l">2: </span><span class="k">for</span> <span onmouseout="hideTip(event, 'tiptask18', 26)" onmouseover="showTip(event, 'tiptask18', 26)" class="i">i</span> <span class="k">in</span> <span class="n">0</span> <span class="o">..</span> <span class="n">3</span> <span class="k">do</span>
<span class="l">3: </span>    <span onmouseout="hideTip(event, 'tiptask15', 27)" onmouseover="showTip(event, 'tiptask15', 27)" class="i">tasks</span><span class="o">.</span>[<span onmouseout="hideTip(event, 'tiptask18', 28)" onmouseover="showTip(event, 'tiptask18', 28)" class="i">i</span>] <span class="o">&lt;-</span> <span onmouseout="hideTip(event, 'tiptask2', 29)" onmouseover="showTip(event, 'tiptask2', 29)" class="i">Task</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask3', 30)" onmouseover="showTip(event, 'tiptask3', 30)" class="i">Factory</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask4', 31)" onmouseover="showTip(event, 'tiptask4', 31)" class="i">StartNew</span>(<span class="k">fun</span> () <span class="k">-&gt;</span> 
<span class="l">4: </span>        <span onmouseout="hideTip(event, 'tiptask19', 32)" onmouseover="showTip(event, 'tiptask19', 32)" class="i">Console</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask20', 33)" onmouseover="showTip(event, 'tiptask20', 33)" class="i">WriteLine</span>(<span onmouseout="hideTip(event, 'tiptask18', 34)" onmouseover="showTip(event, 'tiptask18', 34)" class="i">i</span>))
<span class="l">5: </span><span onmouseout="hideTip(event, 'tiptask2', 35)" onmouseover="showTip(event, 'tiptask2', 35)" class="i">Task</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask12', 36)" onmouseover="showTip(event, 'tiptask12', 36)" class="i">WaitAll</span>(<span onmouseout="hideTip(event, 'tiptask15', 37)" onmouseover="showTip(event, 'tiptask15', 37)" class="i">tasks</span>)
</pre>
<p>If you run this version of code, it will always print <code>1,2,3,4</code> as expected. How is that possible?
  The reason is that F# interprets the <code>for</code> loop construct differently. Instead of declaring a mutable
  variable and changing it during the iteration, it creates a new immutable value for every iteration. 
  This is a logical approach in F#, because mutable state is generally discouraged. As a result, the 
  lambda function captures a reference to a value that will not be later changed.</p>

<p>This subtle difference between the two interpretations of the <code>for</code> loop can save you quite
  a headache when working with tasks. In fact, immutability can save you lot of troubles in general, because
  you can easily see which operations can be safely parallelized and which can not (this is also discussed in 
  chapters 11 and 14 of my <a href="http://manning.com/petricek">Real-World Functional Programming</a>).
  The next snippet shows an F# example that behaves exactly as the original C# snippet, which means that
  it prints <code>4,4,4,4</code>. As you can see we have to use reference cells. This makes the 
  problem obvious:</p>

<pre>
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'tiptask21', 38)" onmouseover="showTip(event, 'tiptask21', 38)" class="i">tasks</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'tiptask16', 39)" onmouseover="showTip(event, 'tiptask16', 39)" class="i">Array</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask17', 40)" onmouseover="showTip(event, 'tiptask17', 40)" class="i">zeroCreate</span> <span class="n">4</span>
<span class="l">2: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'tiptask22', 41)" onmouseover="showTip(event, 'tiptask22', 41)" class="i">i</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'tiptask23', 42)" onmouseover="showTip(event, 'tiptask23', 42)" class="i">ref</span> <span class="n">0</span> 
<span class="l">3: </span><span class="k">while</span> <span class="o">!</span><span onmouseout="hideTip(event, 'tiptask22', 43)" onmouseover="showTip(event, 'tiptask22', 43)" class="i">i</span> <span class="o">&lt;</span> <span class="n">4</span> <span class="k">do</span>
<span class="l">4: </span>    <span onmouseout="hideTip(event, 'tiptask21', 44)" onmouseover="showTip(event, 'tiptask21', 44)" class="i">tasks</span><span class="o">.</span>[<span class="o">!</span><span onmouseout="hideTip(event, 'tiptask22', 45)" onmouseover="showTip(event, 'tiptask22', 45)" class="i">i</span>] <span class="o">&lt;-</span> <span onmouseout="hideTip(event, 'tiptask2', 46)" onmouseover="showTip(event, 'tiptask2', 46)" class="i">Task</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask3', 47)" onmouseover="showTip(event, 'tiptask3', 47)" class="i">Factory</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask4', 48)" onmouseover="showTip(event, 'tiptask4', 48)" class="i">StartNew</span>(<span class="k">fun</span> () <span class="k">-&gt;</span> 
<span class="l">5: </span>        <span onmouseout="hideTip(event, 'tiptask19', 49)" onmouseover="showTip(event, 'tiptask19', 49)" class="i">Console</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask20', 50)" onmouseover="showTip(event, 'tiptask20', 50)" class="i">WriteLine</span>(<span class="o">!</span><span onmouseout="hideTip(event, 'tiptask22', 51)" onmouseover="showTip(event, 'tiptask22', 51)" class="i">i</span>))
<span class="l">6: </span>    <span onmouseout="hideTip(event, 'tiptask22', 52)" onmouseover="showTip(event, 'tiptask22', 52)" class="i">i</span> <span class="o">:=</span> <span class="o">!</span><span onmouseout="hideTip(event, 'tiptask22', 53)" onmouseover="showTip(event, 'tiptask22', 53)" class="i">i</span> <span class="o">+</span> <span class="n">1</span>
<span class="l">7: </span><span onmouseout="hideTip(event, 'tiptask2', 54)" onmouseover="showTip(event, 'tiptask2', 54)" class="i">Task</span><span class="o">.</span><span onmouseout="hideTip(event, 'tiptask12', 55)" onmouseover="showTip(event, 'tiptask12', 55)" class="i">WaitAll</span>(<span onmouseout="hideTip(event, 'tiptask21', 56)" onmouseover="showTip(event, 'tiptask21', 56)" class="i">tasks</span>)
</pre>


<p>If we want to capture mutable value in a closure in F#, we have to use reference cells (mutable values
  declared using <code>let mutable</code> cannot be captured). This makes the situation clearer, because
  reference cell is a heap allocated object that contains some mutable contents. In our example,
  we create a reference cell <code>i</code> that is modified as we iterate over the loop. The 
  lambda function uses <code>i</code>, so the closure will keep a reference to the mutable
  heap allocated reference cell. When the task runs (after the <code>while</code> loop finishes), 
  the reference cell will contain value 4.</p>

<h2>Summary</h2>
<p>In this article, we looked at several simpler examples from <a href="http://parallelpatterns.codeplex.com/" type="external">Parallel 
  Programming with Microsoft .NET</a> (mainly from chapters 2 and 3). We looked at several
  ways of implementing the "parallel loop" pattern in F#. One option is to use 
  <code>Parallel.For</code> and <code>Parallel.ForEach</code> methods, which can be easily 
  called directly from F#. Another option is to use (more declarative) Parallel LINQ library.
  The library can be either used directly (by calling extension methods) or using the
  <code>PSeq</code> module (available in F# PowerPack), which makes the API more F#-friendly.</p>
<p>Next, we looked at the key component from Task Parallel Library (TPL), which is a type
  <code>Task</code> that represents a unit of work. Tasks can be also easily created from F#
  using the <code>Task.Factory.StartNew</code> call (you'll find many other task-related operations
  in the book). As the last thing in this article, we also looked how immutability makes things
  easier. In particular, when creating task inside a <code>for</code> loop, we can easily 
  make a mistake in C#, because the loop index variable is mutable. F# avoids this problem by
  treating the variable as a immutable value (newly created for every iteration).</p>

<h2>Downloads and References</h2>
<ul>
  <li><a href="http://parallelpatterns.codeplex.com" type="external">Parallel Programming with Microsoft .NET</a> - Book homepage at CodePlex </li>
  <li><a href="http://parallelpatterns.codeplex.com/releases/view/50473" type="external">F# Code Samples</a> - Parallel Programming with Microsoft .NET </li>
</ul>



<div class="tip" id="tipplinq1">val result : float []<br /><br />&#160;&#160;type: float []<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: Collections.IList<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: Collections.Generic.IList&lt;float&gt;<br />&#160;&#160;implements: Collections.Generic.ICollection&lt;float&gt;<br />&#160;&#160;implements: seq&lt;float&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;inherits: Array<br /></div>
<div class="tip" id="tipplinq2">type Array =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;member Clone : unit -&gt; obj<br />&#160;&#160;&#160;&#160;member CopyTo : System.Array * int -&gt; unit<br />&#160;&#160;&#160;&#160;member CopyTo : System.Array * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;member GetEnumerator : unit -&gt; System.Collections.IEnumerator<br />&#160;&#160;&#160;&#160;member GetLength : int -&gt; int<br />&#160;&#160;&#160;&#160;member GetLongLength : int -&gt; int64<br />&#160;&#160;&#160;&#160;member GetLowerBound : int -&gt; int<br />&#160;&#160;&#160;&#160;member GetUpperBound : int -&gt; int<br />&#160;&#160;&#160;&#160;member GetValue : int [] -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int64 -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int64 [] -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int * int -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int64 * int64 -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int * int * int -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int64 * int64 * int64 -&gt; obj<br />&#160;&#160;&#160;&#160;member Initialize : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member IsFixedSize : bool<br />&#160;&#160;&#160;&#160;member IsReadOnly : bool<br />&#160;&#160;&#160;&#160;member IsSynchronized : bool<br />&#160;&#160;&#160;&#160;member Length : int<br />&#160;&#160;&#160;&#160;member LongLength : int64<br />&#160;&#160;&#160;&#160;member Rank : int<br />&#160;&#160;&#160;&#160;member SetValue : obj * int -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int [] -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int64 [] -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int64 * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int64 * int64 * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;member SyncRoot : obj<br />&#160;&#160;&#160;&#160;static member AsReadOnly&lt;'T&gt; : 'T [] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;<br />&#160;&#160;&#160;&#160;static member BinarySearch : System.Array * obj -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch&lt;'T&gt; : 'T [] * 'T -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch : System.Array * obj * System.Collections.IComparer -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch&lt;'T&gt; : 'T [] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch : System.Array * int * int * obj -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch&lt;'T&gt; : 'T [] * int * int * 'T -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch : System.Array * int * int * obj * System.Collections.IComparer -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch&lt;'T&gt; : 'T [] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member Clear : System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member ConstrainedCopy : System.Array * int * System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member ConvertAll&lt;'TInput,'TOutput&gt; : 'TInput [] * System.Converter&lt;'TInput,'TOutput&gt; -&gt; 'TOutput []<br />&#160;&#160;&#160;&#160;static member Copy : System.Array * System.Array * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Copy : System.Array * System.Array * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;static member Copy : System.Array * int * System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Copy : System.Array * int64 * System.Array * int64 * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int [] -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int64 [] -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int * int -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int [] * int [] -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int * int * int -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member Exists&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; bool<br />&#160;&#160;&#160;&#160;static member Find&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; 'T<br />&#160;&#160;&#160;&#160;static member FindAll&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; 'T []<br />&#160;&#160;&#160;&#160;static member FindIndex&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member FindIndex&lt;'T&gt; : 'T [] * int * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member FindIndex&lt;'T&gt; : 'T [] * int * int * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member FindLast&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; 'T<br />&#160;&#160;&#160;&#160;static member FindLastIndex&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member FindLastIndex&lt;'T&gt; : 'T [] * int * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member FindLastIndex&lt;'T&gt; : 'T [] * int * int * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'T&gt; : 'T [] * System.Action&lt;'T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member IndexOf : System.Array * obj -&gt; int<br />&#160;&#160;&#160;&#160;static member IndexOf&lt;'T&gt; : 'T [] * 'T -&gt; int<br />&#160;&#160;&#160;&#160;static member IndexOf : System.Array * obj * int -&gt; int<br />&#160;&#160;&#160;&#160;static member IndexOf&lt;'T&gt; : 'T [] * 'T * int -&gt; int<br />&#160;&#160;&#160;&#160;static member IndexOf : System.Array * obj * int * int -&gt; int<br />&#160;&#160;&#160;&#160;static member IndexOf&lt;'T&gt; : 'T [] * 'T * int * int -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf : System.Array * obj -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf&lt;'T&gt; : 'T [] * 'T -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf : System.Array * obj * int -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf&lt;'T&gt; : 'T [] * 'T * int -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf : System.Array * obj * int * int -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf&lt;'T&gt; : 'T [] * 'T * int * int -&gt; int<br />&#160;&#160;&#160;&#160;static member Resize&lt;'T&gt; : 'T [] * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Reverse : System.Array -&gt; unit<br />&#160;&#160;&#160;&#160;static member Reverse : System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'T&gt; : 'T [] -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * System.Array -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * System.Collections.IComparer -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'TKey,'TValue&gt; : 'TKey [] * 'TValue [] -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'T&gt; : 'T [] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'T&gt; : 'T [] * System.Comparison&lt;'T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * System.Array * System.Collections.IComparer -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'T&gt; : 'T [] * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'TKey,'TValue&gt; : 'TKey [] * 'TValue [] * System.Collections.Generic.IComparer&lt;'TKey&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * int * int * System.Collections.IComparer -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'TKey,'TValue&gt; : 'TKey [] * 'TValue [] * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'T&gt; : 'T [] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * System.Array * int * int * System.Collections.IComparer -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'TKey,'TValue&gt; : 'TKey [] * 'TValue [] * int * int * System.Collections.Generic.IComparer&lt;'TKey&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member TrueForAll&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; bool<br />&#160;&#160;end<br /><br />Full name: System.Array<br /><br />&#160;&#160;type: Array<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: Collections.IList<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.IStructuralEquatable<br /></div>
<div class="tip" id="tipplinq3">val zeroCreate : int -&gt; 'T []<br /><br />Full name: Microsoft.FSharp.Collections.Array.zeroCreate<br /></div>
<div class="tip" id="tipplinq4">val source : int []<br /><br />&#160;&#160;type: int []<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: Collections.IList<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: Collections.Generic.IList&lt;int&gt;<br />&#160;&#160;implements: Collections.Generic.ICollection&lt;int&gt;<br />&#160;&#160;implements: seq&lt;int&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;inherits: Array<br /></div>
<div class="tip" id="tipplinq5">property Array.Length: int<br /></div>
<div class="tip" id="tipplinq6">type Parallel =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;static member For : int * int * System.Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member For : int64 * int64 * System.Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member For : int * int * System.Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member For : int64 * int64 * System.Action&lt;int64,System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member For : int * int * System.Threading.Tasks.ParallelOptions * System.Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * System.Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member For : int * int * System.Threading.Tasks.ParallelOptions * System.Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * System.Action&lt;int64,System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member For&lt;'TLocal&gt; : int * int * System.Func&lt;'TLocal&gt; * System.Func&lt;int,System.Threading.Tasks.ParallelLoopState,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member For&lt;'TLocal&gt; : int64 * int64 * System.Func&lt;'TLocal&gt; * System.Func&lt;int64,System.Threading.Tasks.ParallelLoopState,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member For&lt;'TLocal&gt; : int * int * System.Threading.Tasks.ParallelOptions * System.Func&lt;'TLocal&gt; * System.Func&lt;int,System.Threading.Tasks.ParallelLoopState,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member For&lt;'TLocal&gt; : int64 * int64 * System.Threading.Tasks.ParallelOptions * System.Func&lt;'TLocal&gt; * System.Func&lt;int64,System.Threading.Tasks.ParallelLoopState,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Generic.IEnumerable&lt;'TSource&gt; * System.Action&lt;'TSource&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Generic.IEnumerable&lt;'TSource&gt; * System.Action&lt;'TSource,System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Generic.IEnumerable&lt;'TSource&gt; * System.Action&lt;'TSource,System.Threading.Tasks.ParallelLoopState,int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Concurrent.Partitioner&lt;'TSource&gt; * System.Action&lt;'TSource&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Concurrent.Partitioner&lt;'TSource&gt; * System.Action&lt;'TSource,System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Concurrent.OrderablePartitioner&lt;'TSource&gt; * System.Action&lt;'TSource,System.Threading.Tasks.ParallelLoopState,int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Generic.IEnumerable&lt;'TSource&gt; * System.Threading.Tasks.ParallelOptions * System.Action&lt;'TSource&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Generic.IEnumerable&lt;'TSource&gt; * System.Threading.Tasks.ParallelOptions * System.Action&lt;'TSource,System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Generic.IEnumerable&lt;'TSource&gt; * System.Threading.Tasks.ParallelOptions * System.Action&lt;'TSource,System.Threading.Tasks.ParallelLoopState,int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Concurrent.Partitioner&lt;'TSource&gt; * System.Threading.Tasks.ParallelOptions * System.Action&lt;'TSource&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Concurrent.Partitioner&lt;'TSource&gt; * System.Threading.Tasks.ParallelOptions * System.Action&lt;'TSource,System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource&gt; : System.Collections.Concurrent.OrderablePartitioner&lt;'TSource&gt; * System.Threading.Tasks.ParallelOptions * System.Action&lt;'TSource,System.Threading.Tasks.ParallelLoopState,int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource,'TLocal&gt; : System.Collections.Generic.IEnumerable&lt;'TSource&gt; * System.Func&lt;'TLocal&gt; * System.Func&lt;'TSource,System.Threading.Tasks.ParallelLoopState,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource,'TLocal&gt; : System.Collections.Generic.IEnumerable&lt;'TSource&gt; * System.Func&lt;'TLocal&gt; * System.Func&lt;'TSource,System.Threading.Tasks.ParallelLoopState,int64,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource,'TLocal&gt; : System.Collections.Concurrent.Partitioner&lt;'TSource&gt; * System.Func&lt;'TLocal&gt; * System.Func&lt;'TSource,System.Threading.Tasks.ParallelLoopState,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource,'TLocal&gt; : System.Collections.Concurrent.OrderablePartitioner&lt;'TSource&gt; * System.Func&lt;'TLocal&gt; * System.Func&lt;'TSource,System.Threading.Tasks.ParallelLoopState,int64,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource,'TLocal&gt; : System.Collections.Generic.IEnumerable&lt;'TSource&gt; * System.Threading.Tasks.ParallelOptions * System.Func&lt;'TLocal&gt; * System.Func&lt;'TSource,System.Threading.Tasks.ParallelLoopState,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource,'TLocal&gt; : System.Collections.Generic.IEnumerable&lt;'TSource&gt; * System.Threading.Tasks.ParallelOptions * System.Func&lt;'TLocal&gt; * System.Func&lt;'TSource,System.Threading.Tasks.ParallelLoopState,int64,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource,'TLocal&gt; : System.Collections.Concurrent.Partitioner&lt;'TSource&gt; * System.Threading.Tasks.ParallelOptions * System.Func&lt;'TLocal&gt; * System.Func&lt;'TSource,System.Threading.Tasks.ParallelLoopState,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'TSource,'TLocal&gt; : System.Collections.Concurrent.OrderablePartitioner&lt;'TSource&gt; * System.Threading.Tasks.ParallelOptions * System.Func&lt;'TLocal&gt; * System.Func&lt;'TSource,System.Threading.Tasks.ParallelLoopState,int64,'TLocal,'TLocal&gt; * System.Action&lt;'TLocal&gt; -&gt; System.Threading.Tasks.ParallelLoopResult<br />&#160;&#160;&#160;&#160;static member Invoke : System.Action [] -&gt; unit<br />&#160;&#160;&#160;&#160;static member Invoke : System.Threading.Tasks.ParallelOptions * System.Action [] -&gt; unit<br />&#160;&#160;end<br /><br />Full name: System.Threading.Tasks.Parallel<br /></div>
<div class="tip" id="tipplinq7">Multiple overloads
<br />Parallel.ForEach&lt;'TSource&gt;(source: OrderablePartitioner&lt;'TSource&gt;, body: Action&lt;'TSource,ParallelLoopState,int64&gt;) : ParallelLoopResult
<br />Parallel.ForEach&lt;'TSource&gt;(source: Partitioner&lt;'TSource&gt;, body: Action&lt;'TSource,ParallelLoopState&gt;) : ParallelLoopResult
<br />Parallel.ForEach&lt;'TSource&gt;(source: Partitioner&lt;'TSource&gt;, body: Action&lt;'TSource&gt;) : ParallelLoopResult
<br />Parallel.ForEach&lt;'TSource&gt;(source: seq&lt;'TSource&gt;, body: Action&lt;'TSource,ParallelLoopState,int64&gt;) : ParallelLoopResult
<br />Parallel.ForEach&lt;'TSource&gt;(source: seq&lt;'TSource&gt;, body: Action&lt;'TSource,ParallelLoopState&gt;) : ParallelLoopResult
<br />Parallel.ForEach&lt;'TSource&gt;(source: seq&lt;'TSource&gt;, body: Action&lt;'TSource&gt;) : ParallelLoopResult
<br />Parallel.ForEach&lt;'TSource&gt;(source: OrderablePartitioner&lt;'TSource&gt;, parallelOptions: ParallelOptions, body: Action&lt;'TSource,ParallelLoopState,int64&gt;) : ParallelLoopResult
<br />Parallel.ForEach&lt;'TSource&gt;(source: Partitioner&lt;'TSource&gt;, parallelOptions: ParallelOptions, body: Action&lt;'TSource,ParallelLoopState&gt;) : ParallelLoopResult
<br />Parallel.ForEach&lt;'TSource&gt;(source: Partitioner&lt;'TSource&gt;, parallelOptions: ParallelOptions, body: Action&lt;'TSource&gt;) : ParallelLoopResult
<br />Parallel.ForEach&lt;'TSource&gt;(source: seq&lt;'TSource&gt;, parallelOptions: ParallelOptions, body: Action&lt;'TSource,ParallelLoopState,int64&gt;) : ParallelLoopResult
<br />&#160;&#160;&#160;<em>(+10 other overloads)</em><br /></div>
<div class="tip" id="tipplinq8">val i : int<br /><br />&#160;&#160;type: int<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: IFormattable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;int&gt;<br />&#160;&#160;implements: IEquatable&lt;int&gt;<br />&#160;&#160;inherits: ValueType<br /></div>
<div class="tip" id="tipplinq9">val private doWork : ExampleOptions -&gt; int -&gt; float<br /><br />Full name: ParallelForExample.doWork<br /></div>
<div class="tip" id="tipplinq10">val opts : ExampleOptions<br /><br />&#160;&#160;type: ExampleOptions<br />&#160;&#160;implements: IEquatable&lt;ExampleOptions&gt;<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: IComparable&lt;ExampleOptions&gt;<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: Collections.IStructuralComparable<br /></div>
<div class="tip" id="tipplinq11">val ignore : 'T -&gt; unit<br /><br />Full name: Microsoft.FSharp.Core.Operators.ignore<br /></div>
<div class="tip" id="tipplinq12">Multiple overloads
<br />Collections.IEnumerable.AsParallel() : ParallelQuery
<br />Collections.Generic.IEnumerable.AsParallel&lt;'TSource&gt;() : ParallelQuery&lt;'TSource&gt;<br /></div>
<div class="tip" id="tipplinq13">module PSeq<br /><br />from Microsoft.FSharp.Collections<br /></div>
<div class="tip" id="tipplinq14">val ordered : seq&lt;'a&gt; -&gt; ParallelQuery&lt;'a&gt;<br /><br />Full name: Microsoft.FSharp.Collections.PSeqModule.ordered<br /></div>
<div class="tip" id="tipplinq15">val map : ('a -&gt; 'b) -&gt; seq&lt;'a&gt; -&gt; ParallelQuery&lt;'b&gt;<br /><br />Full name: Microsoft.FSharp.Collections.PSeqModule.map<br /></div>
<div class="tip" id="tipplinq16">val toArray : seq&lt;'a&gt; -&gt; 'a []<br /><br />Full name: Microsoft.FSharp.Collections.PSeqModule.toArray<br /></div>



<div class="tip" id="tiptask1">val toGray : Task<br /><br />&#160;&#160;type: Task<br />&#160;&#160;implements: Threading.IThreadPoolWorkItem<br />&#160;&#160;implements: IAsyncResult<br />&#160;&#160;implements: IDisposable<br /></div>
<div class="tip" id="tiptask2">Multiple items
<br />type Task&lt;'TResult&gt; =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;inherit System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;new : System.Func&lt;'TResult&gt; -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;new : System.Func&lt;'TResult&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;new : System.Func&lt;'TResult&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;new : System.Func&lt;'TResult&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;new : System.Func&lt;obj,'TResult&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;new : System.Func&lt;obj,'TResult&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;new : System.Func&lt;obj,'TResult&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;new : System.Func&lt;obj,'TResult&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;member ContinueWith : System.Action&lt;System.Threading.Tasks.Task&lt;'TResult&gt;&gt; -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;member ContinueWith&lt;'TNewResult&gt; : System.Func&lt;System.Threading.Tasks.Task&lt;'TResult&gt;,'TNewResult&gt; -&gt; System.Threading.Tasks.Task&lt;'TNewResult&gt;<br />&#160;&#160;&#160;&#160;member ContinueWith : System.Action&lt;System.Threading.Tasks.Task&lt;'TResult&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;member ContinueWith : System.Action&lt;System.Threading.Tasks.Task&lt;'TResult&gt;&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;member ContinueWith : System.Action&lt;System.Threading.Tasks.Task&lt;'TResult&gt;&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;member ContinueWith&lt;'TNewResult&gt; : System.Func&lt;System.Threading.Tasks.Task&lt;'TResult&gt;,'TNewResult&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'TNewResult&gt;<br />&#160;&#160;&#160;&#160;member ContinueWith&lt;'TNewResult&gt; : System.Func&lt;System.Threading.Tasks.Task&lt;'TResult&gt;,'TNewResult&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'TNewResult&gt;<br />&#160;&#160;&#160;&#160;member ContinueWith&lt;'TNewResult&gt; : System.Func&lt;System.Threading.Tasks.Task&lt;'TResult&gt;,'TNewResult&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'TNewResult&gt;<br />&#160;&#160;&#160;&#160;member ContinueWith : System.Action&lt;System.Threading.Tasks.Task&lt;'TResult&gt;&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;member ContinueWith&lt;'TNewResult&gt; : System.Func&lt;System.Threading.Tasks.Task&lt;'TResult&gt;,'TNewResult&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'TNewResult&gt;<br />&#160;&#160;&#160;&#160;member Result : 'TResult with get, set<br />&#160;&#160;&#160;&#160;static member Factory : System.Threading.Tasks.TaskFactory&lt;'TResult&gt;<br />&#160;&#160;end<br /><br />Full name: System.Threading.Tasks.Task&lt;_&gt;<br /><br />&#160;&#160;type: Task&lt;'TResult&gt;<br />&#160;&#160;implements: Threading.IThreadPoolWorkItem<br />&#160;&#160;implements: IAsyncResult<br />&#160;&#160;implements: IDisposable<br />&#160;&#160;inherits: Task<br />
<br /><br />--------------------<br />
<br />type Task =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : System.Action -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;new : System.Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;new : System.Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;new : System.Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;new : System.Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;new : System.Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;new : System.Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;new : System.Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;member AsyncState : obj<br />&#160;&#160;&#160;&#160;member ContinueWith : System.Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;member ContinueWith&lt;'TResult&gt; : System.Func&lt;System.Threading.Tasks.Task,'TResult&gt; -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;member ContinueWith : System.Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;member ContinueWith : System.Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;member ContinueWith : System.Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;member ContinueWith&lt;'TResult&gt; : System.Func&lt;System.Threading.Tasks.Task,'TResult&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;member ContinueWith&lt;'TResult&gt; : System.Func&lt;System.Threading.Tasks.Task,'TResult&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;member ContinueWith&lt;'TResult&gt; : System.Func&lt;System.Threading.Tasks.Task,'TResult&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;member ContinueWith : System.Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task<br />&#160;&#160;&#160;&#160;member ContinueWith&lt;'TResult&gt; : System.Func&lt;System.Threading.Tasks.Task,'TResult&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'TResult&gt;<br />&#160;&#160;&#160;&#160;member CreationOptions : System.Threading.Tasks.TaskCreationOptions<br />&#160;&#160;&#160;&#160;member Dispose : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Exception : System.AggregateException<br />&#160;&#160;&#160;&#160;member Id : int<br />&#160;&#160;&#160;&#160;member IsCanceled : bool<br />&#160;&#160;&#160;&#160;member IsCompleted : bool<br />&#160;&#160;&#160;&#160;member IsFaulted : bool<br />&#160;&#160;&#160;&#160;member RunSynchronously : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit<br />&#160;&#160;&#160;&#160;member Start : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Start : System.Threading.Tasks.TaskScheduler -&gt; unit<br />&#160;&#160;&#160;&#160;member Status : System.Threading.Tasks.TaskStatus<br />&#160;&#160;&#160;&#160;member Wait : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Wait : System.TimeSpan -&gt; bool<br />&#160;&#160;&#160;&#160;member Wait : System.Threading.CancellationToken -&gt; unit<br />&#160;&#160;&#160;&#160;member Wait : int -&gt; bool<br />&#160;&#160;&#160;&#160;member Wait : int * System.Threading.CancellationToken -&gt; bool<br />&#160;&#160;&#160;&#160;static member CurrentId : System.Nullable&lt;int&gt;<br />&#160;&#160;&#160;&#160;static member Factory : System.Threading.Tasks.TaskFactory<br />&#160;&#160;&#160;&#160;static member WaitAll : System.Threading.Tasks.Task [] -&gt; unit<br />&#160;&#160;&#160;&#160;static member WaitAll : System.Threading.Tasks.Task [] * System.TimeSpan -&gt; bool<br />&#160;&#160;&#160;&#160;static member WaitAll : System.Threading.Tasks.Task [] * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member WaitAll : System.Threading.Tasks.Task [] * System.Threading.CancellationToken -&gt; unit<br />&#160;&#160;&#160;&#160;static member WaitAll : System.Threading.Tasks.Task [] * int * System.Threading.CancellationToken -&gt; bool<br />&#160;&#160;&#160;&#160;static member WaitAny : System.Threading.Tasks.Task [] -&gt; int<br />&#160;&#160;&#160;&#160;static member WaitAny : System.Threading.Tasks.Task [] * System.TimeSpan -&gt; int<br />&#160;&#160;&#160;&#160;static member WaitAny : System.Threading.Tasks.Task [] * System.Threading.CancellationToken -&gt; int<br />&#160;&#160;&#160;&#160;static member WaitAny : System.Threading.Tasks.Task [] * int -&gt; int<br />&#160;&#160;&#160;&#160;static member WaitAny : System.Threading.Tasks.Task [] * int * System.Threading.CancellationToken -&gt; int<br />&#160;&#160;end<br /><br />Full name: System.Threading.Tasks.Task<br /><br />&#160;&#160;type: Task<br />&#160;&#160;implements: Threading.IThreadPoolWorkItem<br />&#160;&#160;implements: IAsyncResult<br />&#160;&#160;implements: IDisposable<br /></div>
<div class="tip" id="tiptask3">Multiple items
<br />property Task.Factory: TaskFactory
<br /><br />--------------------<br />
<br />property Task.Factory: TaskFactory&lt;'TResult&gt;<br /></div>
<div class="tip" id="tiptask4">Multiple items
<br />TaskFactory.StartNew&lt;'TResult&gt;(function: Func&lt;'TResult&gt;) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew(action: Action) : Task
<br />TaskFactory.StartNew&lt;'TResult&gt;(function: Func&lt;obj,'TResult&gt;, state: obj) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew&lt;'TResult&gt;(function: Func&lt;'TResult&gt;, creationOptions: TaskCreationOptions) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew&lt;'TResult&gt;(function: Func&lt;'TResult&gt;, cancellationToken: Threading.CancellationToken) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew(action: Action&lt;obj&gt;, state: obj) : Task
<br />TaskFactory.StartNew(action: Action, creationOptions: TaskCreationOptions) : Task
<br />TaskFactory.StartNew(action: Action, cancellationToken: Threading.CancellationToken) : Task
<br />TaskFactory.StartNew&lt;'TResult&gt;(function: Func&lt;obj,'TResult&gt;, state: obj, creationOptions: TaskCreationOptions) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew&lt;'TResult&gt;(function: Func&lt;obj,'TResult&gt;, state: obj, cancellationToken: Threading.CancellationToken) : Task&lt;'TResult&gt;
<br />&#160;&#160;&#160;<em>(+6 other overloads)</em><br />--------------------<br />
<br />TaskFactory.StartNew(function: Func&lt;'TResult&gt;) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew(function: Func&lt;obj,'TResult&gt;, state: obj) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew(function: Func&lt;'TResult&gt;, creationOptions: TaskCreationOptions) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew(function: Func&lt;'TResult&gt;, cancellationToken: Threading.CancellationToken) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew(function: Func&lt;obj,'TResult&gt;, state: obj, creationOptions: TaskCreationOptions) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew(function: Func&lt;obj,'TResult&gt;, state: obj, cancellationToken: Threading.CancellationToken) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew(function: Func&lt;'TResult&gt;, cancellationToken: Threading.CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler) : Task&lt;'TResult&gt;
<br />TaskFactory.StartNew(function: Func&lt;obj,'TResult&gt;, state: obj, cancellationToken: Threading.CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler) : Task&lt;'TResult&gt;<br /></div>
<div class="tip" id="tiptask5">val private setToGray : Bitmap -&gt; Bitmap -&gt; unit<br /><br />Full name: Processing.setToGray
<br /><em><br /><br />&#160;Copy source bitmap to the layer and make the target <br />&#160;grayscale and partially transparent (sequentially)</em><br /></div>
<div class="tip" id="tiptask6">val source1 : Bitmap<br /><br />&#160;&#160;type: Bitmap<br />&#160;&#160;implements: Runtime.Serialization.ISerializable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IDisposable<br />&#160;&#160;inherits: Image<br />&#160;&#160;inherits: MarshalByRefObject<br /></div>
<div class="tip" id="tiptask7">val layer1 : Bitmap<br /><br />&#160;&#160;type: Bitmap<br />&#160;&#160;implements: Runtime.Serialization.ISerializable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IDisposable<br />&#160;&#160;inherits: Image<br />&#160;&#160;inherits: MarshalByRefObject<br /></div>
<div class="tip" id="tiptask8">val rotate : Task<br /><br />&#160;&#160;type: Task<br />&#160;&#160;implements: Threading.IThreadPoolWorkItem<br />&#160;&#160;implements: IAsyncResult<br />&#160;&#160;implements: IDisposable<br /></div>
<div class="tip" id="tiptask9">val private rotate : Bitmap -&gt; Bitmap -&gt; unit<br /><br />Full name: Processing.rotate
<br /><em><br /><br />&#160;Copy source bitmap to the layer, rotate it (by 90 degrees)<br />&#160;and make it partially transparent (sequentially)</em><br /></div>
<div class="tip" id="tiptask10">val source2 : Bitmap<br /><br />&#160;&#160;type: Bitmap<br />&#160;&#160;implements: Runtime.Serialization.ISerializable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IDisposable<br />&#160;&#160;inherits: Image<br />&#160;&#160;inherits: MarshalByRefObject<br /></div>
<div class="tip" id="tiptask11">val layer2 : Bitmap<br /><br />&#160;&#160;type: Bitmap<br />&#160;&#160;implements: Runtime.Serialization.ISerializable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IDisposable<br />&#160;&#160;inherits: Image<br />&#160;&#160;inherits: MarshalByRefObject<br /></div>
<div class="tip" id="tiptask12">Multiple overloads
<br />Task.WaitAll(tasks: Task []) : unit
<br />Task.WaitAll(tasks: Task [], cancellationToken: Threading.CancellationToken) : unit
<br />Task.WaitAll(tasks: Task [], millisecondsTimeout: int) : bool
<br />Task.WaitAll(tasks: Task [], timeout: TimeSpan) : bool
<br />Task.WaitAll(tasks: Task [], millisecondsTimeout: int, cancellationToken: Threading.CancellationToken) : bool<br /></div>
<div class="tip" id="tiptask13">val private blend : Bitmap -&gt; Bitmap -&gt; Graphics -&gt; unit<br /><br />Full name: Processing.blend
<br /><em><br /><br />&#160;Alpha blend - draw both of the layers on the result bitmap<br />&#160;(using Graphics.DrawImage method) (sequentially)</em><br /></div>
<div class="tip" id="tiptask14">val blender : Graphics<br /><br />&#160;&#160;type: Graphics<br />&#160;&#160;implements: IDeviceContext<br />&#160;&#160;implements: IDisposable<br />&#160;&#160;inherits: MarshalByRefObject<br /></div>
<div class="tip" id="tiptask15">val tasks : Task []<br /><br />Full name: Processing.tasks<br /><br />&#160;&#160;type: Task []<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: Collections.IList<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: Collections.Generic.IList&lt;Task&gt;<br />&#160;&#160;implements: Collections.Generic.ICollection&lt;Task&gt;<br />&#160;&#160;implements: seq&lt;Task&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;inherits: Array<br /></div>
<div class="tip" id="tiptask16">type Array =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;member Clone : unit -&gt; obj<br />&#160;&#160;&#160;&#160;member CopyTo : System.Array * int -&gt; unit<br />&#160;&#160;&#160;&#160;member CopyTo : System.Array * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;member GetEnumerator : unit -&gt; System.Collections.IEnumerator<br />&#160;&#160;&#160;&#160;member GetLength : int -&gt; int<br />&#160;&#160;&#160;&#160;member GetLongLength : int -&gt; int64<br />&#160;&#160;&#160;&#160;member GetLowerBound : int -&gt; int<br />&#160;&#160;&#160;&#160;member GetUpperBound : int -&gt; int<br />&#160;&#160;&#160;&#160;member GetValue : int [] -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int64 -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int64 [] -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int * int -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int64 * int64 -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int * int * int -&gt; obj<br />&#160;&#160;&#160;&#160;member GetValue : int64 * int64 * int64 -&gt; obj<br />&#160;&#160;&#160;&#160;member Initialize : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member IsFixedSize : bool<br />&#160;&#160;&#160;&#160;member IsReadOnly : bool<br />&#160;&#160;&#160;&#160;member IsSynchronized : bool<br />&#160;&#160;&#160;&#160;member Length : int<br />&#160;&#160;&#160;&#160;member LongLength : int64<br />&#160;&#160;&#160;&#160;member Rank : int<br />&#160;&#160;&#160;&#160;member SetValue : obj * int -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int [] -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int64 [] -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int64 * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;member SetValue : obj * int64 * int64 * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;member SyncRoot : obj<br />&#160;&#160;&#160;&#160;static member AsReadOnly&lt;'T&gt; : 'T [] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;<br />&#160;&#160;&#160;&#160;static member BinarySearch : System.Array * obj -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch&lt;'T&gt; : 'T [] * 'T -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch : System.Array * obj * System.Collections.IComparer -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch&lt;'T&gt; : 'T [] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch : System.Array * int * int * obj -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch&lt;'T&gt; : 'T [] * int * int * 'T -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch : System.Array * int * int * obj * System.Collections.IComparer -&gt; int<br />&#160;&#160;&#160;&#160;static member BinarySearch&lt;'T&gt; : 'T [] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member Clear : System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member ConstrainedCopy : System.Array * int * System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member ConvertAll&lt;'TInput,'TOutput&gt; : 'TInput [] * System.Converter&lt;'TInput,'TOutput&gt; -&gt; 'TOutput []<br />&#160;&#160;&#160;&#160;static member Copy : System.Array * System.Array * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Copy : System.Array * System.Array * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;static member Copy : System.Array * int * System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Copy : System.Array * int64 * System.Array * int64 * int64 -&gt; unit<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int [] -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int64 [] -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int * int -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int [] * int [] -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member CreateInstance : System.Type * int * int * int -&gt; System.Array<br />&#160;&#160;&#160;&#160;static member Exists&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; bool<br />&#160;&#160;&#160;&#160;static member Find&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; 'T<br />&#160;&#160;&#160;&#160;static member FindAll&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; 'T []<br />&#160;&#160;&#160;&#160;static member FindIndex&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member FindIndex&lt;'T&gt; : 'T [] * int * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member FindIndex&lt;'T&gt; : 'T [] * int * int * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member FindLast&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; 'T<br />&#160;&#160;&#160;&#160;static member FindLastIndex&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member FindLastIndex&lt;'T&gt; : 'T [] * int * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member FindLastIndex&lt;'T&gt; : 'T [] * int * int * System.Predicate&lt;'T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;static member ForEach&lt;'T&gt; : 'T [] * System.Action&lt;'T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member IndexOf : System.Array * obj -&gt; int<br />&#160;&#160;&#160;&#160;static member IndexOf&lt;'T&gt; : 'T [] * 'T -&gt; int<br />&#160;&#160;&#160;&#160;static member IndexOf : System.Array * obj * int -&gt; int<br />&#160;&#160;&#160;&#160;static member IndexOf&lt;'T&gt; : 'T [] * 'T * int -&gt; int<br />&#160;&#160;&#160;&#160;static member IndexOf : System.Array * obj * int * int -&gt; int<br />&#160;&#160;&#160;&#160;static member IndexOf&lt;'T&gt; : 'T [] * 'T * int * int -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf : System.Array * obj -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf&lt;'T&gt; : 'T [] * 'T -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf : System.Array * obj * int -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf&lt;'T&gt; : 'T [] * 'T * int -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf : System.Array * obj * int * int -&gt; int<br />&#160;&#160;&#160;&#160;static member LastIndexOf&lt;'T&gt; : 'T [] * 'T * int * int -&gt; int<br />&#160;&#160;&#160;&#160;static member Resize&lt;'T&gt; : 'T [] * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Reverse : System.Array -&gt; unit<br />&#160;&#160;&#160;&#160;static member Reverse : System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'T&gt; : 'T [] -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * System.Array -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * System.Collections.IComparer -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'TKey,'TValue&gt; : 'TKey [] * 'TValue [] -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'T&gt; : 'T [] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'T&gt; : 'T [] * System.Comparison&lt;'T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * System.Array * System.Collections.IComparer -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'T&gt; : 'T [] * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'TKey,'TValue&gt; : 'TKey [] * 'TValue [] * System.Collections.Generic.IComparer&lt;'TKey&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * System.Array * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * int * int * System.Collections.IComparer -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'TKey,'TValue&gt; : 'TKey [] * 'TValue [] * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'T&gt; : 'T [] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort : System.Array * System.Array * int * int * System.Collections.IComparer -&gt; unit<br />&#160;&#160;&#160;&#160;static member Sort&lt;'TKey,'TValue&gt; : 'TKey [] * 'TValue [] * int * int * System.Collections.Generic.IComparer&lt;'TKey&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member TrueForAll&lt;'T&gt; : 'T [] * System.Predicate&lt;'T&gt; -&gt; bool<br />&#160;&#160;end<br /><br />Full name: System.Array<br /><br />&#160;&#160;type: Array<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: Collections.IList<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.IStructuralEquatable<br /></div>
<div class="tip" id="tiptask17">val zeroCreate : int -&gt; 'T []<br /><br />Full name: Microsoft.FSharp.Collections.Array.zeroCreate<br /></div>
<div class="tip" id="tiptask18">val i : int32<br /><br />&#160;&#160;type: int32<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: IFormattable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;int&gt;<br />&#160;&#160;implements: IEquatable&lt;int&gt;<br />&#160;&#160;inherits: ValueType<br /></div>
<div class="tip" id="tiptask19">type Console =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;static member BackgroundColor : System.ConsoleColor with get, set<br />&#160;&#160;&#160;&#160;static member Beep : unit -&gt; unit<br />&#160;&#160;&#160;&#160;static member Beep : int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member BufferHeight : int with get, set<br />&#160;&#160;&#160;&#160;static member BufferWidth : int with get, set<br />&#160;&#160;&#160;&#160;static member CapsLock : bool<br />&#160;&#160;&#160;&#160;static member Clear : unit -&gt; unit<br />&#160;&#160;&#160;&#160;static member CursorLeft : int with get, set<br />&#160;&#160;&#160;&#160;static member CursorSize : int with get, set<br />&#160;&#160;&#160;&#160;static member CursorTop : int with get, set<br />&#160;&#160;&#160;&#160;static member CursorVisible : bool with get, set<br />&#160;&#160;&#160;&#160;static member Error : System.IO.TextWriter<br />&#160;&#160;&#160;&#160;static member ForegroundColor : System.ConsoleColor with get, set<br />&#160;&#160;&#160;&#160;static member In : System.IO.TextReader<br />&#160;&#160;&#160;&#160;static member InputEncoding : System.Text.Encoding with get, set<br />&#160;&#160;&#160;&#160;static member KeyAvailable : bool<br />&#160;&#160;&#160;&#160;static member LargestWindowHeight : int<br />&#160;&#160;&#160;&#160;static member LargestWindowWidth : int<br />&#160;&#160;&#160;&#160;static member MoveBufferArea : int * int * int * int * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member MoveBufferArea : int * int * int * int * int * int * char * System.ConsoleColor * System.ConsoleColor -&gt; unit<br />&#160;&#160;&#160;&#160;static member NumberLock : bool<br />&#160;&#160;&#160;&#160;static member OpenStandardError : unit -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;static member OpenStandardError : int -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;static member OpenStandardInput : unit -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;static member OpenStandardInput : int -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;static member OpenStandardOutput : unit -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;static member OpenStandardOutput : int -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;static member Out : System.IO.TextWriter<br />&#160;&#160;&#160;&#160;static member OutputEncoding : System.Text.Encoding with get, set<br />&#160;&#160;&#160;&#160;static member Read : unit -&gt; int<br />&#160;&#160;&#160;&#160;static member ReadKey : unit -&gt; System.ConsoleKeyInfo<br />&#160;&#160;&#160;&#160;static member ReadKey : bool -&gt; System.ConsoleKeyInfo<br />&#160;&#160;&#160;&#160;static member ReadLine : unit -&gt; string<br />&#160;&#160;&#160;&#160;static member ResetColor : unit -&gt; unit<br />&#160;&#160;&#160;&#160;static member SetBufferSize : int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member SetCursorPosition : int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member SetError : System.IO.TextWriter -&gt; unit<br />&#160;&#160;&#160;&#160;static member SetIn : System.IO.TextReader -&gt; unit<br />&#160;&#160;&#160;&#160;static member SetOut : System.IO.TextWriter -&gt; unit<br />&#160;&#160;&#160;&#160;static member SetWindowPosition : int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member SetWindowSize : int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Title : string with get, set<br />&#160;&#160;&#160;&#160;static member TreatControlCAsInput : bool with get, set<br />&#160;&#160;&#160;&#160;static member WindowHeight : int with get, set<br />&#160;&#160;&#160;&#160;static member WindowLeft : int with get, set<br />&#160;&#160;&#160;&#160;static member WindowTop : int with get, set<br />&#160;&#160;&#160;&#160;static member WindowWidth : int with get, set<br />&#160;&#160;&#160;&#160;static member Write : bool -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : char -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : char [] -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : float -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : decimal -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : float32 -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : uint32 -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : int64 -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : uint64 -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : obj -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : string -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : string * obj -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : string * obj [] -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : string * obj * obj -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : char [] * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : string * obj * obj * obj -&gt; unit<br />&#160;&#160;&#160;&#160;static member Write : string * obj * obj * obj * obj -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : unit -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : bool -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : char -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : char [] -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : decimal -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : float -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : float32 -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : int -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : uint32 -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : int64 -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : uint64 -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : obj -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : string -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : string * obj -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : string * obj [] -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : char [] * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : string * obj * obj -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : string * obj * obj * obj -&gt; unit<br />&#160;&#160;&#160;&#160;static member WriteLine : string * obj * obj * obj * obj -&gt; unit<br />&#160;&#160;end<br /><br />Full name: System.Console<br /></div>
<div class="tip" id="tiptask20">Multiple overloads
<br />Console.WriteLine() : unit
<br />Console.WriteLine(value: string) : unit
<br />Console.WriteLine(value: obj) : unit
<br />Console.WriteLine(value: uint64) : unit
<br />Console.WriteLine(value: int64) : unit
<br />Console.WriteLine(value: uint32) : unit
<br />Console.WriteLine(value: int) : unit
<br />Console.WriteLine(value: float32) : unit
<br />Console.WriteLine(value: float) : unit
<br />Console.WriteLine(value: decimal) : unit
<br />&#160;&#160;&#160;<em>(+9 other overloads)</em><br /></div>
<div class="tip" id="tiptask21">val tasks : Task []<br /><br />Full name: Processing.Bar.tasks<br /><br />&#160;&#160;type: Task []<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: Collections.IList<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: Collections.Generic.IList&lt;Task&gt;<br />&#160;&#160;implements: Collections.Generic.ICollection&lt;Task&gt;<br />&#160;&#160;implements: seq&lt;Task&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;inherits: Array<br /></div>
<div class="tip" id="tiptask22">val i : int ref<br /><br />Full name: Processing.Bar.i<br /><br />&#160;&#160;type: int ref<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: IComparable&lt;Ref&lt;int&gt;&gt;<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: Collections.IStructuralComparable<br /></div>
<div class="tip" id="tiptask23">Multiple items
<br />val ref : 'T -&gt; 'T ref<br /><br />Full name: Microsoft.FSharp.Core.Operators.ref
<br /><br />--------------------<br />
<br />type 'T ref = Ref&lt;'T&gt;<br /><br />Full name: Microsoft.FSharp.Core.ref&lt;_&gt;<br /><br />&#160;&#160;type: 'T ref<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: IComparable&lt;Ref&lt;'T&gt;&gt;<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: Collections.IStructuralComparable<br /></div>

    <div class="info">
    <p class="share">
        <a target="_blank" href="https://twitter.com/intent/tweet?url=http%3a%2f%2ftomasp.net%2fblog%2ffsharp-parallel-plinq.aspx%2f&amp;text=Parallel+Programming+in+F%23+(II.)%3a+Using+PLINQ+and+Tasksvia+%40tomaspetricek">
          <i class="fab fa-twitter-square"></i></a>
        <a target="_blank" href="https://www.facebook.com/sharer.php?u=http%3a%2f%2ftomasp.net%2fblog%2ffsharp-parallel-plinq.aspx%2f">
          <i class="fab fa-facebook-square"></i></a>
        <a href="http://www.reddit.com/submit?url=http%3a%2f%2ftomasp.net%2fblog%2ffsharp-parallel-plinq.aspx%2f&title=Parallel+Programming+in+F%23+(II.)%3a+Using+PLINQ+and+Tasks">
          <i class="fab fa-reddit-square"></i></a>
        <a href="mailto:?subject=Parallel%20Programming%20in%20F%23%20(II.)%3a%20Using%20PLINQ%20and%20Tasks&body=%20In%20this%20article%2c%20we%27ll%20look%20at%20several%20F%23%20samples%20from%20Chapters%202%20and%203%20of%20Parallel%20Programming%20with%20Microsoft%20.NET.%20We%27ll%20look%20at%20using%20Task%20Parallel%20Library%20(TPL)%20and%20Parallel%20LINQ%20from%20F%23%2c%20including%20the%20PSeq%20module%20from%20F%23%20PowerPack.%0a%0aSee%3a%20http%3a%2f%2ftomasp.net%2fblog%2ffsharp-parallel-plinq.aspx%2f">
          <i class="fa fa-envelope"></i></a>
    </p>
    <p class="details">
      <strong>Published:</strong> Monday, 6 September 2010, 10:10 AM<br />
      <strong>Author:</strong> Tomas Petricek<br />
      <strong>Typos:</strong> <a href="http://github.com/tpetricek/tomasp.net">Send me a pull request</a>!<br />
      
        <strong>Tags:</strong> <a
          href="/blog/tag/functional/">functional</a>, <a
          href="/blog/tag/parallel/">parallel</a>, <a
          href="/blog/tag/fsharp/">f#</a></span><br />
      
    </p>
    </div>
  </article>


  <footer>
  <div class="footer-body">
    <div class="fl70"><div class="fmr">
      <h4><a href="http://tomasp.net/rss.xml"><i class="fa fa-rss" style="margin-right:5px;"></i></a> Blog archives</h4>
      <p>
      
      <a href="/blog/archive/february_2025/">February 2025 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2023/">December 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2023/">February 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2022/">September 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2022/">April 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2021/">October 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2021/">April 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2020/">October 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2020/">July 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2020/">April 2020 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2019/">December 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2019/">February 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2018/">November 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2018/">October 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2018/">May 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2017/">September 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2017/">June 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2017/">April 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2017/">March 2017 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2017/">January 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2016/">October 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2016/">September 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/august_2016/">August 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2016/">July 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2016/">May 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2016/">April 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2015/">December 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2015/">November 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2015/">September 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2015/">July 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2015/">June 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2015/">May 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2015/">April 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2015/">March 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2015/">February 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2015/">January 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2014/">December 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2014/">May 2014 (3)</a>,&nbsp;
      
      <a href="/blog/archive/april_2014/">April 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2014/">March 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2014/">January 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2013/">December 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2013/">November 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2013/">October 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2013/">September 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2013/">August 2013 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2013/">May 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2013/">April 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2013/">March 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2013/">February 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2013/">January 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2012/">December 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/october_2012/">October 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2012/">August 2012 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2012/">June 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2012/">April 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2012/">March 2012 (4)</a>,&nbsp;
      
      <a href="/blog/archive/february_2012/">February 2012 (5)</a>,&nbsp;
      
      <a href="/blog/archive/january_2012/">January 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2011/">November 2011 (5)</a>,&nbsp;
      
      <a href="/blog/archive/august_2011/">August 2011 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2011/">July 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/june_2011/">June 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2011/">May 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2011/">March 2011 (4)</a>,&nbsp;
      
      <a href="/blog/archive/december_2010/">December 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2010/">November 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2010/">October 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/september_2010/">September 2010 (4)</a>,&nbsp;
      
      <a href="/blog/archive/july_2010/">July 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2010/">June 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2010/">May 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2010/">February 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2010/">January 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/december_2009/">December 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2009/">July 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2009/">June 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2009/">May 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2009/">April 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2009/">March 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2009/">February 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2008/">December 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2008/">November 2008 (5)</a>,&nbsp;
      
      <a href="/blog/archive/october_2008/">October 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2008/">September 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2008/">June 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2008/">March 2008 (3)</a>,&nbsp;
      
      <a href="/blog/archive/february_2008/">February 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2007/">December 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2007/">November 2007 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2007/">October 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2007/">September 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2007/">August 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2007/">July 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2007/">April 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2007/">March 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2007/">February 2007 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2007/">January 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2006/">November 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2006/">October 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/august_2006/">August 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/july_2006/">July 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2006/">June 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2006/">May 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2006/">April 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2005/">December 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2005/">July 2005 (4)</a>,&nbsp;
      
      <a href="/blog/archive/june_2005/">June 2005 (5)</a>,&nbsp;
      
      <a href="/blog/archive/may_2005/">May 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2005/">April 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2005/">March 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2005/">January 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2004/">December 2004 (3)</a>,&nbsp;
      
      <a href="/blog/archive/november_2004/">November 2004 (2)</a>,&nbsp;
      
      </p>
    </div></div>
    <div class="fr30"><div class="fmr">
      <h4>License and about</h4>
      <p>All articles on this site are licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share Alike</a>.
        All source code samples are licensed under the MIT License.
      </p>
      <p>This site is hosted on GitHub and is generated using <a href="https://github.com/tpetricek/FSharp.Formatting">F# Formatting</a>
        and <a href="http://dotliquidmarkup.org/">DotLiquid</a>.
        For more info, see the <a href="https://github.com/tpetricek/tomasp.net">website source on GitHub</a>.
      </p>
      <p>Please submit issues &amp; corrections on GitHub. Use pull requests for minor corrections only.</p>
      <ul>
        <li><i class="fab fa-twitter"></i> Twitter: <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a></li>
        <li><i class="fab fa-github"></i> GitHub: <a href="https://github.com/tpetricek">@tpetricek</a></li>
        <li><i class="fa fa-envelope"></i> Email: <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a></li>
      </ul>
      <p style="text-align:center;margin-top:15px;"><img src="https://tomasp.net/img/cc-sa.png" alt="CC License logo" /></p>
    </div></div>
  </div>
  </footer>

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-1561220-1']);
    _gaq.push(['_trackPageview']);
    (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</body>
</html>
