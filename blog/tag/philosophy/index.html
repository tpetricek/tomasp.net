<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <meta name=viewport content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Droid+Sans+Mono&family=Kreon:wght@300;400;500;600&family=PT+Sans:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha512-xh6O/CkQoPOWDdYTDqeRdPCVd1SpvCA9XXcUnZS2FmJNp1coAFzvtCN9BmamE+4aHK8yyUHUSCcJHgXloTyT2A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="alternate" type="application/rss+xml" title="Latest news from Tomas Petricek" href="/rss.xml" />
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <link href="/custom/style.css" rel="stylesheet">
  <link href="/custom/tooltips.css" rel="stylesheet">
  <script src="/custom/tooltips.js" type="text/javascript"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon-big.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/img/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/img/favicon-big.png">
  <meta name="msapplication-TileColor" content="#004C6B">
  <meta name="msapplication-TileImage" content="/img/favicon-big.png">
  <meta name="theme-color" content="#004C6B">
  
  <title>Tagged philosophy - Latest writings from my blog - Tomas Petricek</title>
  <meta name="description" content="Tomas Petricek's latest blog posts about programming languages and tools, working with data, philosophy of science and more." />
  <meta name="author" content="Tomas Petricek" />
  <meta name="copyright" content="Tomas Petricek" />

</head>
<body class="default">
  
<span class="tplink"><a href="/">TP</a></span>

<article>
  
    <h1><a href="http://tomasp.net/blog/2021/popup-from-hell/">Pop-up from Hell: On the growing opacity of web programs</a></h1>
    <p>I started to learn how to program in high school at the end of the 1990s using a mix of BASIC, Turbo
Pascal and HTML with JavaScript. The seed for this blog post comes from my experience with learning
how to program in JavaScript, without having much guidance or organized resources. This article continues
a theme that I started in my <a href="http://tomasp.net/commodore64">interactive Commodore 64 article</a>,
which is to look at past programming systems and see what interesting past ideas have been lost
in contemporary systems. Unlike with Commodore 64, which I first used in 2018 in the
Seattle Living Computers museum, my perspective on the Early Web may be biased by personal
experience. I will do my best to not make this post sound like a grumbling of an old nerd!
(I thought this only comes later, but I may have been wrong...)</p>
<div class="rdecor"><img src="http://tomasp.net/blog/2021/popup-from-hell/close-me.gif" style="max-width:400px" /></div>
<p>The 1990s, the web had a fair amount of quirky web pages, often created just for fun. The GeoCities
hosting service, which has <a href="http://www.oocities.org">partly been archived</a> is a witness of this
and there are even academic books, such as <a href="https://amzn.to/2YiEUVe">Dot-Com Design</a> documenting
this history.</p>
<p>Some of the quirky things that you could do with JavaScript included creating roll-over effects
(making an image change when mouse pointer is over it), creating an animation that follows the
cursor as it moves and, of course, annoying the users with all sorts of pop-up windows for both
entertaining and advertising purposes. Annoying pop-ups will be the starting point for my blog
post, but I'll be using those to make a more general and interesting point about how programs
evolve to become more opaque.</p>
<p><em>This blog post is based on a talk <a href="http://tpetricek.github.io/Talks/2021/popup-from-hell/">Popup from hell: Reflections on the most annoying 1990s
program</a> that I did recently at an
(in person!) meeting of the <a href="https://programme.hypotheses.org/">PROGRAMme project</a>. Thanks to
everyone who attended for lively discussion and useful feedback!</em></p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Friday, 8 October 2021, 1:14 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/academic/">academic</a>, <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/web/">web</a>, <a
              href="/blog/tag/philosophy/">philosophy</a>, <a
              href="/blog/tag/talks/">talks</a>
        
        <br />
        <a href="http://tomasp.net/blog/2021/popup-from-hell/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2021/software-designers/">Software designers, not engineers: An interview from alternative universe</a></h1>
    <p>While the physicists investigate the nature of the mysterious portal that has recently appeared in
North London, several human beings recently came through the portal, which appears to be a
gate into an alternative universe. As we understood from the last two people coming through the
portal, it seems to be a linked with a universe that is in many ways like ours, reached about the
same level of social and technological development, but differs in numerous curious details.
The paths through which people in this alternative universe reached similar results as our world
are often subtly different.</p>
<div class="rdecor"><a href="https://amzn.to/3x0Ww5a"><img src="http://tomasp.net/blog/2021/software-designers/ways.png" style="max-width:260px" /></a></div>
<p>The most recent visitor from the alternative universe is Ms Zaha Atkinson, who would most likely
be titled <em>software engineer</em> in our world, although the title she uses in her home world is
<em>software designer</em>. She is a well-known software designer and has been also titled using the
strange-sounding title <em>softwarenova</em>, a label that we will soon say more about. As with other
technological and societal developments, the alternative universe seems to have arrived at very
similar results as our worlds. Software is eating the (alternative) world, but it is built in very
different ways. The interview with Ms Zaha Atkinson, presented below, reveals how very different
the world of software is when we think of programmers as software <em>designers</em> rather than as
software <em>engineers</em>.</p>
<p><em>This article is a work of fiction. Any resemblance to actual events or persons, living or dead,
may or may not be entirely coincidental. It has been largely inspired by the book
<a href="https://amzn.to/3x0Ww5a">Designerly Ways of Knowing</a> by Nigel Cross. Ms <a href="https://en.wikipedia.org/wiki/Zaha%5FHadid">Zaha</a>
<a href="https://en.wikipedia.org/wiki/Bill%5FAtkinson">Atkinson</a> also may or may not be entirely fictional.</em></p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 19 April 2021, 2:30 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/academic/">academic</a>, <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/design/">design</a>, <a
              href="/blog/tag/philosophy/">philosophy</a>, <a
              href="/blog/tag/architecture/">architecture</a>
        
        <br />
        <a href="http://tomasp.net/blog/2021/software-designers/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2020/learning-and-programming/">Is deep learning a new kind of programming? Operationalistic look at programming</a></h1>
    <p>In most discussions about how to make programming better, someone eventually says
something along the lines of <em>"we'll just have to wait until deep learning solves
the problem!"</em> I think this is a <a href="https://en.wikipedia.org/wiki/AI_winter">naively optimistic idea</a>,
but it raises one interesting question: In what sense are programs created using deep
learning a <em>different kind</em> of programs than those written by hand?</p>
<div class="rdecor">
<img src="http://tomasp.net/blog/2020/learning-and-programming/bridgman.jpg" style="max-width:350px"/>
</div>
<p>This question recently arose in discussions that we have been having as part of the
<a href="https://programme.hypotheses.org/">PROGRAMme project</a>, which explores historical and
philosophical perspectives on the question "What is a (computer) program?" and so this
article owes much debt to <a href="https://programme.hypotheses.org/members">others involved in the project</a>,
especially Maël Pégny, Liesbeth De Mol and Nick Wiggershaus.</p>
<p>Many people will intuitively think that, if you train a deep neural network to solve some
a problem, you get a different kind of program than if you manually write some logic to solve
the problem. But what exactly is the difference? In both cases, the program is a sequence of
instructions that are deterministically executed by a machine, one after another, to produce
the result.</p>
<p>When reading the excellent book <a href="https://amzn.to/2SvTwKT" title="Hasok Chang (2004). Inventing Temperature: Measurement and Scientific Progress">Inventing Temperature</a> by Hasok
Chang recently, I came across the idea of <a href="https://plato.stanford.edu/entries/operationalism/" title="Hasok Chang (2019). Operationalism, The Stanford Encyclopedia of Philosophy">operationalism</a>,
which I believe provides a useful perspective for thinking about the issue of deep learning and
programming. The operationalist point of view was introduced by a physicist Percy Williams Bridgman. To
quote: <em>we mean by any concept nothing more than a set of operations; the concept is synonymous
with the corresponding set of operations</em>. What does this tell us about deep learning and programming?</p>



    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Wednesday, 7 October 2020, 2:43 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/programming-languages/">programming languages</a>, <a
              href="/blog/tag/philosophy/">philosophy</a>, <a
              href="/blog/tag/research/">research</a>
        
        <br />
        <a href="http://tomasp.net/blog/2020/learning-and-programming/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2020/cities-and-programming/">On architecture, urban planning and software construction</a></h1>
    <p>Despite having the term <em>science</em> in its name, it is not always clear what kind of
discipline <em>computer science</em> actually is. Research on programming is sometimes like
science, sometimes like mathematics, sometimes like engineering, sometimes like design
and sometimes like art. It also has a long tradition of importing ideas from a wide range
of other disciplines.</p>
<p>In this article, I will look at ideas from architecture and urban planning. Architecture
has already been an inspiration for <em>design patterns</em>, although some would say that we did
quite poor job and imported a trivialized (and not very useful) version of the idea. However,
there are many other interesting ideas in architecture and urban planning worth exploring.</p>
<div class="rdecor-sm"><img src="http://tomasp.net/blog/2020/cities-and-programming/patterns.jpg" /></div>
<p>To explain why learning from architecture and urban planning is a good idea, I will first
discuss similarities between problems solved by architects or urban planners and programmers.
I will then look at a number of concrete ideas that we can learn, mostly taking inspiration
from four books that I've read recently. There are two general areas:</p>
<ul>
<li>
<p>First, writing about architecture and urban planning often uses interesting methodologies
that research on programming could adopt to gain new insights into systems, programming
and its problems.</p>
</li>
<li>
<p>Second, there are a number of more concrete ideas in architecture and urban planning that
might directly apply to software. For example, can programmers learn how to deal with complexity
of software by looking at how urban planners deal with the complexity of cities? Or, can we learn
about software maintenance by looking at how buildings evolve in time?</p>
</li>
</ul>
<p>The nature of problems that programmers face are often more similar to the problems that
architects and urban planners have to deal with than, say, the problems that scientists, engineers
or mathematicians need to solve. We might not want to go all the way and completely rebuild
how we do programming to mirror architecture and urban planning, but treating the ideas from those
disciplines as equal to those from science or engineering will make programming richer and more
productive discipline.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Wednesday, 8 April 2020, 12:13 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/academic/">academic</a>, <a
              href="/blog/tag/programming-languages/">programming languages</a>, <a
              href="/blog/tag/philosophy/">philosophy</a>, <a
              href="/blog/tag/design/">design</a>, <a
              href="/blog/tag/architecture/">architecture</a>
        
        <br />
        <a href="http://tomasp.net/blog/2020/cities-and-programming/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2019/first-language/">What to teach as the first programming language and why</a></h1>
    <p>The number of Google search results for the phrase
<a href="https://www.google.com/search?q=" title="choosing+the+first+programming+language">"choosing the first programming language"</a>
at the time of writing is 15,800. This illustrates just how debated the issue of choosing the first
programming language is. In this blog post, I will not actually try to answer the question posed
in the title of the post. I will not discuss what language we should teach as the first one.
Instead, I will look at a more interesting question.</p>
<p>I will investigate the arguments that are used in favour of or against particular programming
languages in computer science curriculum. I am more interested in the kind of argumentation that
is employed to support a particular choice than in the specific languages involved. This approach is
valuable for two reasons. First, by looking at the argumentation used, we can learn what educators
consider important about computer science. Second, understanding the motivations behind different
arguments allows us to make our own debates about the choice of a programming language more informed.</p>
<p>The scope of this blog post is limited to the choice of the first programming language taught in an
undergraduate computer science programmes at universities. This means that I will not discuss other
important contexts such as choices at a primary or a secondary education level, choices for
independent learners and choices in other university degrees that might involve programming.</p>
<p>Note that this blog post is adapted from an essay that I wrote as part of a
<a href="https://www.kent.ac.uk/teaching/qualifications/pgche/">Postgrduate Certificate for Higher Education programme</a>
at University of Kent, so it assumes less knowledge about programming than a typical reader of
my blog has. This makes it accessible to a broader audience thinking about education
though!</p>



    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 2 December 2019, 5:48 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/academic/">academic</a>, <a
              href="/blog/tag/programming-languages/">programming languages</a>, <a
              href="/blog/tag/philosophy/">philosophy</a>, <a
              href="/blog/tag/writing/">writing</a>
        
        <br />
        <a href="http://tomasp.net/blog/2019/first-language/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2019/software-engineering/">What should a Software Engineering course look like?</a></h1>
    <p>When I joined the <a href="https://www.cs.kent.ac.uk/">School of Computing</a> at the <a href="https://www.kent.ac.uk/">University of
Kent</a>, I was asked what subjects I wanted to teach. One of the topics
I chose was <em>Software Engineering</em>. I spent quite a lot of time reading about the history of
software engineering when working on my paper <a href="/academic/papers/failures/index.html">on programming
errors</a> and I go to a fair number of <a href="http://github.com/tpetricek/Talks">professional
programming conferences</a>, so I thought I can come up
with a good way of teaching it! Yet, I was not quite sure how to go about it or even what
<em>software engineering</em> actually means.</p>
<p>In this blog post, I share my thought process on deciding what to cover in my Software
Engineering module and also a rough list of topics. The introduction explaining <em>why</em> I chose
these and <em>how</em> I structure them is perhaps more important than the list itself, but it
is fairly long, so if you just want to see a list you can
<a href="http://tomasp.net/blog/2019/software-engineering/#fund">skip ahead to Section 2</a> (but please read the
introduction if you want to comment on the list!) I also add a brief reflection on why I think
this is a good approach, referencing a couple of ideas from philosophy of science in <a href="#phil">Section 3</a>.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Friday, 8 February 2019, 12:22 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/academic/">academic</a>, <a
              href="/blog/tag/teaching/">teaching</a>, <a
              href="/blog/tag/philosophy/">philosophy</a>
        
        <br />
        <a href="http://tomasp.net/blog/2019/software-engineering/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2018/alien-lambda-calculus/">Would aliens understand lambda calculus?</a></h1>
    <p>Unless you are a sci-fi author or some secret government agency, the question whether aliens
would understand lambda calculus is probably not your main practical concern. However, the question
is intriguing because it nicely vividly formulates a fundamental question about our formal mathematical
knowledge. Are mathematical theories and results about them <em>invented</em>, i.e. constructed by
humans, or <em>discovered</em>, i.e. are they eternal truths that exist regardless of whether there are
humans to know them?</p>
<img src="http://tomasp.net/blog/2018/alien-lambda-calculus/human.jpg" class="rdecor"
    style="width:40%;max-width:400px;margin-left:30px;margin-top:0px;margin-bottom:0px" />
<p>The question makes for a fantastic late night pub debate, but how can we go about answering it using
a more serious methodology? Is there a paper one can read to better understand the problem?
Occasionally, a <a href="https://www.youtube.com/watch?list=PLcGKfGEEONaCIl5eU53uPBnRJ9rbIH32R&amp;v=IOiZatlZtGU">talk</a>
or an <a href="https://www.quora.com/Do-aliens-have-LISP-or-Scheme">online comment</a>
by a computer scientist comments on this question, but way too often, people miss the fact that
the nature of mathematical entities is one of the fundamental questions of <em>philosophy of
mathematics</em>. Alas, all those discussions are carefully hidden in the humanities department!</p>
<p>I believe that knowing a bit about philosophy of mathematics is important if we want to have a
meaningful debate about philosophical questions of mathematics (sic!) and so I did a talk
<a href="https://www.youtube.com/watch?v=JoWH2jNlvQQ">on this very subject at CodeMesh 2017</a>.
This article is slightly refined and hopefully
more polished version of the talk for those who, like me, prefer reading over watching.
Keep in mind that the question about the nature of mathematical entities is one of the fundamental
questions of an <em>entire academic discipline</em>. As such, this article cannot possibly cover all the
relevant discussions. Compared to some other writings in this space, this article is, at least,
based on a couple of philosophical books that, I believe, have useful things to say on the subject!</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Tuesday, 22 May 2018, 11:27 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/academic/">academic</a>, <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/programming-languages/">programming languages</a>, <a
              href="/blog/tag/philosophy/">philosophy</a>
        
        <br />
        <a href="http://tomasp.net/blog/2018/alien-lambda-calculus/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2017/design-side-of-pl/">The design side of programming language design</a></h1>
    <div style="text-align:center">
<a href="http://amzn.to/2gVxn8W">
  <img src="http://tomasp.net/blog/2017/design-side-of-pl/parsons.jpg" class="rdecor"
    style="max-width:220px;margin-left:30px;margin-top:20px;margin-bottom:20px;width:75%" /></a></div>
<p>The word "design" is often used when talking about programming languages. In fact, it even made
it into the name of one of the most prestigious academic programming conferences, <a href="http://www.sigplan.org/Conferences/PLDI/">Programming
Language Design and Implementation (PLDI)</a>. Yet, it is
almost impossible to come across a paper about programming languages that uses design methods to
study its subject. We intuitively feel that "design" is an important aspect of programming
languages, but we never found a way to talk about it and instead treat programming languages as
mathematical puzzles or as engineering problems.</p>
<p>This is a shame. Applying design thinking, in the sense used in applied arts, can let us talk
about, explore and answer important questions about programming languages that are ignored when
we limit ourselves to mathematical or engineering methods. I think the programming language
community is, perhaps unconsciously, aware of this - one of the reviews of <a href="http://tomasp.net/academic/papers/fsharp-data/">my recent PLDI
paper</a> said <em>"this is a nice, novel design paper,
and the community often wants more design papers in our conferences"</em>. The problem is that we
we do not know how to write and evaluate work that follows design methodology.</p>
<p>To better understand how design works, I recently read <a href="http://amzn.to/2gVxn8W">The Philosophy of Design</a>
by Glenn Parsons. The book perhaps did not answer many of my questions about design, but it did give
me a number of ideas about what design is, what questions it can explore and how those could be
relevant for the study of programming languages...</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Tuesday, 12 September 2017, 6:42 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/academic/">academic</a>, <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/programming-languages/">programming languages</a>, <a
              href="/blog/tag/philosophy/">philosophy</a>, <a
              href="/blog/tag/design/">design</a>
        
        <br />
        <a href="http://tomasp.net/blog/2017/design-side-of-pl/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2017/papers-we-scrutinize/">Papers we Scrutinize: How to critically read papers</a></h1>
    <p>As someone who enjoys being at the intersection of the academic world and the world of
industry, I'm very happy to see any attempts at bridging this harmful gap. For this reason,
it is great to see that <a href="http://michaelrbernste.in/2014/10/21/should-i-read-papers.html">more people are interested in reading academic
papers</a> and that initiatives
like <a href="http://paperswelove.org/">Papers We Love</a> are there to help.</p>
<a href="http://paperswelove.org/"><img src="http://tomasp.net/blog/2017/papers-we-scrutinize/pwl.png" class="rdecor" style="width:300px;"/></a>
<p>There is one caveat with academic papers though. It is very easy to see academic papers
as containing eternal and unquestionable truths, rather than as something that the reader
should actively interact with. I <a href="https://twitter.com/tomaspetricek/status/814600193643577344">recently remarked</a>
about this saying that "reading papers" is too passive. I also mentioned one way of doing more
than just "reading", which is to write "critical reviews" – something that we recently tried
to do at the <a href="http://2017.programmingconference.org/track/refuses-2017">Salon des Refusés</a> workshop.
In this post, I would like to expand my remark.</p>
<p>First of all, it is very easy to miss the context in which papers are written. The life of an academic
paper is not complete after it is published. Instead, it continues living its own life – people refer to it
in various contexts, give different meanings to entities that appear in the paper and may "love"
different parts of the paper than the author. This also means that there are different ways of
reading papers. You can try to reconstruct the original historical context, read it according to
the current main-stream interpretation or see it as an inspiration for your own ideas.</p>
<p>I suspect that many people, both in academia and outside, read papers without worrying about
<em>how</em> they are reading them. You can certainly "do science" or "read papers" without reflecting
on the process. That said, I think the philosophical reflection is important if we do not want to
get stuck in local maxima.</p>



    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Wednesday, 12 April 2017, 3:05 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/academic/">academic</a>, <a
              href="/blog/tag/programming-languages/">programming languages</a>, <a
              href="/blog/tag/philosophy/">philosophy</a>
        
        <br />
        <a href="http://tomasp.net/blog/2017/papers-we-scrutinize/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2017/programming-mythology/">The mythology of programming language ideas</a></h1>
    <p>If you read a about the history of science, you will no doubt be astonished by some of the
amazing theories that people used to believe. I recently finished reading <a href="http://amzn.to/2mPjXtW">The Invention of Science
by David Wootton</a>, which documents many of them (and is well worth reading,
not just because of this!) For example, did you know that if you put garlic on a magnet, the magnet
will stop working? Fortunately, you can recover the magnet by smearing goats blood on it. <a href="https://en.wikipedia.org/wiki/Giambattista_della_Porta">Giambattista
della Porta</a> tested this and concluded that it
was false, but <a href="https://en.wikipedia.org/wiki/Alexander_Ross_(writer)">Alexander Ross</a> argued that
our garlic is perhaps not so vigorous as those of ancient Greeks.</p>
<div style="text-align:center"><a href="http://tomasp.net/blog/2017/programming-mythology/heliocentric.jpg">
  <img src="http://tomasp.net/blog/2017/programming-mythology/heliocentric.jpg" class="rdecor"
    style="width:60%;max-width:400px;margin-left:30px;margin-top:0px;margin-bottom:20px" /></a></div>
<p>You can just laugh at these stories, but they can serve as interesting lessons for any scientist.
The lesson, however, is not the obvious one. Academics will <a href="http://danghica.blogspot.co.uk/2016/09/what-else-are-we-getting-wrong.html">sometimes read those
stories</a> and use them
to argue against something they do not consider scientific - arguing that it is like believing
that garlic break magnets.</p>
<p>This is not how the analogy works. What is amazing about the old stories is that the conclusions
that now seem funny often had very solid reasoning behind them. If you believed in the basic
assumption of the time, then you could reach the same conclusions by following fairly sound
reasoning principles. In other words, the amazing theories were scientific and entirely reasonable.
The lesson is that what seems a completely reasonable idea now, may turn out to be wrong and quite
hilarious in retrospect.</p>
<p>In this article, I will look at a couple of amazing theories that people believed in the past
and I will explain why they were reasonable given the way of thinking of the time.
Along the way, I will explore some of the ways of thinking that we use today about
programming and computer science and why they might appear silly in the future.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Tuesday, 7 March 2017, 4:31 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/academic/">academic</a>, <a
              href="/blog/tag/programming-languages/">programming languages</a>, <a
              href="/blog/tag/philosophy/">philosophy</a>
        
        <br />
        <a href="http://tomasp.net/blog/2017/programming-mythology/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2016/thinking-unthinkable/">Thinking the unthinkable: What we cannot think in programming</a></h1>
    <blockquote>
<p><em><i class="fa fa-file-pdf-o" style="font-size:110%;margin:0px 5px 0px 0px"></i>
This blog post is an edited and more accessible version of an article <a href="http://tomasp.net/academic/drafts/unthinkable/">Thinking the
unthinkable</a> that I recently presented at the PPIG 2016
conference. The <a href="http://tomasp.net/academic/drafts/unthinkable/unthinkable-ppig.pdf">original article</a>
(PDF) has proper references and more details; the <a href="http://tpetricek.github.io/Talks/2016/unthinkable/ppig/">minimalistic talk
slides</a> give a quick summary of the article.</em></p>
<p><em><i class="fa fa-hand-o-right" style="font-size:110%;margin:0px 5px 0px 0px"></i>
If you find this interesting, you might also be interested in a <a href="https://github.com/tpetricek/anarchy-workshop/blob/master/proposal.md">workshop we are
planning</a>. To keep in
touch leave a <a href="https://github.com/tpetricek/anarchy-workshop/issues/3">comment on GitHub</a>, ping me
at <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a> or email <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a>!</em></p>
</blockquote>
<div class="rdecor">
<img src="http://tomasp.net/blog/2016/thinking-unthinkable/bufo.jpg" />
</div>
<p>Our thinking is shaped by basic assumptions that we rarely question. These assumptions exist at
different scales. Foucault's <em>episteme</em> describes basic assumptions of an epoch (such as Renaissance);
Kuhn's <em>research paradigms</em> determine how scientists of a given discipline approach problems and
Lakatos' <em>research programmes</em> provide undisputable assumptions followed by a group of scientists.</p>
<p>In this article, I try to discover some of the hidden assumptions in the area of programming
language research. What are assumptions that we never question and that determine how programming
languages are designed? And what might the world look like if we based our design method on
different basic principles?</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Tuesday, 11 October 2016, 6:30 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/philosophy/">philosophy</a>, <a
              href="/blog/tag/programming-languages/">programming languages</a>
        
        <br />
        <a href="http://tomasp.net/blog/2016/thinking-unthinkable/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2016/philopl-questions/">Philosophical questions about programming</a></h1>
    <p>Combining philosophy and computer science might appear a bit odd. The disciplines have very little
overlap. Both philosophers and computer scientists get taught formal logic at some point in their
undergraduate courses, but that's probably as close as they get.</p>
<p>But the fact that the disciplines do not overlap much might very well be the reason why putting them
together is interesting. In an article about <a href="http://jods.mitpress.mit.edu/pub/designandscience">Design and Science</a>,
Joichi Ito (from MIT Media Lab), describes the term <em>antidisciplinary</em> and nicely
summarizes why looking at such unusual combinations is worthwhile:</p>
<blockquote>
<p>Interdisciplinary work is when people from different disciplines work together. But
<em>antidisciplinary</em> is something very different; it's about working in spaces that
simply do not fit into any existing academic discipline.</p>
<p>[When focusing on disciplines, it] takes more and more effort and resources to make a
unique contribution. While the space between and beyond the disciplines can be academically
risky, it (...) requires fewer resources to try promising, unorthodox
approaches; and provides the potential to have tremendous impact (...).</p>
</blockquote>
<p>As you can see from some of my <a href="http://tomasp.net/blog/tag/philosophy/">earlier blog posts</a>,
I think the space between philosophy and computer science is an interesting area. In this article,
I'll explain why. Unlike some of the previous posts (about <a href="http://tomasp.net/blog/2015/failures/index.html">miscomputation</a>,
<a href="http://tomasp.net/blog/2015/against-types/index.html">types</a> and <a href="http://tomasp.net/blog/2014/philosophy-pl/index.html">philosophy of
science</a>), this post is quite broad and
does not go into much detail.</p>
<p>At the danger of sounding like a collection of random rants, I look at a number of
questions that arise when you look at computer science from the philosophical perspective,
but I won't attempt to answer them. You can see this article as a research proposal too -
and I hope to write more about some of the questions in the future.
I wish antidisciplinary work was more common and I believe looking
into such questions could have the tremendous impact that Joichi Ito mentioned.</p>



    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Thursday, 26 May 2016, 2:33 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/philosophy/">philosophy</a>, <a
              href="/blog/tag/programming-languages/">programming languages</a>
        
        <br />
        <a href="http://tomasp.net/blog/2016/philopl-questions/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2015/reading-list/">Philosophy of science books every computer scientist should read</a></h1>
    <p>When I tell my fellow computer scientists or software developers that I'm interested in
<em>philosophy of science</em>, they first look a bit confused, then we have a really interesting
discussion about it and then they ask me for some interesting books they could read about it.
Given that Christmas is just around the corner and some of the readers might still be looking
for a good present to get, I thought that now is the perfect time to turn my answer into a
blog post!</p>
<p>So, what is philosophy of science about? In summary, it is about trying to better understand
science. I'll keep using the word <em>science</em> here, but I think <em>engineering</em> would work equally
well. As someone who recently spent a couple of years doing a PhD on programming language theory,
I find this extremely important for computer science (and programming). How can we make better
programming languages if we do not know what <em>better</em> means? And what do we mean when we talk
about very basic concepts like <em>types</em> or programming <em>errors</em>?</p>
<p>Reading about philosophy of science inspired me to write a couple of essays on some of the
topics above including <a href="/blog/2014/philosophy-pl/">What can programming language research learn from the philosophy of science?</a> and two essays that discuss the <a href="/blog/2015/against-types/">nature of types in programming languages</a> and also
the nature of <a href="/blog/2015/failures/">errors and miscomputations</a>. This blog post lists some of
the interesting books that I've read and that influenced my thinking (not just) when writing the
aforementioned essays.</p>



    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Thursday, 10 December 2015, 1:42 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/philosophy/">philosophy</a>, <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/talks/">talks</a>
        
        <br />
        <a href="http://tomasp.net/blog/2015/reading-list/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2015/failures/">Miscomputation: Learning to live with errors</a></h1>
    <blockquote>
<img src="http://tomasp.net/blog/2015/failures/babbage.png" style="float:right;width:110px;margin:5px 0px 10px 20px" />
<p style="margin-bottom:5px">If trials of three or four simple cases have been made, and are found
to agree with the results given by the engine, it is scarcely possible that there can be any error
(...).</p>
<p style="text-align:right">Charles Babbage, On the mathematical<br /> powers of the calculating engine (1837)</p>
</blockquote>
<p>Anybody who has something to do with modern computers will agree that the above statement made by
Charles Babbage about the analytical engine is understatement, to say the least.</p>
<p>Computer programs do not always work as expected. There is a complex taxonomy of errors or
<a href="http://link.springer.com/article/10.1007/s13347-013-0112-0"><em>miscomputations</em></a>. The taxonomy of
possible errors is itself interesting. Syntax errors like missing semicolons are quite obvious
and are easy to catch. Logical errors are harder to find, but at least we know that something
went wrong. For example, our algorithm does not correctly sort some lists. There are also issues that
may or may not be actual errors. For example an algorithm in online store might suggest slightly
suspicious products. Finally, we also have concurrency errors that happen very rarely in some
very specific scenario.</p>
<p>If Babbage was right, we would just try three or four simple cases and eradicate all errors from
our programs, but eliminating errors is not so easy. In retrospect, it is quite interesting to
see how long it took early computer engineers to realise that coding (i.e. translating
mathematical algorithm to program code) errors are a problem:</p>
<blockquote>
<p style="margin-bottom:5px">Errors in coding were only gradually recognized to be a signiﬁcant
problem: a typical early comment was that of Miller [circa 1949], who wrote that such errors,
along with hardware faults, could be "expected, in time, to become infrequent".</p>
<p style="text-align:right">Mark Priestley, Science of Operations (2011)</p>
</blockquote>
<p>We <em>mostly</em> got rid of hardware faults, but coding errors are still here. Programmers spent
over 50 years finding different practical strategies for dealing with them. In this
blog post, I want to look at four of the strategies. Quite curiously, there is a very wide range.</p>



    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 27 July 2015, 3:15 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/philosophy/">philosophy</a>, <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/programming-languages/">programming languages</a>
        
        <br />
        <a href="http://tomasp.net/blog/2015/failures/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2015/against-types/">Against the definition of types</a></h1>
    <blockquote>
<p style="margin-bottom:5px">Science is much more 'sloppy' and 'irrational' than its methodological image.</p>
<p style="text-align:right">Paul Feyerabend, Against Method (1975)</p>
</blockquote>
<a href="http://tomasp.net/academic/drafts/against-types/">
<img src="http://tomasp.net/blog/2015/against-types/paper.png" style="float:right;margin:0px 0px 5px 20px;width:160px" />
</a>
<p>Programming languages are a fascinating area because they combine computer science (and logic) with
many other disciplines including <a href="http://lmeyerov.github.io/projects/socioplt/viz/index.html">sociology</a>, <a href="https://www.cl.cam.ac.uk/teaching/1415/P201/">human computer interaction</a> and things
that cannot be scientifically quantified like intuition, taste and (for better or worse) politics.</p>
<p>When we talk about programming languages, we often treat it mainly as scientific discussion seeking
some objective truth. This is not surprising - science is surrounded by an aura of perfection and
so it is easy to think that focusing on the core scientific essence (and leaving out everything)
else is the right way of looking at programming languages.</p>
<p>However this leaves out many things that make programming languages interesting. I believe that one
way to fill the missing gap is to look at philosophy of science, which can help us understand how
programming language research is done and how it should be done. I wrote about the general idea
<a href="http://tomasp.net/blog/2014/philosophy-pl/">in a blog post (and essay) last year</a>. Today, I want to talk about one specific topic: <em>What
is the meaning of types?</em></p>
<p>This blog post is a shorter (less philosophical and more to the point) version of an essay that
I submitted to <a href="http://2015.splashcon.org/track/onward2015-essays">Onward! Essays 2015</a>. If you want to get a quick peek at the ideas in the
essay, then continue reading here! If you want to read the full essay (or save it for later),
you can get <a href="http://tomasp.net/academic/drafts/against-types/">the full version from here</a>.</p>



    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Thursday, 14 May 2015, 4:46 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/philosophy/">philosophy</a>, <a
              href="/blog/tag/research/">research</a>
        
        <br />
        <a href="http://tomasp.net/blog/2015/against-types/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/2014/philosophy-pl/">What can programming language research learn from the philosophy of science?</a></h1>
    <p>As someone doing programming language research, I find it really interesting to think
about <em>how</em> programming language research is done, how it has been done in the past
and how it <em>should</em> be done. This kind of questions are usually asked by philosophy
of science, but only a few people have discussed this in the context of computing
(or even programming languages).</p>
<p>So, my starting point was to look at the classic works in the general philosophy of science
and see which of these could tell us something about programming languages.</p>
<p>I wrote an article about some of these ideas and presented it last week at the
second symposium on <a href="http://www.computing-conference.ugent.be/hapop2">History and Philosophy of Programming</a>.
For me, it was amazing to talk with interesting people working on so many great
related ideas! Anyway, now that the paper has been published and I did a talk, I should
also share it on my blog:</p>
<ul>
<li>
<a href="http://tomasp.net/academic/papers/philosophy-pl/index.html">What can Programming Language Research Learn from the Philosophy of 
Science?</a>
</li>
<li>
Fairly minimalistic <a href="http://tomasp.net/academic/papers/philosophy-pl/philosophy-pl-aisb.pdf">slides from my talk at the 
symposium</a>
</li>
</ul>
<p>One feedback that I got when I submitted the paper to Onward! Essays last year was that
the paper uses a lot of philosophy of science terminology. This was partly the point of
the paper, but the feedback inspired me to write a more readable overview in a form of
blog post. So, if you want to get a quick peek at some of the ideas, you can also read
this short blog (and then perhaps go back to the paper)!</p>



    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Thursday, 10 April 2014, 6:16 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/philosophy/">philosophy</a>
        
        <br />
        <a href="http://tomasp.net/blog/2014/philosophy-pl/">Read the complete article</a><br /><br />
      </p>
    </div>
  

  <h1>All blog posts by tag</h1>
  
  <a
    href="/blog/tag/fsharp/">f# (112)</a>, <a
    href="/blog/tag/functional/">functional (66)</a>, <a
    href="/blog/tag/research/">research (50)</a>, <a
    href="/blog/tag/csharp/">c# (37)</a>, <a
    href="/blog/tag/academic/">academic (28)</a>, <a
    href="/blog/tag/asynchronous/">asynchronous (27)</a>, <a
    href="/blog/tag/programming-languages/">programming languages (23)</a>, <a
    href="/blog/tag/parallel/">parallel (23)</a>, <a
    href="/blog/tag/functional-programming/">functional programming (20)</a>, <a
    href="/blog/tag/universe/">universe (20)</a>, <a
    href="/blog/tag/meta-programming/">meta-programming (18)</a>, <a
    href="/blog/tag/philosophy/">philosophy (16)</a>, <a
    href="/blog/tag/links/">links (15)</a>, <a
    href="/blog/tag/presentations/">presentations (14)</a>, <a
    href="/blog/tag/thegamma/">thegamma (12)</a>, <a
    href="/blog/tag/data-science/">data science (12)</a>, <a
    href="/blog/tag/writing/">writing (12)</a>, <a
    href="/blog/tag/joinads/">joinads (12)</a>, <a
    href="/blog/tag/web/">web (11)</a>, <a
    href="/blog/tag/talks/">talks (9)</a>, <a
    href="/blog/tag/data-journalism/">data journalism (9)</a>, <a
    href="/blog/tag/math-and-numerics/">math and numerics (9)</a>, <a
    href="/blog/tag/random-thoughts/">random thoughts (9)</a>, <a
    href="/blog/tag/phalanger/">phalanger (8)</a>, <a
    href="/blog/tag/haskell/">haskell (7)</a>, <a
    href="/blog/tag/mono/">mono (7)</a>, <a
    href="/blog/tag/webcast/">webcast (7)</a>, <a
    href="/blog/tag/design/">design (6)</a>, <a
    href="/blog/tag/architecture/">architecture (5)</a>, <a
    href="/blog/tag/fslab/">fslab (5)</a>, <a
    href="/blog/tag/open-source/">open source (5)</a>, <a
    href="/blog/tag/type-providers/">type providers (4)</a>, <a
    href="/blog/tag/visualization/">visualization (4)</a>, <a
    href="/blog/tag/fun/">fun (4)</a>, <a
    href="/blog/tag/accelerator/">accelerator (4)</a>, <a
    href="/blog/tag/linq/">linq (3)</a>, <a
    href="/blog/tag/fsharp-data/">f# data (3)</a>, <a
    href="/blog/tag/dotnet/">.net (3)</a>, <a
    href="/blog/tag/training/">training (2)</a>, <a
    href="/blog/tag/coeffects/">coeffects (2)</a>, <a
    href="/blog/tag/deedle/">deedle (2)</a>, <a
    href="/blog/tag/monads/">monads (2)</a>, <a
    href="/blog/tag/art/">art (2)</a>, <a
    href="/blog/tag/fractals/">fractals (2)</a>, <a
    href="/blog/tag/funscript/">funscript (2)</a>, <a
    href="/blog/tag/new-york/">new york (2)</a>, <a
    href="/blog/tag/manning/">manning (2)</a>, <a
    href="/blog/tag/books/">books (2)</a>
</article>


  <footer>
  <div class="footer-body">
    <div class="fl70"><div class="fmr">
      <h4><a href="http://tomasp.net/rss.xml"><i class="fa fa-rss" style="margin-right:5px;"></i></a> Blog archives</h4>
      <p>
      
      <a href="/blog/archive/february_2025/">February 2025 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2023/">December 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2023/">February 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2022/">September 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2022/">April 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2021/">October 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2021/">April 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2020/">October 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2020/">July 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2020/">April 2020 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2019/">December 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2019/">February 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2018/">November 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2018/">October 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2018/">May 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2017/">September 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2017/">June 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2017/">April 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2017/">March 2017 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2017/">January 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2016/">October 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2016/">September 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/august_2016/">August 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2016/">July 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2016/">May 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2016/">April 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2015/">December 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2015/">November 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2015/">September 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2015/">July 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2015/">June 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2015/">May 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2015/">April 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2015/">March 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2015/">February 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2015/">January 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2014/">December 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2014/">May 2014 (3)</a>,&nbsp;
      
      <a href="/blog/archive/april_2014/">April 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2014/">March 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2014/">January 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2013/">December 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2013/">November 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2013/">October 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2013/">September 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2013/">August 2013 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2013/">May 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2013/">April 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2013/">March 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2013/">February 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2013/">January 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2012/">December 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/october_2012/">October 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2012/">August 2012 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2012/">June 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2012/">April 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2012/">March 2012 (4)</a>,&nbsp;
      
      <a href="/blog/archive/february_2012/">February 2012 (5)</a>,&nbsp;
      
      <a href="/blog/archive/january_2012/">January 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2011/">November 2011 (5)</a>,&nbsp;
      
      <a href="/blog/archive/august_2011/">August 2011 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2011/">July 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/june_2011/">June 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2011/">May 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2011/">March 2011 (4)</a>,&nbsp;
      
      <a href="/blog/archive/december_2010/">December 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2010/">November 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2010/">October 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/september_2010/">September 2010 (4)</a>,&nbsp;
      
      <a href="/blog/archive/july_2010/">July 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2010/">June 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2010/">May 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2010/">February 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2010/">January 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/december_2009/">December 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2009/">July 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2009/">June 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2009/">May 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2009/">April 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2009/">March 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2009/">February 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2008/">December 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2008/">November 2008 (5)</a>,&nbsp;
      
      <a href="/blog/archive/october_2008/">October 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2008/">September 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2008/">June 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2008/">March 2008 (3)</a>,&nbsp;
      
      <a href="/blog/archive/february_2008/">February 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2007/">December 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2007/">November 2007 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2007/">October 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2007/">September 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2007/">August 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2007/">July 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2007/">April 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2007/">March 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2007/">February 2007 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2007/">January 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2006/">November 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2006/">October 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/august_2006/">August 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/july_2006/">July 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2006/">June 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2006/">May 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2006/">April 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2005/">December 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2005/">July 2005 (4)</a>,&nbsp;
      
      <a href="/blog/archive/june_2005/">June 2005 (5)</a>,&nbsp;
      
      <a href="/blog/archive/may_2005/">May 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2005/">April 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2005/">March 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2005/">January 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2004/">December 2004 (3)</a>,&nbsp;
      
      <a href="/blog/archive/november_2004/">November 2004 (2)</a>,&nbsp;
      
      </p>
    </div></div>
    <div class="fr30"><div class="fmr">
      <h4>License and about</h4>
      <p>All articles on this site are licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share Alike</a>.
        All source code samples are licensed under the MIT License.
      </p>
      <p>This site is hosted on GitHub and is generated using <a href="https://github.com/tpetricek/FSharp.Formatting">F# Formatting</a>
        and <a href="http://dotliquidmarkup.org/">DotLiquid</a>.
        For more info, see the <a href="https://github.com/tpetricek/tomasp.net">website source on GitHub</a>.
      </p>
      <p>Please submit issues &amp; corrections on GitHub. Use pull requests for minor corrections only.</p>
      <ul>
        <li><i class="fab fa-twitter"></i> Twitter: <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a></li>
        <li><i class="fab fa-github"></i> GitHub: <a href="https://github.com/tpetricek">@tpetricek</a></li>
        <li><i class="fa fa-envelope"></i> Email: <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a></li>
      </ul>
      <p style="text-align:center;margin-top:15px;"><img src="https://tomasp.net/img/cc-sa.png" alt="CC License logo" /></p>
    </div></div>
  </div>
  </footer>

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-1561220-1']);
    _gaq.push(['_trackPageview']);
    (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</body>
</html>
