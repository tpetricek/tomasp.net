<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <meta name=viewport content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Droid+Sans+Mono&family=Kreon:wght@300;400;500;600&family=PT+Sans:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="alternate" type="application/rss+xml" title="Latest news from Tomas Petricek" href="/rss.xml" />
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <link href="/custom/style.css" rel="stylesheet">
  <link href="/custom/tooltips.css" rel="stylesheet">
  <script src="/custom/tooltips.js" type="text/javascript"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon-big.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/img/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/img/favicon-big.png">
  <meta name="msapplication-TileColor" content="#004C6B">
  <meta name="msapplication-TileImage" content="/img/favicon-big.png">
  <meta name="theme-color" content="#004C6B">
  
  <title>Tagged asynchronous - Latest writings from my blog - Tomas Petricek</title>
  <meta name="description" content="Tomas Petricek's latest blog posts about programming languages and tools, working with data, philosophy of science and more." />
  <meta name="author" content="Tomas Petricek" />
  <meta name="copyright" content="Tomas Petricek" />

</head>
<body class="default">
  
<span class="tplink"><a href="/">TP</a></span>

<article>
  
    <h1><a href="http://tomasp.net/blog/agent-event-reporting.aspx/">Reporting events from F# Agents</a></h1>
    
<p>Over the last year, I wrote quite a lot of articles about agent-based programming in F#.
Agents (inspired by Erlang) provide a great abstraction for writing concurrent and scalable
systems. They are a great fit for both server-side development (for example, handling 
a large number of concurrent requests), but also for user interface (for example, keeping
state in an application with background tasks and interactive interface).</p>

<p>When writing reusable agents, we usually encapsulate agent in an F# object type. The 
type provides methods for sending messages to the agent. However, sometimes the agent
also needs to report some state change that can be handled by another interested agent.
This is done using F# events. However, F# events do not specify threading behaviour, 
so there is a number of options.</p>

<p>In this article (inspired by a recent email discussion), I describe three ways of 
reporting events from an agent. The options differ in what thread is used to report the
event. Choosing the right option is important as it affects scalability and simplicity
of your agent-based code.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Saturday, 16 June 2012, 12:23 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/fsharp/">f#</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>
        
        <br />
        <a href="http://tomasp.net/blog/agent-event-reporting.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/joinads-async-implement.aspx/">TryJoinads (VII.) - Implementing joinads for async workflows</a></h1>
    
<p>The article <a href="http://tomasp.net/blog/joinads-async-prog.aspx">Asynchronous workflows and joinads</a> gives numerous
examples of programming with asynchronous workflows using the <code>match!</code> construct.
Briefly, when matching on multiple asynchronous workflows, they are executed in 
parallel. When pattern matching consists of multiple clauses, the clause that matches
on computations that complete first gets executed. These two behaviours are 
implemented by the <code>Merge</code> and the <code>Choose</code> operation of joinads. Additionally, 
asynchronous workflows require the <code>Alias</code> operation, which makes it possible to 
share the result of a started asynchronous workflow in multiple clauses.</p>

<p>In this article, we look at the definition of the additional <code>AsyncBuilder</code>
operations that enable the <code>match!</code> syntax. We do not look at additional examples
of using the syntax, because these can be <a href="http://tomasp.net/blog/joinads-async-prog.aspx">found in a previous article</a>.</p>

<p><em><strong>Note:</strong> This blog post is a re-publication of a tutorial from the <a href="http://tryjoinads.org">TryJoinads.org</a>
web page. If you read the article there, you can run the examples interactively
and experiment with them: <a href="http://tryjoinads.org/index.html?implement/async.html">view the article on TryJoinads</a>.</em></p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Friday, 23 March 2012, 5:21 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>, <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/joinads/">joinads</a>
        
        <br />
        <a href="http://tomasp.net/blog/joinads-async-implement.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/qcon-async-fsharp.aspx/">Asynchronous client/server in F# (QCon 2012)</a></h1>
    
<img src="http://tomasp.net/articles/qcon-async-fsharp/qcon.png" alt="Qcon" class="rdecor" />

<p>Last week, I gave a talk on asynchronous programming in F# at <a href="http://qconlondon.com/london-2012">London QCon 2012</a>.
The talk was a part of <a href="http://qconlondon.com/london-2012/tracks/show_track.jsp?trackOID=560">The Rise of Scala &amp; Functional Programming</a> 
track organized by Charles Humble. Reactive and asynchronous programming was a topic that was repeated
a couple of times during the whole session - Sadek Drobi talked about <a href="http://qconlondon.com/london-2012/presentation/Non%20blocking,%20composable%20reactive%20web%20programming%20with%20Iteratees%20in%20Play2">non-blocking reactive web framework
Play2</a>
and Damien Katz talked about <a href="http://qconlondon.com/london-2012/presentation/Erlang%20in%20the%20real%20world:%20CouchDB">Erlang and CouchDB</a>.</p>

<p>I used the one hour slot to implement "Rectangle Drawing App" - a simple application that 
shows how to write complete client-server application just using F#. On the
server-side, I used asynchronous workflows to write HTTP server with an F#
agent. On the client-side, I used asynchronous workflows to express user
interface logic and the <a href="http://pitfw.org/">Pit project</a> to run F# code as
JavaScript that works everywhere. The app definitely had a huge commercial potential:</p>

<div style="text-align:center">
<img src="http://tomasp.net/articles/qcon-async-fsharp/quote.png" alt="Quote" />
</div>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 12 March 2012, 1:09 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/presentations/">presentations</a>, <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>, <a
              href="/blog/tag/links/">links</a>
        
        <br />
        <a href="http://tomasp.net/blog/qcon-async-fsharp.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/joinads-join-calculus.aspx/">TryJoinads (IV.) - Concurrency using join calculus</a></h1>
    
<p>Join calculus provides a declarative way of expressing asynchronous synchronization
patterns. It has been use as a basis for programming languages (JoCaml and COmega), but also
as a basis for libraries (embedded in C# and Scala). Using joinads, it is possible to 
embed join calculus in F# with a nice syntax using the <code>match!</code> construct. Formally,
join calculus does not form a <em>monad</em>, but it can be viewed as a version of <em>joinad</em>
as described in the <a href="../pubs.html">first paper on joinads</a>.</p>

<p>The programming model is based on <em>channels</em> and <em>join patterns</em>. A channel can be viewed
as a thread-safe mailbox into which we can put values without blocking the caller. In some
sense, this is quite similar to <a href="agents.html">F# agents</a>. A join pattern is then a rule
saying that a certain combination of values in channels should trigger a specific reaction
(and remove values from the channels). The ability to match on multiple channels distinguishes
join calculus from F# agents.</p>

<p><em><strong>Note:</strong> This blog post is a re-publication of a tutorial from the <a href="http://tryjoinads.org">TryJoinads.org</a>
web page. If you read the article there, you can run the examples interactively
and experiment with them: <a href="http://tryjoinads.org/index.html?use/joins.html">view the article on TryJoinads</a>.</em></p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Wednesday, 22 February 2012, 5:38 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/fsharp/">f#</a>, <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/joinads/">joinads</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/parallel/">parallel</a>
        
        <br />
        <a href="http://tomasp.net/blog/joinads-join-calculus.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/joinads-agents.aspx/">TryJoinads (III.): Agent-based programming</a></h1>
    
<p>Another area where the <code>match!</code> syntax can be used is when programming with F# <em>agents</em>,
implemented by the <code>MailboxProcessor</code> type. Formally, agents do not form the monad
structure in a useful way - when programming with agents, we do not compose a new agents,
but instead we write code that (imperatively) receives messages from the agent's mailbox
and handles them.</p>

<p>This article demonstrates an <code>agent { ... }</code> computation builder that can be used for 
implementing the body of an agent. Normally, the body of an agent is an <em>asynchronous
workflow</em>. The code in the body uses <code>let!</code> to perform asynchronous operations, most 
importantly to call <code>inbox.Receive</code> to get the next message from the inbox. When the
agent intends to handle only certain kinds of messages, it can use <code>inbox.Scan</code>. When
using the <code>agent</code> builder, pattern matching on messages can be written using <code>match!</code> and
it is possible to write code that ignores certain types of messages simply by writing an
incomplete pattern matching.</p>

<p><em><strong>Note:</strong> This blog post is a re-publication of a tutorial from the <a href="http://tryjoinads.org">TryJoinads.org</a>
web page. If you read the article there, you can run the examples interactively
and experiment with them: <a href="http://tryjoinads.org/index.html?use/agents.html">view the article on TryJoinads</a>.</em></p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 20 February 2012, 12:36 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/joinads/">joinads</a>, <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/fsharp/">f#</a>, <a
              href="/blog/tag/parallel/">parallel</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>
        
        <br />
        <a href="http://tomasp.net/blog/joinads-agents.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/introducing-tryjoinads.aspx/">Introducing TryJoinads.org</a></h1>
    
<div class="rdecor" style="text-align:center">
  <a href="http://tomasp.net/articles/introducing-tryjoinads/screen.png" target="_blank">
    <img src="http://tomasp.net/articles/introducing-tryjoinads/screen-sm.png" alt="TryJoinads.Org web site" style="border:none" />
  </a><br />
  <small>(<a href="http://tomasp.net/articles/introducing-tryjoinads/screen.png" target="_blank">Click for a larger version</a>)</small>
</div>

<p>If you have been following my blog, you've probably already heard of <em>joinads</em>. It is
a research extension of F# computation expressions (or monads in Haskell). The extension
makes computation expressions more useful in domains like parallel, concurrent and reactive
programming. However, it can be used for any type of computation including, for example, parsers.
If you're interested in detailed description, you can find it in two academic papers that
I blogged about previously: <a href="http://tomasp.net/blog/match-bang-paper.aspx">PADL 2011</a> and <a href="http://tomasp.net/blog/docase-haskell.aspx">Haskell 2011</a>.</p>

<p>The extension adds a keyword <code>match!</code> - as the syntax suggests, it is akin to pattern
matching using <code>match</code>, but instead of pattern matching on values, you can pattern match
on computations like <code>Async&lt;'T&gt;</code> (or on other monadic values). Just like other features of
computation expressions, the <code>match!</code> syntax is translated to applications of several
methods defined by the computation builder.</p>

<p>I won't say more about joinads in this post, because you can now easily try joinads yourself...</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 13 February 2012, 4:21 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/parallel/">parallel</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>, <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/links/">links</a>, <a
              href="/blog/tag/joinads/">joinads</a>
        
        <br />
        <a href="http://tomasp.net/blog/introducing-tryjoinads.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/async-sequences.aspx/">Programming with F# asynchronous sequences</a></h1>
    
<img src="http://tomasp.net/articles/async-sequences/decor.png" class="rdecor" />

<p>In F#, we can represent asynchronous operations that do not block threads and eventually
  return a value of type <code>'T</code> using asynchronous workflows <code>Async&lt;'T&gt;</code>.
  Asynchronous workflows can be easily constructed using the computation expression syntax
  <code>async { ... }</code> and there are also a few combi&#173;nators that express more advanced
  composition (such as parallel composition or fork-join parallelism).</p>

<p>Sometimes, we need to use asynchronous operations that return more than just one value.
  For example, when downloading data from the internet, we would like to create an 
  <em>asynchronous sequence</em> that returns the data in chunks as they become available.</p>

<p>One way to represent asynchronous operations that produce multiple values is to use 
  the <code>IObservable&lt;'T&gt;</code> type from .NET. This isn't always the best option 
  though. Observables implement <em>push-based</em> model, which means that chunks of data are
  generated as quickly as possible (until all chunks are emitted). What if we wanted to take 
  the chunks one-by-one after the previous chunk is processed?</p>

<p>In this article, I describe <em>asynchronous sequences</em>. An asynchronous sequence is a simple,
  yet very powerful concept based on asynchronous workflows. It follows the same core model: results 
  are generated on demand and asynchronously. Unlike asynchronous workflows, asynchronous sequences
  can be called (on demand) to generate multiple values until the end of the sequence is reached.</p>

<p style="font-style:italic">I first discussed asynchronous sequences with Don Syme, Dmitry Lomov and Brian McNamara in an
  email thread a long time ago. Thanks to Don for enthusiasm about the concept and for the 
  first implementation of some of the combinators!</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Thursday, 11 August 2011, 11:30 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>, <a
              href="/blog/tag/research/">research</a>
        
        <br />
        <a href="http://tomasp.net/blog/async-sequences.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/real-world-book-msdn.aspx/">Real-World F# Articles on MSDN</a></h1>
    
<img src="http://tomasp.net/articles/real-world-book-msdn/msdn.jpg" style="float:right;margin:0px 15px 15px 15px;" />
<p>More than a year ago, Mike Stephens from <a href="http://manning.com">Manning</a> (who
 was also behind my <a href="http://manning.com/petricek">Real-World Functional Programming</a>
 book) asked me if I'd be interested in collaborating on a project for MSDN. The idea 
 was to collaborate with Microsoft on creating some additional content for the official
 <a href="http://msdn.microsoft.com/library/dd233154(VS.100).aspx">F# Documentation</a>.</p>

<p>A few days ago, the new content appeared on MSDN, so I finally have an excuse for the
  recent lack of blogging! Although the content contains a large number of new articles
  that are not based on my book, you can find it in the MSDN section named after my
  book, right under <em>Visual F#</em>. If you can't wait to check it out, here are all the links:</p>

<ul>
  <li>The <a href="http://msdn.microsoft.com/en-us/library/hh314518.aspx">Real-World Functional Programming</a> section on MSDN.</li>
  <li>The <a href="http://code.msdn.microsoft.com/site/search?query=tomas%20petricek&amp;f%5B0%5D.Value=tomas%20petricek&amp;f%5B0%5D.Type=SearchText&amp;ac=8">source code for individual chapters</a> is available on MSDN Code Gallery.</li>
  <li>I also published <a href="http://functional-programming.net/msdn/">annotated TOC with source code links</a> on my functional programming web site.</li>
</ul>

<p>While working on the articles, I also wrote about a few topics that we didn't use in the final version. You'll see them on my blog in the next few days, as soon as I edit them into a blog post form. <a href="http://tomasp.net/blog/real-world-book-msdn.aspx">Continue reading</a> for more information about individual chapters.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Wednesday, 10 August 2011, 4:38 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/web/">web</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/parallel/">parallel</a>, <a
              href="/blog/tag/links/">links</a>, <a
              href="/blog/tag/fsharp/">f#</a>, <a
              href="/blog/tag/csharp/">c#</a>
        
        <br />
        <a href="http://tomasp.net/blog/real-world-book-msdn.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/safe-gui-async.aspx/">Safer asynchronous workflows for GUI programming</a></h1>
    
<img src="http://tomasp.net/articles/safe-gui-async/screen.png" style="float:right; margin:0px 0px 0px 15px;" />

<p>In the <a href="http://tomasp.net/blog/async-non-blocking-gui.aspx">previous article</a>,
  I discussed how to use F# asynchronous work&#173;flows for creating reactive user-interfaces.
  One of the main concerns was to avoid blocking the GUI thread (to prevent the user-interface
  from freezing). The workflow shouldn't perform any CPU-intensive compu&#173;tation when running
  on the GUI thread.</p>

<p>The standard F# library provides two ways to run a computation on a background thread from
  an asynchronous workflow. The <code>StartChild</code> operation starts an operation 
  in the thread pool and returns a workflow that can be called using asynchronous (non-blocking)
  <code>let!</code> construct. The <code>SwitchToThreadPool</code> operation can be called
  using <code>do!</code> and resumes the rest of the workflow on a background thread.</p>

<p>When using the <code>SwitchToThreadPool</code> operation, we also need to eventually use
  <code>SwitchToContext</code> to transfer the execution back to the GUI thread (after 
  completing the CPU-intensive calculations). In this article, I describe a variation of 
  F# asynchronous workflows that keeps track of the running thread in the type of the 
  computation. As a result, calling a workflow that should be executed on a GUI thread 
  from a background thread is a compile-time error as opposed to failing at runtime.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Wednesday, 15 June 2011, 9:36 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/fsharp/">f#</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/functional/">functional</a>
        
        <br />
        <a href="http://tomasp.net/blog/safe-gui-async.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/async-non-blocking-gui.aspx/">Writing non-blocking user-interfaces in F#</a></h1>
    
<img src="http://tomasp.net/articles/async-non-blocking-calls/screen.png" style="float:right; margin:0px 0px 0px 15px;" />

<p>F# asynchronous workflows are best known as a way to write efficient I/O operations
  or as an underlying mechanism of F# agent-based programming (using the <code>MailboxProcessor</code>
  type). However, they are also very useful for user-interface programming. I think this is 
  a very interesting and important area, so I already wrote and talked about this topic - 
  it is covered in <a href="http://manning.com/petricek/">Chapter 16 of my book</a> (there
  is a <a href="http://dotnetslackers.com/articles/net/Programming-user-interfaces-using-f-sharp-workflows.aspx">free excerpt</a>)
  and I <a href="http://tomasp.net/blog/reactive-talk.aspx">talked about it</a> at F#unctional Londoners
  meeting.</p>

<p>Many applications combine user-interface programming (such as waiting for an event asynchronously)
  with some CPU-intensive tasks. This article looks at an example of such application and I'll explain 
  how to avoid blocking the user-interface when doing the CPU-intensive task. 
  The article starts with an example that is wrong and blocks the user-interface when doing data processing.
  Then I'll show you two options for fixing the problem. The three most important
  functions from the standard F# library that I'll discuss are <code>Async.StartChild</code> and 
  <code>Async.SwitchTo&#173;ThreadPool</code> with <code>Async.SwitchToContext</code>.</p>

<p>This is the first article of a mini-series. In the next article, I'll demonstrate a simple
  wrapper for F# <code>async</code> that makes it more difficult to write <em>wrong</em> 
  programs. The wrapper keeps the desired thread (GUI or background) in the type of the 
  computations and code that would block the user interface will not type-check. But first,
  let's look at the example...</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Friday, 10 June 2011, 11:36 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/research/">research</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>, <a
              href="/blog/tag/functional/">functional</a>
        
        <br />
        <a href="http://tomasp.net/blog/async-non-blocking-gui.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/async-compilation-internals.aspx/">Asynchronous C# and F# (III.): How does it work?</a></h1>
    
<p>Some time ago, I started writing a series about the differences between the asynchronous model in F# 
  (in Visual Studio 2010) and the asynchronous language extensions for C# proposed at PDC 2010.
  In the <a href="http://tomasp.net/blog/csharp-fsharp-async-intro.aspx">first article</a>, I showed
  how both of the language features look and I highlighted a couple of differences. In the
  <a href="http://tomasp.net/blog/async-csharp-differences.aspx">second article</a>, I discussed
  the support for cancellation (available only in F#) and how the two models differ 
  <em>semantically</em> (i.e. what are differences in the behaviour). However, I didn't talk about more
  techincal differences and, in particular, how is the asynchronous code compiled. We'll look 
  at this topic today...</p>

<p>Although the C# asynchronous programming model is very similar to F# asynchronous workflows,
  the compilation looks quite different. The C# compiler uses a similar technique as when compiling
  iterators and creates a state machine, while the F# compiler uses an approach based on higher order
  functions (combinators) that's shared with (most) other computation expressions.</p>

<p>I won't discuss the syntax of F# asynchronous workflows or the C# asynchronous extensions in 
  this article, so if you're new to one of these, here are links to other articles in this 
  series: </p>
<ul>
  <li><a href="http://tomasp.net/blog/csharp-fsharp-async-intro.aspx">Asynchronous C# and F# (I.): Simultaneous introduction</a></li>
  <li><a href="http://tomasp.net/blog/async-csharp-differences.aspx">Asynchronous C# and F# (II.): How do they differ?</a></li>
  <li><strong>Asynchronous C# and F# (III.): How does it work?</strong></li>
  <li>Asynchronous C# and F# (IV.): Calling F# libraries from C# <em>(not yet available)</em></li>
</ul>  

<p>Let's start by looking at the mechanism used in the C# compiler. If you already know how
  iterators work in C# 2.0, then you'll find it quite easy to understand. If you're not familiar
  with iterators, then don't worry - I'll make the explanation self-contained.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Sunday, 21 November 2010, 3:15 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/csharp/">c#</a>, <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/async-compilation-internals.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/async-csharp-differences.aspx/">Asynchronous C# and F# (II.): How do they differ?</a></h1>
    
<p>Anders Hejlsberg announced the support for asynchronous programming in the next version of C# announced at PDC 2010.
  The extension looks very similar to F# asynchronous workflows (which are already available in Visual Studio 2010). 
  Despite the large similarity, there are a couple of differences between the two programming models. I already mentioned 
  some of them briefly in <a href="http://tomasp.net/blog/csharp-fsharp-async-intro.aspx">the first article of this series</a>.
  In this article, we'll look at some of the technical differences between the two models.</p>

<p>The most notable non-technical difference is that F# asynchronous workflows are already available in a 
  supported version of Visual Studio and can be used on a large number of .NET runtimes (including, for example,
  Windows Phone and Silverlight). However, there are surprisingly many technical differences as well.
  In this article, I'll talk about the support for cancellation, which is available in F# and is not
  (currently) available in the C# preview. We'll also look at the difference between model where tasks
  are created as running and the delayed model.</p>

<p>This article is the second part of a short series about the asynchronous programming support
  in C# and F#. The previous article shows a simple example in both of the languages and the next
  articles explain how does the feature work (and how you can customize its behavior) as well as 
  how to call F# libraries from C#:</p>
<ul>
  <li><a href="http://tomasp.net/blog/csharp-fsharp-async-intro.aspx">Asynchronous C# and F# (I.): Simultaneous introduction</a></li>
  <li><strong>Asynchronous C# and F# (II.): How do they differ?</strong></li>
  <li><a href="http://tomasp.net/blog/async-compilation-internals.aspx">Asynchronous C# and F# (III.): How does it work?</a></li>
  <li>Asynchronous C# and F# (IV.): Calling F# libraries from C# <em>(not yet available)</em></li>
</ul>  
<p>Let's start by looking at, perhaps, the most important technical difference - the 
  built-in support for cancellation available in F# asynchronous workflows.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 1 November 2010, 4:36 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/csharp/">c#</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/async-csharp-differences.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/csharp-fsharp-async-intro.aspx/">Asynchronous C# and F# (I.): Simultaneous introduction</a></h1>
    
<img src="http://tomasp.net/articles/csharp-fsharp-async-intro/pdc2010.png" style="float:right;margin:5px;margin-left:20px;" />
<p>One of the exciting new technologies that was announced at <a href="http://www.microsoftpdc.com/">PDC 2010</a>
  is the support for <em>asynchronous programming</em> in C#. So what exactly is <em>asynchronous programming</em>?
  Many applications today need to connect to some service or external data source including, for example, 
  Web Services and REST APIs. These calls may take a long time to run, but we want to run them without
  blocking the application.</p>

<p>Currently, you can run the operation on a background thread or using a <code>Task</code>, but
  coordinating multiple such operations is difficult. What if you for example need to wait until
  any (or all) of downloads complete and run some more code then? This is not only difficult, but
  it also scales badly, because blocking .NET threads is a bad practice (Threads are expensive and when
  they're just waiting for other operation to complete, we're wasting valuable resources).
  This problem has been the main motivation for including <em>asynchronous workflows</em> in F#
  about 3 years ago. In F#, this also enabled various interesting programming styles - for example
  <a href="http://dotnetslackers.com/articles/net/Programming-user-interfaces-using-f-sharp-workflows.aspx" type="external">creating 
  GUI using asynchronous workflows</a> (also discussed in Chapter 16 of <a href="http://manning.com/petricek">my book</a> and in 
  in <a href="http://tomasp.net/blog/reactive-talk.aspx">my recent talk</a>). The C# asynchronous 
  programming support and the <code>await</code> keyword is largely inspired by
  F# <em>asynchronous workflows</em> (I was quite surprised that F# wasn't more visibly 
  mentioned in the PDC talk).
</p>

<p>In this article series, I'll demonstrate both F# and C# asynchronous programming model,
  I'll look at features that are missing in one or the other as well as a few subtle differences
  (that may be unexpected) and finally, I'll write about writing (asynchronous) F# libraries 
  that are easy to use from C#. The plan for the series is following:</p>
<ul>
  <li><strong>Asynchronous C# and F# (I.): Simultaneous introduction</strong></li>
  <li><a href="http://tomasp.net/blog/async-csharp-differences.aspx">Asynchronous C# and F# (II.): How do they differ?</a></li>
  <li><a href="http://tomasp.net/blog/async-compilation-internals.aspx">Asynchronous C# and F# (III.): How does it work?</a></li>  <li>Asynchronous C# and F# (IV.): Calling F# libraries from C# <em>(not yet available)</em></li>
</ul>  
<p>Let's start with a brief overview of asynchronous programming features in C# and F#...</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Friday, 29 October 2010, 4:34 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/csharp/">c#</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/csharp-fsharp-async-intro.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/parallel-extra-adash-cancellation.aspx/">F# Parallel Extras (III.): Financial dashboard with cancellation</a></h1>
    
<p>In this article we'll look at several improvements that can be done to the Financial dashboard example
  (originally from the <a href="http://parallelpatterns.codeplex.com/" type="external">Parallel Programming with Microsoft .NET</a> book).
  When I was translating samples in the book from C# to F#, the sample struck me, because it looks like
  a perfect fit for F# asynchronous workflows (instead of the <code>Task&lt;T&gt;</code> type used in the
  C# version). I already talked about an <a href="http://tomasp.net/blog/fsharp-parallel-adash.aspx">alternative 
  implementation</a> based on asynchronous workflows. However that version was still following some of the
  programming patterns, from the original C# version, which are not idiomatic in F#. In this article, I'll talk
  about a few other improvements that we can make to the sample...</p>

<p>In the original version of the sample (in both C# and F#), we explicitly checked whether a cancellation
  token has been cancelled in every single operation. This was needed in C#, because tasks do not support
  cancellation automatically. However, F# asynchronous workflows make cancellation easier. They automatically
  check if the computation should be cancelled at the beginning and the end of every asynchronous call. Our
  first change will be to use this feature. Also, the original version propagates a <code>null</code> value
  when the computation is cancelling. In F# we don't need that and we'll only change the type of the overall
  result to <code>option&lt;T&gt;</code>, so that we can notify the user interface (but we don't need to 
  propagate cancellation explicitly). Finally, the original version contained sequential implementation, but
  didn't provide any way of actually running it, so we'll do a bit of refactoring to make that sample 
  actually useable.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Wednesday, 27 October 2010, 11:13 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/parallel/">parallel</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/parallel-extra-adash-cancellation.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/parallel-extra-blockingagent.aspx/">F# Parallel Extras (II.): Agent-based blocking queue</a></h1>
    
<p>In the <a href="http://tomasp.net/blog/parallel-extra-image-pipeline.aspx">previous article</a>, we 
  briefly introduced the <code>BlockingQueueAgent&lt;T&gt;</code> type and we used it to implement the
  pipeline pattern (from Chapter 7 of <a href="http://parallelpatterns.codeplex.com/" type="external">Parallel Programming with Microsoft .NET</a>)
  using asynchronous workflows. The type was used to represent intermediate buffers with a limited size.
  In this article we'll take a look at the implementation of the type. The type implements a very useful
  pattern in agent-based parallel programming, so you can use it in your work, but it could be also 
  interesting as a demonstration of the F# <code>Agent&lt;T&gt;</code> type (an recommended alias 
  for the <code>MailboxProcessor&lt;T&gt;</code> type).</p>
<p>The <code>BlockingQueueAgent&lt;T&gt;</code> type is similar to <code>BlockingCollection&lt;T&gt;</code> 
  from .NET 4.0. It has methods for adding and removing elements that block when the operation cannot be
  done (e.g. adding when the queue is full or removing when the queue is empty). The most important 
  difference is that it can be used <em>asynchronously</em>. This means that when we call its operations
  form F# asynchronous workflow (using <code>let!</code> and <code>do!</code>), the operation will block
  the calling workflow, but it will not block any physical thread. We start by looking at the overall
  structure of the agent and then look at the body of the agent which implements its behavior (using
  a state machine)...</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Wednesday, 27 October 2010, 11:12 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/parallel/">parallel</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/parallel-extra-blockingagent.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/parallel-extra-image-pipeline.aspx/">F# Parallel Extras (I.): Image pipeline using agents</a></h1>
    
<p>In a <a href="http://tomasp.net/blog/fsharp-parallel-samples.aspx">recent blog post series</a>,
  I wrote about parallel programming samples that accompany the 
  <a href="http://parallelpatterns.codeplex.com/" type="external">Parallel Programming with Microsoft .NET</a>
  book by patterns &amp; practices group at Microsoft. The F# translation of the samples that I
  wrote about mostly followed the style used in the book, so it used patterns that 
  are typical for C#. However, some of the samples can be written in F# in a more interesting way...</p>
<p>In this article, we'll take a look at agent-based implementation of the Image pipeline 
  example (from chapter 7). A <em>pipeline</em> is a useful pattern if you need to process large
  number of inputs in parallel and the processing consists of multiple phases or steps. In the
  original implementation, the pipeline was implemented using <code>BlockingCollection&lt;T&gt;</code>
  and <code>Task&lt;T&gt;</code> types from .NET 4.0.</p>
<p>In this article, I'll show a 
  version that uses F# agents and asynchronous workflows. We'll use a <code>BlockingQueueAgent&lt;T&gt;</code> 
  type, which is <a href="http://tomasp.net/blog/parallel-extra-blockingagent.aspx">discussed in another 
  article</a>. It represents a queue with limited capacity that asynchronously blocks the process that is adding 
  values if there is no space in the buffer and blocks the process that reads values when there are no 
  values. This type can be elegantly used to implement the pipeline pattern. In this article, we'll 
  demonstrate it by writing a four-phase pipeline that processes images. As you'll see, 
  the agent-based version of the code is very much easier to write and has similar performance as 
  the original version.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Wednesday, 27 October 2010, 11:11 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/parallel/">parallel</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/parallel-extra-image-pipeline.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/fsharp-parallel-adash.aspx/">Parallel Programming in F# (IV.): Financial dashboard example</a></h1>
    
<p>In the fourth part of the Parallel Programming in F# series, we'll take a look at the Adatum Financial 
  Dashboard sample. The sample is a part of <a href="http://parallelpatterns.codeplex.com/" type="external">Parallel 
  Programming with Microsoft .NET</a>, which is a guide that introduces common parallel programming patterns
  on .NET 4.0. The C# version of the sample is in details discussed in the guide, but the F# translation
  contains several additional interesting aspects that I'll introduce in this article.</p>

<p>The sample simulates a financial modelling application that performs processing of market
  data in several steps that can be partly executed in parallel. In this article we'll compare two
  implementations. The first one (similar to the C# version) uses the <code>Task&lt;'T&gt;</code> type 
  from .NET 4.0 and chains steps using the <code>ContinueWith</code> method. The second version is 
  F# specific and it implements step as a sequential computation wrapped in asynchronous 
  workflows. Partial results are reported to the user interface using events.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 6 September 2010, 10:30 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/parallel/">parallel</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/fsharp-parallel-adash.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/fsharp-parallel-samples.aspx/">Parallel Programming in F# (I.): Introducing the samples</a></h1>
    
<img src="http://tomasp.net/articles/fsharp-parallel-samples/book.png" style="float:right;margin:20px;"/>
<p><a href="http://parallelpatterns.codeplex.com/" type="external">Parallel Programming with Microsoft .NET</a> is a 
  guide written by the patterns &amp; practices group at Microsoft. It introduces .NET programmers to
  patterns for including parallelism in their applications (using support for parallel programming in
  .NET 4.0). It introduces techniques such as parallel loops, parallel tasks, data aggregation and so on.
  The book includes numerous samples in C# and Visual Basic that can be easily copied and adapted 
  to match your needs.</p>

<p>As part of a contracting work for the F# team, I developed an F# version of the samples, which is 
  now available on the <a href="http://parallelpatterns.codeplex.com/" type="external">book web site</a>.
  You can get it by downloading <a href="http://parallelpatterns.codeplex.com/releases/view/50473">F# code samples</a> (ZIP) from the 1.0 release, or you can download the <a href="http://parallelpatterns.codeplex.com/SourceControl/list/changesets" 
  type="external">latest version of the source code</a> directly. The F# version of the
  code is mostly a direct translation of the C# versions, but there are a few interesting places that
  are worth discussing. In particular, some of the samples use the <code>PSeq</code> module from F#
  PowerPack and I also added a version of one example that uses F# asynchronous workflows.</p>

<p>In this article series, I'll look at several interesting examples from the F# version of the source code.
  We'll look how to use PLINQ and Tasks (which are available in .NET 4.0) from F# (Part II.) including some advanced topics such 
  as the Map-Reduce algorithm (Part III.). We'll also look at a larger example built using tasks and an alternative 
  implementation using asynchronous workflows (Part IV.) Here are links to the individual articles:</p>

<ul>
  <li><strong>Parallel Programming in F# (I.): Introducing the samples</strong></li>
  <li><a href="http://tomasp.net/blog/fsharp-parallel-plinq.aspx">Parallel Programming in F# (II.): Using PLINQ and Tasks</a></li>
  <li><a href="http://tomasp.net/blog/fsharp-parallel-aggregate.aspx">Parallel Programming in F# (III.): Aggregating data</a></li>
  <li><a href="http://tomasp.net/blog/fsharp-parallel-adash.aspx">Parallel Programming in F# (IV.): Financial dashboard example</a></li>
</ul>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 6 September 2010, 10:00 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/parallel/">parallel</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/fsharp-parallel-samples.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/fsharp-webcast-objects.aspx/">F# Webcast (IV.) - Developing standard .NET libraries</a></h1>
    
<p>In the previous parts of this webcast series we've developed an F# script that downloads RSS feeds
  asynchronously and in parallel and searches them for the specified keywords. We followed the usual F#
  development style, so after introducing <a href="fsharp-webcast-functional.aspx">the basic functional 
  concepts</a>, we wrote the code in <a href="fsharp-webcast-dotnet.aspx">the simples possible style</a> 
  and demonstrated how to use <code>System.Xml</code> and <code>System.Net</code> namespaces. Then we 
  <a href="fsharp-webcast-async.aspx">refactored the existing code</a>, to run asynchronously and process
  the results potentially in parallel, which was very easy thanks to F# <em>asynchronous workflows</em>.</p>

<p>In this part of the series, we'll make the next evolutionary step of our sample application. We'll turn
  the code that originally used F# tuples and lists into code that uses standard .NET objects and we'll
  also see how to declare a class in F#. This simple modification will turn the script into an F# library
  that is almost indistinguishable from a library developed in C#. We'll also look how you can use the library
  from C# web application to show the interop between C# and F# in practice. We'll start
  with the code from the <a href="fsharp-webcast-async.aspx">previous part</a>, so if you missed that, you
  may want to check it out or download the source code.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 15 June 2009, 8:09 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/webcast/">webcast</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/fsharp-webcast-objects.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/fsharp-webcast-async.aspx/">F# Webcast (III.) - Using Asynchronous Workflows</a></h1>
    
<p>In this webcast, we'll look at improving the code for downloading and
  processing RSS feeds that I presented in <a href="fsharp-webcast-dotnet.aspx">the second part</a> 
  (if you didn't see earlier parts, <a href="fsharp-webcast-dotnet.aspx">the first one</a> was an introduction to 
  basic functional ideas). The previous part demonstrated how to use .NET libraries
  and we implemented a simple <code>downloadUrl</code> function for obtaining content
  of from the web and we've also seen how to load the data into an XML document object
  and how to filter items. In this part, we'll modify the code to run asynchronously and 
  potentially in parallel. To use some of the functionality, you'll need to get 
  <code>FSharp.PowerPack.dll</code>, which is available with the VS 2008 installation or
  as a separated download for VS 2010 [<a href="#fswc_asy">4</a>].
</p>

<p>Now that we have the first version of the code, we can start <em>refactoring</em> it.
  I'm using the term in a slightly vague meaning - we're of course going to change the
  behavior of the code. We'll wrap it into F# <em>asynchronous workflow</em> to run
  without blocking threads and we'll also run multiple downloads in parallel. However,
  this can still be viewed as refactoring in some sense, because we're not changing
  the <em>core</em> behavior of the code. As you can see from the webcast, these kinds of
  refactorings are also very nicely supported by F# syntax...</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Friday, 5 June 2009, 3:39 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/webcast/">webcast</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/fsharp-webcast-async.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/fsharp-webcast-dotnet.aspx/">F# Webcast (II.) - Using .NET libraries</a></h1>
    
<p>About a week ago I posted <a href="fsharp-webcast-functional.aspx">the first part</a> of my F# webcast series.
  It focused on explainining the basic ideas behind functional programming such as immutability, recursion
  and passing functions as arguments to other functions (or methods in C#). In the first part, we've seen some
  C# code to demonstrate the ideas and also a bit of F#, mainly to show the basic language features.
</p>

<p>The second part is going to be exclusively about F#. It'll demonstrate how we can start writing
  a demo application that grabs data from RSS feeds and processes them. You'll learn how to access
  .NET libraries from F# (in particular, we'll use <code>System.Net</code> and <code>System.Xml</code>).
  We'll develop the code iteratively, which means that we'll start by simply enumerating the RSS elements using <code>for</code> loop and printing the results and then we'll refactor the code to use <em>tuples</em> and <em>sequence expressions</em> to turn it into processing code that generates a sequence of feed items. Finally we'll also demonstrate how to use some of the functions from the previous part such as <code>List.filter</code> in practice.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 1 June 2009, 2:57 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/webcast/">webcast</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/fsharp-webcast-dotnet.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/fsharp-webcast-functional.aspx/">F# Webcast (I.) - Introducing functional concepts</a></h1>
    
<p>Now that <a href="http://www.microsoft.com/visualstudio/en-us/products/2010/default.mspx" type="external">Visual Studio 2010 Beta 1</a> is out, it is finally a good time to take a look at 
  one of the (in my opinion) most interesting new features in the new release - <a href="http://blogs.msdn.com/dsyme/archive/2009/05/20/visual-studio-2010-beta1-with-f-is-now-available-plus-matching-f-ctp-update-for-vs2008.aspx" type="external">the F# language</a>. F# existed for
  quite a long time now as Microsoft Research project, but is now becoming a real Microsoft product.
  Interestingly, F# is still available as a <a href="http://www.microsoft.com/downloads/details.aspx?displaylang=en&amp;FamilyID=7bb32f32-9fac-4f34-ad56-b0bda130cf00" type="external">plugin for Visual Studio 2008</a>, so if you want to try it
  you don't have to install the whole new beta of 2010.</p>

<p>There are already many resources for learning F# including my <a href="http://tomasp.net/blog/functional-overview.aspx">functional programming overview</a>,
  which is a Manning Greenpaper for the book <a href="http://www.functional-programming.net" type="external">Functional Programming for the Real World</a> that I'm writing with Jon Skeet
  and my <a href="http://tomasp.net/blog/fsharp-i-introduction.aspx">four-part F# introduction</a>. There are also some useful links on the 
  official <a href="http://www.fsharp.net">F# web site</a> including some talk recordings. However, I haven't yet seen any good F# webcast focusing 
  mainly on showing F# source code, starting from simple functional concepts to the real-world features like asynchronous workflows and object-oriented 
  programming in F#, so I decided to create one.</p>
<p style="text-indent:0px;"><strong>So, here it is...</strong></p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Monday, 25 May 2009, 1:39 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/webcast/">webcast</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/fsharp-webcast-functional.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/internship-match-bang.aspx/">Internship project: Reactive pattern matching</a></h1>
    
<a href="http://cid-6ddff5260c96e30a.skydrive.live.com/albums.aspx">
<img src="http://tomasp.net/articles/internship-match-bang/image.jpg" alt="Cambridge, 2009" class="ldecor" 
  style="border:0px;float:left; margin:20px" />
</a>

<p>I already <a href="http://tomasp.net/blog/book-source-available.aspx">mentioned</a> that I was doing my second internship
  with <a href="http://blogs.msdn.com/dsyme/" type="external">Don Syme</a> at Microsoft Research in Cambridge.
  This time, I was in Cambridge for 6 months from October until April, so it has been more than a month since 
  I left, but as you can guess I didn't have time to write anything about the internship until now... There isn't
  much to say though, because the internship was simply fantastic. Cambridge is a beautiful place (here are
  some <a href="http://cid-6ddff5260c96e30a.skydrive.live.com/browse.aspx/2008%20Autumn%20-%20Cambridge" type="external">autumn</a> and <a href="http://cid-6ddff5260c96e30a.skydrive.live.com/browse.aspx/2009%20Winter%20-%20Cambridge" type="external">winter</a> photos),
  the Microsoft Research lab in Cambridge is full of smart people, so it is a perferct working environment
  (except that you realize that you're not as clever as you think :-)). Also, it is just a few meters away from the
  <a href="http://www.cl.cam.ac.uk" type="external">Computer Laboratory</a> of the Cambridge University, so there are always many 
  interesting talks and seminars. So, big thanks to Don Syme, James Margetson and everyone else who I had a chance 
  to work with during the internship.</p>
  
<p>One of the reasons why I didn't have much time to write about the internship earlier is that I
  was invited to the <a href="http://www.langnetsymposium.com/" type="external">Lang.NET Symposium</a> shortly
  after the end of the internship. I had a chance to talk about my project there as well and there is
  even a video recording from the talk (the link is below), so you can watch it to find out more about my recent F# work.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Sunday, 17 May 2009, 11:00 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/random-thoughts/">random thoughts</a>, <a
              href="/blog/tag/universe/">universe</a>, <a
              href="/blog/tag/parallel/">parallel</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/joinads/">joinads</a>
        
        <br />
        <a href="http://tomasp.net/blog/internship-match-bang.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/book-source-available.aspx/">Source code for Real World Functional Programming available!</a></h1>
    
<a href="http://cid-8c3f26b4befe2dfa.skydrive.live.com/self.aspx/2009%20-%20Winter%20-%20Cambridge/P1060023.jpg" target="_blank"><img src="http://tomasp.net/articles/book-source-available/cambridge.jpg" class="ldecor" /></a>
<p>As you can see, there has been quite a bit of silence on this blog for a while. 
  There are two reasons for that - the first is that I'm still working on the book 
  <a type="external" href="http://www.manning.com/petricek">Real World Functional
  Programming</a>, so all my writing activities are fully dedicated to the book. The second
  reason is that I'm having a great time doing an internship in the <a href="http://research.microsoft.com/en-us/groups/ppt">Programming Principles and Tools</a> group
  at Microsoft Research in Cambridge with the F# team and namely the F# language 
  designer <a href="http://blogs.msdn.com/dsyme/" type="external">Don Syme</a>. 
  The photo on the left side is the entrance gate to the Trinity College of the Cambridge
  University taken during the few days when there was a snow. I recently started using
  Live Gallery, so you can find more photos from Cambridge in my <a href="http://cid-8c3f26b4befe2dfa.skydrive.live.com/browse.aspx/2009%20-%20Winter%20-%20Cambridge" type="external">online gallery</a>. Anyway,
  I just wanted to post a quick update with some information (and downloads!) related
  to the book...
</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Thursday, 12 February 2009, 2:10 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/random-thoughts/">random thoughts</a>, <a
              href="/blog/tag/csharp/">c#</a>, <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/universe/">universe</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>
        
        <br />
        <a href="http://tomasp.net/blog/book-source-available.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/reactive-i-fsevents.aspx/">Reactive programming (I.) - First class events in F#</a></h1>
    
<p>I believe that the LINQ project and changes in C# 3.0 and VB 9 are interesting because they 
  allow rewriting of many ideas from functional programming. An ability to express queries easily
  is one of these ideas, but it is definitely not the only one. There are many other interesting ideas.
  The C# 3.0 language isn't primary a functional language, so it isn't easy to discover the idea
  if you use only C#, but it is possible to implement it if you know the idea already.</p>
<p>I already wrote a few interesting C# examples that were inspired by some functional idea.
  I'm a big fan of the F# language, so it is not a surprise that I started with an F# version
  of the problem and then looked at the way to do the same thing in C#. In particular, this is 
  how my article about building dynamic queries in C# came to the existence - the F# version used
  <a href="http://tomasp.net/blog/dynamic-flinq.aspx">FLINQ and Quotations</a> and then I demonstrated how to do the same in <a href="http://tomasp.net/blog/dynamic-linq-queries.aspx">C# 
  using expression trees</a>. Another example is my article about asynchronous 
  programming in C# <a href="http://tomasp.net/blog/csharp-async.aspx">using iterators</a>, which shows how to implement something 
  like F# <a href="http://blogs.msdn.com/dsyme/archive/2007/10/11/introducing-f-asynchronous-workflows.aspx">asynchronous workflows using iterators</a> in C# 2.0.</p>

<h3>Functional Reactive Programming</h3>  
<p>Today, I'm going to look at another very interesting idea from functional programming. It is 
  called <em>Functional Reactive Programming</em> and it comes from the Haskell community. You can find 
  a list of related <a href="http://www.haskell.org/frp/" type="external">Haskell projects here</a>.
  However, similar things (though they are not purely functional and simplified) are available 
  in the F# language as well. Don Syme introduced them in his blog post called 
  <a href="http://blogs.msdn.com/dsyme/archive/2006/03/24/559582.aspx">F# First Class Events: Simplicity and Compositionality in Imperative Reactive Programming</a>. In this article, I'm going to briefly introduce the implementation
  available in F# and I'll extend it a little bit to allow some more interesting things. In the 
  second article from this series, I'll show how to implement the same thing in C# 3.0 (and in VB 9 too!)</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Sunday, 16 November 2008, 5:14 PM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/csharp/">c#</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/meta-programming/">meta-programming</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/reactive-i-fsevents.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/csharp-async.aspx/">Asynchronous Programming in C# using Iterators</a></h1>
    
<p>In this article we will look how to write programs that perform asynchronous operations without 
  the typical inversion of control. To briefly introduce what I mean by 'asynchronous' and 
  'inversion of control' - asynchronous refers to programs that perform some long running operations 
  that don't necessary block a calling thread, for example accessing the network, calling web services 
  or performing any other I/O operation in general. The inversion of control refers to the code structure 
  that you have to use when writing a code that explicitly passes a C# delegate as a callback to the
  asynchronous method (typically called <code>Begin<em>Something</em></code> in .NET). The asynchronous method
  calls the delegate when the operation completes, which reverses the way you write the code - instead of
  encoding the control flow using typical language constructs (e.g. <code>while</code> loop) you have to 
  use global variables and write your own control mechanism.</p>
<p>The funny thing about this article is that it could have been written at least 3 years ago when
  a beta version of Visual Studio 2005 and C# 2.0 became first available, but it is using iterators in 
  a slightly bizarre way, so it is not easy to realize that this is possible. Actually, I will use some C# 3.0
  methods in the article as well, but only extension methods and mainly just to keep the code nicer. As with 
  my earlier article about building LINQ queries at runtime, I realized that it can be done in C# when I was playing with 
  the F# solution (called F# Asynchronous Workflows), where this approach is very natural, so I will shortly
  mention the F# implementation as well.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Thursday, 15 November 2007, 3:08 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/csharp/">c#</a>, <a
              href="/blog/tag/parallel/">parallel</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>
        
        <br />
        <a href="http://tomasp.net/blog/csharp-async.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  
    <h1><a href="http://tomasp.net/blog/fsharp-iv-lang.aspx/">F# Overview (IV.) - Language Oriented Programming</a></h1>
    
<p>In the fourth article of the F# overview series, I will shortly describe how I understad the language oriented paradigm and how the F# language can be used for developing libraries using this paradigm. We will look how discriminated unions relate to this paradigm and at three specific features that support this paradigm, namely <em>active patterns</em>, <em>computation expressions</em> and <em>quotations</em>.</p>

<p>Defining precisely what the term <em>language oriented programming</em> means in context of the F# language would be difficult,
  so I will instead explain a few examples that will demonstrate how I understand it. In general, the goal of language oriented
  programming is to develop a <em>language</em> that would be suitable for some (more specific) class of tasks and use this language 
  for solving these tasks. Of course, developing a real programming language is extremely complex problem, so there are several ways
  for making it easier. As the most elementary example, you can look at XML files (with certain schema) as language that 
  are processed by your program and solve some specific problem (for example configuring the application). As a side note,
  I should mention that I'm not particularly happy with the term language in this context, because the term can be used
  for describing a wide range of techniques from very trivial constructs to a complex object-oriented class libraries, 
  but I have not seen any better term for the class of techniques that Im going to talk about.</p>

    <div class="info">
      <p class="details">
        <strong>Published</strong>: <span>Saturday, 3 November 2007, 12:00 AM</span>
        
          <br />
          <strong>Tags</strong>:
            <a
              href="/blog/tag/functional/">functional</a>, <a
              href="/blog/tag/asynchronous/">asynchronous</a>, <a
              href="/blog/tag/meta-programming/">meta-programming</a>, <a
              href="/blog/tag/fsharp/">f#</a>
        
        <br />
        <a href="http://tomasp.net/blog/fsharp-iv-lang.aspx/">Read the complete article</a><br /><br />
      </p>
    </div>
  

  <h1>All blog posts by tag</h1>
  
  <a
    href="/blog/tag/fsharp/">f# (112)</a>, <a
    href="/blog/tag/functional/">functional (66)</a>, <a
    href="/blog/tag/research/">research (50)</a>, <a
    href="/blog/tag/csharp/">c# (37)</a>, <a
    href="/blog/tag/academic/">academic (28)</a>, <a
    href="/blog/tag/asynchronous/">asynchronous (27)</a>, <a
    href="/blog/tag/programming-languages/">programming languages (23)</a>, <a
    href="/blog/tag/parallel/">parallel (23)</a>, <a
    href="/blog/tag/functional-programming/">functional programming (20)</a>, <a
    href="/blog/tag/universe/">universe (20)</a>, <a
    href="/blog/tag/meta-programming/">meta-programming (18)</a>, <a
    href="/blog/tag/philosophy/">philosophy (16)</a>, <a
    href="/blog/tag/links/">links (15)</a>, <a
    href="/blog/tag/presentations/">presentations (14)</a>, <a
    href="/blog/tag/thegamma/">thegamma (12)</a>, <a
    href="/blog/tag/data-science/">data science (12)</a>, <a
    href="/blog/tag/writing/">writing (12)</a>, <a
    href="/blog/tag/joinads/">joinads (12)</a>, <a
    href="/blog/tag/web/">web (11)</a>, <a
    href="/blog/tag/talks/">talks (9)</a>, <a
    href="/blog/tag/data-journalism/">data journalism (9)</a>, <a
    href="/blog/tag/math-and-numerics/">math and numerics (9)</a>, <a
    href="/blog/tag/random-thoughts/">random thoughts (9)</a>, <a
    href="/blog/tag/phalanger/">phalanger (8)</a>, <a
    href="/blog/tag/haskell/">haskell (7)</a>, <a
    href="/blog/tag/mono/">mono (7)</a>, <a
    href="/blog/tag/webcast/">webcast (7)</a>, <a
    href="/blog/tag/design/">design (6)</a>, <a
    href="/blog/tag/architecture/">architecture (5)</a>, <a
    href="/blog/tag/fslab/">fslab (5)</a>, <a
    href="/blog/tag/open-source/">open source (5)</a>, <a
    href="/blog/tag/type-providers/">type providers (4)</a>, <a
    href="/blog/tag/visualization/">visualization (4)</a>, <a
    href="/blog/tag/fun/">fun (4)</a>, <a
    href="/blog/tag/accelerator/">accelerator (4)</a>, <a
    href="/blog/tag/linq/">linq (3)</a>, <a
    href="/blog/tag/fsharp-data/">f# data (3)</a>, <a
    href="/blog/tag/dotnet/">.net (3)</a>, <a
    href="/blog/tag/training/">training (2)</a>, <a
    href="/blog/tag/coeffects/">coeffects (2)</a>, <a
    href="/blog/tag/deedle/">deedle (2)</a>, <a
    href="/blog/tag/monads/">monads (2)</a>, <a
    href="/blog/tag/art/">art (2)</a>, <a
    href="/blog/tag/fractals/">fractals (2)</a>, <a
    href="/blog/tag/funscript/">funscript (2)</a>, <a
    href="/blog/tag/new-york/">new york (2)</a>, <a
    href="/blog/tag/manning/">manning (2)</a>, <a
    href="/blog/tag/books/">books (2)</a>
</article>


  <footer>
  <div class="footer-body">
    <div class="fl70"><div class="fmr">
      <h4><a href="http://tomasp.net/rss.xml"><i class="fa fa-rss" style="margin-right:5px;"></i></a> Blog archives</h4>
      <p>
      
      <a href="/blog/archive/february_2025/">February 2025 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2023/">December 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2023/">February 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2022/">September 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2022/">April 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2021/">October 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2021/">April 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2020/">October 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2020/">July 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2020/">April 2020 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2019/">December 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2019/">February 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2018/">November 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2018/">October 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2018/">May 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2017/">September 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2017/">June 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2017/">April 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2017/">March 2017 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2017/">January 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2016/">October 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2016/">September 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/august_2016/">August 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2016/">July 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2016/">May 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2016/">April 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2015/">December 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2015/">November 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2015/">September 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2015/">July 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2015/">June 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2015/">May 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2015/">April 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2015/">March 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2015/">February 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2015/">January 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2014/">December 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2014/">May 2014 (3)</a>,&nbsp;
      
      <a href="/blog/archive/april_2014/">April 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2014/">March 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2014/">January 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2013/">December 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2013/">November 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2013/">October 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2013/">September 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2013/">August 2013 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2013/">May 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2013/">April 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2013/">March 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2013/">February 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2013/">January 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2012/">December 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/october_2012/">October 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2012/">August 2012 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2012/">June 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2012/">April 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2012/">March 2012 (4)</a>,&nbsp;
      
      <a href="/blog/archive/february_2012/">February 2012 (5)</a>,&nbsp;
      
      <a href="/blog/archive/january_2012/">January 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2011/">November 2011 (5)</a>,&nbsp;
      
      <a href="/blog/archive/august_2011/">August 2011 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2011/">July 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/june_2011/">June 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2011/">May 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2011/">March 2011 (4)</a>,&nbsp;
      
      <a href="/blog/archive/december_2010/">December 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2010/">November 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2010/">October 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/september_2010/">September 2010 (4)</a>,&nbsp;
      
      <a href="/blog/archive/july_2010/">July 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2010/">June 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2010/">May 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2010/">February 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2010/">January 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/december_2009/">December 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2009/">July 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2009/">June 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2009/">May 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2009/">April 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2009/">March 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2009/">February 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2008/">December 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2008/">November 2008 (5)</a>,&nbsp;
      
      <a href="/blog/archive/october_2008/">October 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2008/">September 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2008/">June 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2008/">March 2008 (3)</a>,&nbsp;
      
      <a href="/blog/archive/february_2008/">February 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2007/">December 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2007/">November 2007 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2007/">October 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2007/">September 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2007/">August 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2007/">July 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2007/">April 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2007/">March 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2007/">February 2007 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2007/">January 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2006/">November 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2006/">October 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/august_2006/">August 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/july_2006/">July 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2006/">June 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2006/">May 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2006/">April 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2005/">December 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2005/">July 2005 (4)</a>,&nbsp;
      
      <a href="/blog/archive/june_2005/">June 2005 (5)</a>,&nbsp;
      
      <a href="/blog/archive/may_2005/">May 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2005/">April 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2005/">March 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2005/">January 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2004/">December 2004 (3)</a>,&nbsp;
      
      <a href="/blog/archive/november_2004/">November 2004 (2)</a>,&nbsp;
      
      </p>
    </div></div>
    <div class="fr30"><div class="fmr">
      <h4>License and about</h4>
      <p>All articles on this site are licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share Alike</a>.
        All source code samples are licensed under the MIT License.
      </p>
      <p>This site is hosted on GitHub and is generated using <a href="https://github.com/tpetricek/FSharp.Formatting">F# Formatting</a>
        and <a href="http://dotliquidmarkup.org/">DotLiquid</a>.
        For more info, see the <a href="https://github.com/tpetricek/tomasp.net">website source on GitHub</a>.
      </p>
      <p>Please submit issues &amp; corrections on GitHub. Use pull requests for minor corrections only.</p>
      <ul>
        <li><i class="fab fa-twitter"></i> Twitter: <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a></li>
        <li><i class="fab fa-github"></i> GitHub: <a href="https://github.com/tpetricek">@tpetricek</a></li>
        <li><i class="fa fa-envelope"></i> Email: <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a></li>
      </ul>
      <p style="text-align:center;margin-top:15px;"><img src="https://tomasp.net/img/cc-sa.png" alt="CC License logo" /></p>
    </div></div>
  </div>
  </footer>

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-1561220-1']);
    _gaq.push(['_trackPageview']);
    (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</body>
</html>
