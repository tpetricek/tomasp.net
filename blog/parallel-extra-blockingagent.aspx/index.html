<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <meta name=viewport content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Droid+Sans+Mono&family=Kreon:wght@300;400;500;600&family=PT+Sans:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="alternate" type="application/rss+xml" title="Latest news from Tomas Petricek" href="/rss.xml" />
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <link href="/custom/style.css" rel="stylesheet">
  <link href="/custom/tooltips.css" rel="stylesheet">
  <script src="/custom/tooltips.js" type="text/javascript"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon-big.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/img/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/img/favicon-big.png">
  <meta name="msapplication-TileColor" content="#004C6B">
  <meta name="msapplication-TileImage" content="/img/favicon-big.png">
  <meta name="theme-color" content="#004C6B">
  
  <title>F# Parallel Extras (II.): Agent-based blocking queue - Tomas Petricek</title>

  <meta name="description" content=" In this article, we'll look at type that implements an (asynchronous) blocking queue using F# agents. This can be used, for example, when implementing the pipeline pattern as demonstrated in the previous article." />
  <meta name="keywords" content="functional, parallel, asynchronous, f#, " />  
  <meta name="author" content="Tomas Petricek" />
  <meta name="copyright" content="Tomas Petricek" />
  
  <meta property="og:title" content="F# Parallel Extras (II.): Agent-based blocking queue" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://tomasp.net/blog/parallel-extra-blockingagent.aspx/" />
  <meta property="og:image" content="" />
  <meta property="og:description" content=" In this article, we'll look at type that implements an (asynchronous) blocking queue using F# agents. This can be used, for example, when implementing the pipeline pattern as demonstrated in the previous article." />
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:site" content="@tomaspetricek">
  <meta name="twitter:creator" content="@tomaspetricek">  
  <meta name="twitter:title" content="F# Parallel Extras (II.): Agent-based blocking queue" />
  <meta name="twitter:image" content="" />
  <meta name="twitter:description" content=" In this article, we'll look at type that implements an (asynchronous) blocking queue using F# agents. This can be used, for example, when implementing the pipeline pattern as demonstrated in the previous article." />
    
  <script type="application/ld+json">
  {
  	"@context": "http:\/\/schema.org",
  	"@type": "Article",
  	"name": "F# Parallel Extras (II.): Agent-based blocking queue",
    "headline": "F# Parallel Extras (II.): Agent-based blocking queue",
  	"description": " In this article, we'll look at type that implements an (asynchronous) blocking queue using F# agents. This can be used, for example, when implementing the pipeline pattern as demonstrated in the previous article.",
  	"url": "http://tomasp.net/blog/parallel-extra-blockingagent.aspx/",
  	"author": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	},
  	"creator": ["Tomas Petricek"],
  	"dateCreated": "2010-10-27T11:12:08.0000000",
  	"datePublished": "2010-10-27T11:12:08.0000000",
    "dateModified": "2010-10-27T11:12:08.0000000",
    "mainEntityOfPage": "http://tomasp.net/blog/parallel-extra-blockingagent.aspx/",
  	"image": "",
  	"thumbnailUrl": "",
  	"keywords": ["functional", "parallel", "asynchronous", "f#",  "tomas", "petricek"],
  	"inLanguage": "en-us",
  	"publisher": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
      "logo": "http://tomasp.net/img/favicon-big.png",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	}
  }  
  </script>

</head>
<body class="default">
    
  <span class="tplink"><a href="/">TP</a></span>

  <article class='article''>
    <h1>F# Parallel Extras (II.): Agent-based blocking queue</h1>
<p>In the <a href="http://tomasp.net/blog/parallel-extra-image-pipeline.aspx">previous article</a>, we 
  briefly introduced the <code>BlockingQueueAgent&lt;T&gt;</code> type and we used it to implement the
  pipeline pattern (from Chapter 7 of <a href="http://parallelpatterns.codeplex.com/" type="external">Parallel Programming with Microsoft .NET</a>)
  using asynchronous workflows. The type was used to represent intermediate buffers with a limited size.
  In this article we'll take a look at the implementation of the type. The type implements a very useful
  pattern in agent-based parallel programming, so you can use it in your work, but it could be also 
  interesting as a demonstration of the F# <code>Agent&lt;T&gt;</code> type (an recommended alias 
  for the <code>MailboxProcessor&lt;T&gt;</code> type).</p>
<p>The <code>BlockingQueueAgent&lt;T&gt;</code> type is similar to <code>BlockingCollection&lt;T&gt;</code> 
  from .NET 4.0. It has methods for adding and removing elements that block when the operation cannot be
  done (e.g. adding when the queue is full or removing when the queue is empty). The most important 
  difference is that it can be used <em>asynchronously</em>. This means that when we call its operations
  form F# asynchronous workflow (using <code>let!</code> and <code>do!</code>), the operation will block
  the calling workflow, but it will not block any physical thread. We start by looking at the overall
  structure of the agent and then look at the body of the agent which implements its behavior (using
  a state machine)...</p>

<h2>Structure of the blocking agent</h2>
<p>An agent is simply an object that can receive messages of some type. The best way to represent messages
  is to use an F# discriminated union type which lists all the possible commands that the agent can 
  react to. To make the use of agent more convenient, it is quite common to wrap the agent in 
  a type declaration, so that the messages can be send just by calling a member.</p>

<h3>Defining the message type</h3>
<p>Let's start by defining a type alias <code>Agent&lt;T&gt;</code> and defining a message type for
  our agent. As you can see, the agent is surprisingly simple and it needs only two messages:</p>

<pre class="fssnip">
<span class="l">1: </span><span class="c">///</span><span class="c"> </span><span class="c">A</span><span class="c"> </span><span class="c">convenience</span><span class="c"> </span><span class="c">type</span><span class="c"> </span><span class="c">alias</span><span class="c"> </span><span class="c">for</span><span class="c"> </span><span class="c">'MailboxProcessor&lt;T&gt;'</span><span class="c"> </span><span class="c">type</span>
<span class="l">2: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fsbla1', 1)" onmouseover="showTip(event, 'fsbla1', 1)" class="i">Agent</span><span class="o">&lt;</span><span class="o">'</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla2', 2)" onmouseover="showTip(event, 'fsbla2', 2)" class="i">MailboxProcessor</span><span class="o">&lt;</span><span class="o">'</span><span class="i">T</span><span class="o">&gt;</span>
<span class="l">3: </span>
<span class="l">4: </span><span class="c">///</span><span class="c"> </span><span class="c">Type</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">messages</span><span class="c"> </span><span class="c">internally</span><span class="c"> </span><span class="c">used</span><span class="c"> </span><span class="c">by</span><span class="c"> </span><span class="c">'BlockingQueueAgent&lt;T&gt;'</span>
<span class="l">5: </span><span class="k">type</span> <span class="k">internal</span> <span onmouseout="hideTip(event, 'fsbla3', 3)" onmouseover="showTip(event, 'fsbla3', 3)" class="i">BlockingAgentMessage</span><span class="o">&lt;</span><span class="o">'</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">=</span> 
<span class="l">6: </span>  | <span onmouseout="hideTip(event, 'fsbla4', 4)" onmouseover="showTip(event, 'fsbla4', 4)" class="i">Add</span> <span class="k">of</span> <span class="o">'</span><span class="i">T</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fsbla5', 5)" onmouseover="showTip(event, 'fsbla5', 5)" class="i">AsyncReplyChannel</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fsbla6', 6)" onmouseover="showTip(event, 'fsbla6', 6)" class="i">unit</span><span class="o">&gt;</span> 
<span class="l">7: </span>  | <span onmouseout="hideTip(event, 'fsbla7', 7)" onmouseover="showTip(event, 'fsbla7', 7)" class="i">Get</span> <span class="k">of</span> <span onmouseout="hideTip(event, 'fsbla5', 8)" onmouseover="showTip(event, 'fsbla5', 8)" class="i">AsyncReplyChannel</span><span class="o">&lt;</span><span class="o">'</span><span class="i">T</span><span class="o">&gt;</span><a target="_blank" class="fssniplink" href="http://tomasp.net/fswebsnippets">F# Web Snippets</a>
</pre>

<p>The first message is used to add a new element to the blocking queue. It carries a value to be added and 
  a reply channel. The channel is used to notify the caller that the element was added (and so the caller can 
  continue producing more elements). The second message is used to read elements from the queue is using 
  asynchronous reply channel to send the obtained value to the caller. Now that we have the message type, we 
  can look at the structure of the wrapping type...</p>

<h3>Wrapping agent in a type</h3>
<p>The <code>BlockingQueueAgent&lt;T&gt;</code> type takes a maximal number of elements that can be stored
  in the queue as a constructor parameter. It has a single property <code>Count</code>, which returns the 
  current number of elements in the queue and it has two methods. The <code>AsyncAdd</code> method
  sends the <code>Add</code> message to the agent (and asynchronously waits for the reply) and the
  <code>AsyncGet</code> method does similar thing with the <code>Get</code> message. In addition, both of 
  the methods that an optional parameter <code>?timeout</code> that can be used to limit the waiting time.
  Let's now look at the structure and we'll discuss the private state of the agent as well as the 
  state machine that implements its behavior later:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="c">///</span><span class="c"> </span><span class="c">Agent</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">implements</span><span class="c"> </span><span class="c">an</span><span class="c"> </span><span class="c">asynchronous</span><span class="c"> </span><span class="c">blocking</span><span class="c"> </span><span class="c">queue</span>
<span class="l"> 2: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fsbla8', 9)" onmouseover="showTip(event, 'fsbla8', 9)" class="i">BlockingQueueAgent</span><span class="o">&lt;</span><span class="o">'</span><span class="i">T</span><span class="o">&gt;</span>(<span onmouseout="hideTip(event, 'fsbla9', 10)" onmouseover="showTip(event, 'fsbla9', 10)" class="i">maxLength</span>) <span class="o">=</span>
<span class="l"> 3: </span>  <span onmouseout="hideTip(event, 'fsbla10', 11)" onmouseover="showTip(event, 'fsbla10', 11)" class="omitted">(initialization and private state omitted)</span>
<span class="l"> 4: </span>  <span class="k">let</span> <span onmouseout="hideTip(event, 'fsbla11', 12)" onmouseover="showTip(event, 'fsbla11', 12)" class="i">agent</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla1', 13)" onmouseover="showTip(event, 'fsbla1', 13)" class="i">Agent</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla12', 14)" onmouseover="showTip(event, 'fsbla12', 14)" class="i">Start</span>(<span class="k">fun</span> <span onmouseout="hideTip(event, 'fsbla11', 15)" onmouseover="showTip(event, 'fsbla11', 15)" class="i">agent</span> <span class="k">-&gt;</span>
<span class="l"> 5: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Keeps</span><span class="c"> </span><span class="c">a</span><span class="c"> </span><span class="c">list</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">items</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">are</span><span class="c"> </span><span class="c">in</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">queue</span>
<span class="l"> 6: </span>    <span class="k">let</span> <span onmouseout="hideTip(event, 'fsbla13', 16)" onmouseover="showTip(event, 'fsbla13', 16)" class="i">queue</span> <span class="o">=</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fsbla14', 17)" onmouseover="showTip(event, 'fsbla14', 17)" class="i">Queue</span><span class="o">&lt;</span>_<span class="o">&gt;</span>()
<span class="l"> 7: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Keeps</span><span class="c"> </span><span class="c">a</span><span class="c"> </span><span class="c">list</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">blocked</span><span class="c"> </span><span class="c">callers</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">additional</span><span class="c"> </span><span class="c">values</span>
<span class="l"> 8: </span>    <span class="k">let</span> <span onmouseout="hideTip(event, 'fsbla15', 18)" onmouseover="showTip(event, 'fsbla15', 18)" class="i">pending</span> <span class="o">=</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fsbla14', 19)" onmouseover="showTip(event, 'fsbla14', 19)" class="i">Queue</span><span class="o">&lt;</span>_<span class="o">&gt;</span>()
<span class="l"> 9: </span>
<span class="l">10: </span>    <span class="c">//</span><span class="c"> </span><span class="c">State</span><span class="c"> </span><span class="c">machine</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">implements</span><span class="c"> </span><span class="c">agent's</span><span class="c"> </span><span class="c">behavior</span>
<span class="l">11: </span>    <span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'fsbla16', 20)" onmouseover="showTip(event, 'fsbla16', 20)" class="i">emptyQueue</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla17', 21)" onmouseover="showTip(event, 'fsbla17', 21)" class="omitted">(...)</span>
<span class="l">12: </span>    <span class="k">and</span> <span onmouseout="hideTip(event, 'fsbla18', 22)" onmouseover="showTip(event, 'fsbla18', 22)" class="i">nonEmptyQueue</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla19', 23)" onmouseover="showTip(event, 'fsbla19', 23)" class="omitted">(...)</span>
<span class="l">13: </span>
<span class="l">14: </span>    <span class="c">//</span><span class="c"> </span><span class="c">Start</span><span class="c"> </span><span class="c">with</span><span class="c"> </span><span class="c">an</span><span class="c"> </span><span class="c">empty</span><span class="c"> </span><span class="c">queue</span>
<span class="l">15: </span>    <span onmouseout="hideTip(event, 'fsbla16', 24)" onmouseover="showTip(event, 'fsbla16', 24)" class="i">emptyQueue</span>() )
<span class="l">16: </span>
<span class="l">17: </span>  <span class="c">///</span><span class="c"> </span><span class="c">Returns</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">number</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">items</span><span class="c"> </span><span class="c">in</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">(immediately)</span>
<span class="l">18: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fsbla20', 25)" onmouseover="showTip(event, 'fsbla20', 25)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla21', 26)" onmouseover="showTip(event, 'fsbla21', 26)" class="i">Count</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla22', 27)" onmouseover="showTip(event, 'fsbla22', 27)" class="i">count</span>
<span class="l">19: </span>
<span class="l">20: </span>  <span class="c">///</span><span class="c"> </span><span class="c">Asynchronously</span><span class="c"> </span><span class="c">adds</span><span class="c"> </span><span class="c">item;</span><span class="c"> </span><span class="c">blocks</span><span class="c"> </span><span class="c">if</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">full</span>
<span class="l">21: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fsbla20', 28)" onmouseover="showTip(event, 'fsbla20', 28)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla23', 29)" onmouseover="showTip(event, 'fsbla23', 29)" class="i">AsyncAdd</span>(<span onmouseout="hideTip(event, 'fsbla24', 30)" onmouseover="showTip(event, 'fsbla24', 30)" class="i">v</span><span class="o">:</span><span class="o">'</span><span class="i">T</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fsbla25', 31)" onmouseover="showTip(event, 'fsbla25', 31)" class="i">timeout</span>) <span class="o">=</span> 
<span class="l">22: </span>    <span onmouseout="hideTip(event, 'fsbla11', 32)" onmouseover="showTip(event, 'fsbla11', 32)" class="i">agent</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla26', 33)" onmouseover="showTip(event, 'fsbla26', 33)" class="i">PostAndAsyncReply</span>((<span class="k">fun</span> <span onmouseout="hideTip(event, 'fsbla27', 34)" onmouseover="showTip(event, 'fsbla27', 34)" class="i">ch</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fsbla4', 35)" onmouseover="showTip(event, 'fsbla4', 35)" class="i">Add</span>(<span onmouseout="hideTip(event, 'fsbla24', 36)" onmouseover="showTip(event, 'fsbla24', 36)" class="i">v</span>, <span onmouseout="hideTip(event, 'fsbla27', 37)" onmouseover="showTip(event, 'fsbla27', 37)" class="i">ch</span>)), <span class="o">?</span><span onmouseout="hideTip(event, 'fsbla25', 38)" onmouseover="showTip(event, 'fsbla25', 38)" class="i">timeout</span><span class="o">=</span><span onmouseout="hideTip(event, 'fsbla25', 39)" onmouseover="showTip(event, 'fsbla25', 39)" class="i">timeout</span>)
<span class="l">23: </span>
<span class="l">24: </span>  <span class="c">///</span><span class="c"> </span><span class="c">Asynchronously</span><span class="c"> </span><span class="c">gets</span><span class="c"> </span><span class="c">item;</span><span class="c"> </span><span class="c">blocks</span><span class="c"> </span><span class="c">if</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">empty</span>
<span class="l">25: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fsbla20', 40)" onmouseover="showTip(event, 'fsbla20', 40)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla28', 41)" onmouseover="showTip(event, 'fsbla28', 41)" class="i">AsyncGet</span>(<span class="o">?</span><span onmouseout="hideTip(event, 'fsbla25', 42)" onmouseover="showTip(event, 'fsbla25', 42)" class="i">timeout</span>) <span class="o">=</span> 
<span class="l">26: </span>    <span onmouseout="hideTip(event, 'fsbla11', 43)" onmouseover="showTip(event, 'fsbla11', 43)" class="i">agent</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla26', 44)" onmouseover="showTip(event, 'fsbla26', 44)" class="i">PostAndAsyncReply</span>(<span onmouseout="hideTip(event, 'fsbla7', 45)" onmouseover="showTip(event, 'fsbla7', 45)" class="i">Get</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fsbla25', 46)" onmouseover="showTip(event, 'fsbla25', 46)" class="i">timeout</span><span class="o">=</span><span onmouseout="hideTip(event, 'fsbla25', 47)" onmouseover="showTip(event, 'fsbla25', 47)" class="i">timeout</span>)<a target="_blank" class="fssniplink" href="http://tomasp.net/fswebsnippets">F# Web Snippets</a>
</pre>
<p>The type contains a single private field that is marked as <code>VolatileFiled</code> and is used to track
  the number of elements in the queue. The value can be obtained using the <code>Count</code> member, which can 
  be safely accessed from multiple threads. Next, the queue creates an agent that is used to keep the state
  of the queue and handles the messages that we declared earlier.</p>

<p>Inside the agent, we use mutable state, because the mutable <code>Queue&lt;T&gt;</code> type from .NET libraries
  is faster than a functional implementation. Note that this is also perfectly safe because the body of the agent will never execute multiple times
  in parallel. We use two queues in the implementation of the agent. The first one is used to keep items that
  are currently in the queue (as the tool tips shows if you place mouse pointer over the <code>queue</code>
  identifier, it contains values of type <code>'T</code>). The second queue keeps a list of pending calls to the
  <code>Add</code> method - that is, calls that wanted to add some value, but couldn't finish, because the queue
  was full (as we'll see later, we'll add values together with reply channels to this queue when a call is done
  and the queue is full and we'll process the pending calls when an element is removed).</p>

<p>The body of the agent contains two functions (both implemented using asynchronous workflows) that implement
  the behavior of the agent. As the names suggest, the function <code>emptyQueue</code> represents a state when
  the queue is empty (and cannot handle <code>Get</code> messages) and the other function (<code>nonEmptyQueue</code>)
  is used when the queue contains some elements. I omitted the body of the functions in the previous snippet to 
  show the overall structure, but we'll look at the implementation next...</p>

<h2>Encoding agent's behavior</h2>
<p>Let's start with the function that implements an empty queue. As already mentioned, in this state we can
  only handle the <code>Add</code> message, so the implementation uses the <code>Scan</code> member of the
  mailbox to create computation that reacts only to some messages. The function passed to the <code>Scan</code>
  member returns <code>None</code> to ignore message and <code>Some</code> with some asynchronous workflow
  as an argument to handle a message:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="c">//</span><span class="c"> </span><span class="c">If</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">empty</span><span class="c"> </span><span class="c">we</span><span class="c"> </span><span class="c">handle</span><span class="c"> </span><span class="c">only</span><span class="c"> </span><span class="c">'Add'</span><span class="c"> </span><span class="c">message</span>
<span class="l"> 2: </span><span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'fsbla16', 48)" onmouseover="showTip(event, 'fsbla16', 48)" class="i">emptyQueue</span>() <span class="o">=</span> 
<span class="l"> 3: </span>  <span onmouseout="hideTip(event, 'fsbla11', 49)" onmouseover="showTip(event, 'fsbla11', 49)" class="i">agent</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla29', 50)" onmouseover="showTip(event, 'fsbla29', 50)" class="i">Scan</span>(<span class="k">fun</span> <span onmouseout="hideTip(event, 'fsbla30', 51)" onmouseover="showTip(event, 'fsbla30', 51)" class="i">msg</span> <span class="k">-&gt;</span>
<span class="l"> 4: </span>    <span class="k">match</span> <span onmouseout="hideTip(event, 'fsbla30', 52)" onmouseover="showTip(event, 'fsbla30', 52)" class="i">msg</span> <span class="k">with</span> 
<span class="l"> 5: </span>    | <span onmouseout="hideTip(event, 'fsbla4', 53)" onmouseover="showTip(event, 'fsbla4', 53)" class="i">Add</span>(<span onmouseout="hideTip(event, 'fsbla31', 54)" onmouseover="showTip(event, 'fsbla31', 54)" class="i">value</span>, <span onmouseout="hideTip(event, 'fsbla32', 55)" onmouseover="showTip(event, 'fsbla32', 55)" class="i">reply</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fsbla33', 56)" onmouseover="showTip(event, 'fsbla33', 56)" class="i">Some</span> <span class="o">&lt;|</span> <span onmouseout="hideTip(event, 'fsbla34', 57)" onmouseover="showTip(event, 'fsbla34', 57)" class="i">async</span> {
<span class="l"> 6: </span>        <span onmouseout="hideTip(event, 'fsbla13', 58)" onmouseover="showTip(event, 'fsbla13', 58)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla35', 59)" onmouseover="showTip(event, 'fsbla35', 59)" class="i">Enqueue</span>(<span onmouseout="hideTip(event, 'fsbla31', 60)" onmouseover="showTip(event, 'fsbla31', 60)" class="i">value</span>)
<span class="l"> 7: </span>        <span onmouseout="hideTip(event, 'fsbla22', 61)" onmouseover="showTip(event, 'fsbla22', 61)" class="i">count</span> <span class="o">&lt;-</span> <span onmouseout="hideTip(event, 'fsbla13', 62)" onmouseover="showTip(event, 'fsbla13', 62)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 63)" onmouseover="showTip(event, 'fsbla36', 63)" class="i">Count</span>
<span class="l"> 8: </span>        <span onmouseout="hideTip(event, 'fsbla32', 64)" onmouseover="showTip(event, 'fsbla32', 64)" class="i">reply</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla37', 65)" onmouseover="showTip(event, 'fsbla37', 65)" class="i">Reply</span>()
<span class="l"> 9: </span>        <span class="k">return!</span> <span onmouseout="hideTip(event, 'fsbla18', 66)" onmouseover="showTip(event, 'fsbla18', 66)" class="i">nonEmptyQueue</span>() }
<span class="l">10: </span>    | _ <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fsbla38', 67)" onmouseover="showTip(event, 'fsbla38', 67)" class="i">None</span> )<a target="_blank" class="fssniplink" href="http://tomasp.net/fswebsnippets">F# Web Snippets</a>
</pre>

<p>When we receive the <code>Add</code> message, we return a workflow that adds the value to a queue, 
  updates the number of elements in the queue and sends reply to the caller (as a notification that the 
  value was added). Consequently, the queue is no longer empty, so it switches to the other state.
  Note that any <code>Get</code> messages that are sent to the agent while in the <code>emptyQueue</code>
  state will be automatically buffered by the agent and will be processed when the agent switches the state.</p>

<p>The second function (<code>nonEmptyQueue</code>) can handle both of the messages, so we can implement
  it as an asynchronous workflow that awaits the first message (using <code>Receive</code> method of the
  agent) and then reacts to the message. When adding a value, we need to handle a case when the 
  queue is already full. When removing a value, we then check if there are any pending calls that
  have been blocked while attempting to add a value. These blocked calls are stored in the <code>pending</code>
  queue:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="c">//</span><span class="c"> </span><span class="c">If</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">non-empty,</span><span class="c"> </span><span class="c">we</span><span class="c"> </span><span class="c">can</span><span class="c"> </span><span class="c">handle</span><span class="c"> </span><span class="c">all</span><span class="c"> </span><span class="c">messages</span>
<span class="l"> 2: </span><span class="k">and</span> <span onmouseout="hideTip(event, 'fsbla18', 68)" onmouseover="showTip(event, 'fsbla18', 68)" class="i">nonEmptyQueue</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla34', 69)" onmouseover="showTip(event, 'fsbla34', 69)" class="i">async</span> {
<span class="l"> 3: </span>  <span class="k">let!</span> <span onmouseout="hideTip(event, 'fsbla30', 70)" onmouseover="showTip(event, 'fsbla30', 70)" class="i">msg</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla11', 71)" onmouseover="showTip(event, 'fsbla11', 71)" class="i">agent</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla39', 72)" onmouseover="showTip(event, 'fsbla39', 72)" class="i">Receive</span>()
<span class="l"> 4: </span>  <span class="k">match</span> <span class="i">msg</span> <span class="k">with</span> 
<span class="l"> 5: </span>  | <span onmouseout="hideTip(event, 'fsbla4', 73)" onmouseover="showTip(event, 'fsbla4', 73)" class="i">Add</span>(<span onmouseout="hideTip(event, 'fsbla31', 74)" onmouseover="showTip(event, 'fsbla31', 74)" class="i">value</span>, <span onmouseout="hideTip(event, 'fsbla32', 75)" onmouseover="showTip(event, 'fsbla32', 75)" class="i">reply</span>) <span class="k">-&gt;</span> 
<span class="l"> 6: </span>      <span class="c">//</span><span class="c"> </span><span class="c">Add</span><span class="c"> </span><span class="c">immediately</span><span class="c"> </span><span class="c">if</span><span class="c"> </span><span class="c">possibley,</span><span class="c"> </span><span class="c">otherwise</span><span class="c"> </span><span class="c">block</span><span class="c"> </span><span class="c">caller</span>
<span class="l"> 7: </span>      <span class="k">if</span> <span onmouseout="hideTip(event, 'fsbla13', 76)" onmouseover="showTip(event, 'fsbla13', 76)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 77)" onmouseover="showTip(event, 'fsbla36', 77)" class="i">Count</span> <span class="o">&lt;</span> <span onmouseout="hideTip(event, 'fsbla9', 78)" onmouseover="showTip(event, 'fsbla9', 78)" class="i">maxLength</span> <span class="k">then</span> 
<span class="l"> 8: </span>        <span onmouseout="hideTip(event, 'fsbla13', 79)" onmouseover="showTip(event, 'fsbla13', 79)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla35', 80)" onmouseover="showTip(event, 'fsbla35', 80)" class="i">Enqueue</span>(<span onmouseout="hideTip(event, 'fsbla31', 81)" onmouseover="showTip(event, 'fsbla31', 81)" class="i">value</span>)
<span class="l"> 9: </span>        <span onmouseout="hideTip(event, 'fsbla22', 82)" onmouseover="showTip(event, 'fsbla22', 82)" class="i">count</span> <span class="o">&lt;-</span> <span onmouseout="hideTip(event, 'fsbla13', 83)" onmouseover="showTip(event, 'fsbla13', 83)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 84)" onmouseover="showTip(event, 'fsbla36', 84)" class="i">Count</span>
<span class="l">10: </span>        <span onmouseout="hideTip(event, 'fsbla32', 85)" onmouseover="showTip(event, 'fsbla32', 85)" class="i">reply</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla37', 86)" onmouseover="showTip(event, 'fsbla37', 86)" class="i">Reply</span>()
<span class="l">11: </span>      <span class="k">else</span> 
<span class="l">12: </span>        <span onmouseout="hideTip(event, 'fsbla15', 87)" onmouseover="showTip(event, 'fsbla15', 87)" class="i">pending</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla40', 88)" onmouseover="showTip(event, 'fsbla40', 88)" class="i">Enqueue</span>(<span onmouseout="hideTip(event, 'fsbla31', 89)" onmouseover="showTip(event, 'fsbla31', 89)" class="i">value</span>, <span onmouseout="hideTip(event, 'fsbla32', 90)" onmouseover="showTip(event, 'fsbla32', 90)" class="i">reply</span>) 
<span class="l">13: </span>      <span class="k">return!</span> <span onmouseout="hideTip(event, 'fsbla18', 91)" onmouseover="showTip(event, 'fsbla18', 91)" class="i">nonEmptyQueue</span>()
<span class="l">14: </span>  | <span onmouseout="hideTip(event, 'fsbla7', 92)" onmouseover="showTip(event, 'fsbla7', 92)" class="i">Get</span>(<span onmouseout="hideTip(event, 'fsbla41', 93)" onmouseover="showTip(event, 'fsbla41', 93)" class="i">reply</span>) <span class="k">-&gt;</span> 
<span class="l">15: </span>      <span class="k">let</span> <span onmouseout="hideTip(event, 'fsbla42', 94)" onmouseover="showTip(event, 'fsbla42', 94)" class="i">item</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla13', 95)" onmouseover="showTip(event, 'fsbla13', 95)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla43', 96)" onmouseover="showTip(event, 'fsbla43', 96)" class="i">Dequeue</span>()
<span class="l">16: </span>      <span class="c">//</span><span class="c"> </span><span class="c">Unblock</span><span class="c"> </span><span class="c">some</span><span class="c"> </span><span class="c">blocked</span><span class="c"> </span><span class="c">callers</span><span class="c"> </span><span class="c">as</span><span class="c"> </span><span class="c">we</span><span class="c"> </span><span class="c">have</span><span class="c"> </span><span class="c">some</span><span class="c"> </span><span class="c">space</span><span class="c"> </span><span class="c">now</span>
<span class="l">17: </span>      <span class="k">while</span> <span onmouseout="hideTip(event, 'fsbla13', 97)" onmouseover="showTip(event, 'fsbla13', 97)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 98)" onmouseover="showTip(event, 'fsbla36', 98)" class="i">Count</span> <span class="o">&lt;</span> <span onmouseout="hideTip(event, 'fsbla9', 99)" onmouseover="showTip(event, 'fsbla9', 99)" class="i">maxLength</span> <span class="o">&amp;&amp;</span> <span onmouseout="hideTip(event, 'fsbla15', 100)" onmouseover="showTip(event, 'fsbla15', 100)" class="i">pending</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 101)" onmouseover="showTip(event, 'fsbla36', 101)" class="i">Count</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="k">do</span>
<span class="l">18: </span>        <span class="k">let</span> <span onmouseout="hideTip(event, 'fsbla44', 102)" onmouseover="showTip(event, 'fsbla44', 102)" class="i">itm</span>, <span onmouseout="hideTip(event, 'fsbla45', 103)" onmouseover="showTip(event, 'fsbla45', 103)" class="i">caller</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fsbla15', 104)" onmouseover="showTip(event, 'fsbla15', 104)" class="i">pending</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla46', 105)" onmouseover="showTip(event, 'fsbla46', 105)" class="i">Dequeue</span>()
<span class="l">19: </span>        <span onmouseout="hideTip(event, 'fsbla13', 106)" onmouseover="showTip(event, 'fsbla13', 106)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla35', 107)" onmouseover="showTip(event, 'fsbla35', 107)" class="i">Enqueue</span>(<span onmouseout="hideTip(event, 'fsbla44', 108)" onmouseover="showTip(event, 'fsbla44', 108)" class="i">itm</span>)
<span class="l">20: </span>        <span onmouseout="hideTip(event, 'fsbla45', 109)" onmouseover="showTip(event, 'fsbla45', 109)" class="i">caller</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla37', 110)" onmouseover="showTip(event, 'fsbla37', 110)" class="i">Reply</span>()
<span class="l">21: </span>      <span onmouseout="hideTip(event, 'fsbla22', 111)" onmouseover="showTip(event, 'fsbla22', 111)" class="i">count</span> <span class="o">&lt;-</span> <span onmouseout="hideTip(event, 'fsbla13', 112)" onmouseover="showTip(event, 'fsbla13', 112)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 113)" onmouseover="showTip(event, 'fsbla36', 113)" class="i">Count</span>
<span class="l">22: </span>      <span onmouseout="hideTip(event, 'fsbla41', 114)" onmouseover="showTip(event, 'fsbla41', 114)" class="i">reply</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla37', 115)" onmouseover="showTip(event, 'fsbla37', 115)" class="i">Reply</span>(<span onmouseout="hideTip(event, 'fsbla42', 116)" onmouseover="showTip(event, 'fsbla42', 116)" class="i">item</span>)
<span class="l">23: </span>      <span class="c">//</span><span class="c"> </span><span class="c">If</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">queue</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">empty</span><span class="c"> </span><span class="c">then</span><span class="c"> </span><span class="c">switch</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">state,</span><span class="c"> </span><span class="c">otherwise</span><span class="c"> </span><span class="c">loop</span>
<span class="l">24: </span>      <span class="k">if</span> <span onmouseout="hideTip(event, 'fsbla13', 117)" onmouseover="showTip(event, 'fsbla13', 117)" class="i">queue</span><span class="o">.</span><span onmouseout="hideTip(event, 'fsbla36', 118)" onmouseover="showTip(event, 'fsbla36', 118)" class="i">Count</span> <span class="o">=</span> <span class="n">0</span> <span class="k">then</span> <span class="k">return!</span> <span onmouseout="hideTip(event, 'fsbla16', 119)" onmouseover="showTip(event, 'fsbla16', 119)" class="i">emptyQueue</span>()
<span class="l">25: </span>      <span class="k">else</span> <span class="k">return!</span> <span onmouseout="hideTip(event, 'fsbla18', 120)" onmouseover="showTip(event, 'fsbla18', 120)" class="i">nonEmptyQueue</span>() }<a target="_blank" class="fssniplink" href="http://tomasp.net/fswebsnippets">F# Web Snippets</a>
</pre>

<p>When adding a value to a queue that is not full, we can immediately add the element using <code>queue.Enqueue</code>,
  update the number of elements and notify the caller that a value was successfully added. When the 
  queue is empty, we store the request in the <code>pending</code> queue, which keeps both a value
  to be added and a reply channel that can be later used to notify the caller.</p>
<p>When removing an element, we can always pick an element using the <code>queue.Dequeue</code> method,
  because we're in a state when the queue is not empty. After removing an element, we check if there
  are any pending calls. We use a loop that runs until the queue becomes full or until we process 
  all pending calls. In the body of the loop, we remove one pending call, add value to the queue and
  unblock the caller by replying to the asynchronous reply channel. Finally, we update <code>count</code>
  and send value to the original sender of the <code>Get</code> message. Then we continue in one
  of the two states, depending on whether the queue is now empty or not. </p>

<h2>Summary</h2>
<p>In this article, we looked at the implementation of an F# agent that implements a blocking queue
  that has a maximal number of elements. When getting an element from an empty queue or adding an 
  element to a full queue, the caller will be blocked until an element becomes available or an element
  is removed, respectively. The <code>BlockingQueueAgent&lt;T&gt;</code> type can be quite useful in 
  parallel programming using asynchronous workflows. I demonstrated how to work with the type
  <a href="http://tomasp.net/blog/parallel-extra-image-pipeline.html">another article</a>, which 
  uses it to implement an image processing pipeline. However, the agent can be useful in many
  parallel patterns other than pipeline processing.</p>
<p>Finally, the article is also a good demonstration of message-based parallelism using agents in 
  F#. We've seen a common overall structure of an agent encapsulated in a type. We used two 
  operations for receiving messages (<code>Scan</code> and <code>Receive</code>) and we also 
  used mutually recursive functions to encode a state machine that implements the behavior of an agent.</p>


<h2>Source Code</h2>
<ul>
  <li>Download <a href="http://tomasp.net/articles/parallel-extra/parallelextras.zip">F# Parallel Extras samples</a> (ZIP)</li>
  <li>Get the latest version of samples from <a href="http://fsharpsamples.codeplex.com/" type="external">F# Community Samples</a> at CodePlex</li></ul>

<!-- HTML code for ToolTips -->
<!-- HTML code for ToolTips -->
<div class="tip" id="fsbla1">type Agent&lt;'T&gt; = MailboxProcessor&lt;'T&gt;<br /><br />Full name: Untitled.Agent&lt;_&gt;<br /><br />&#160;&#160;type: Agent&lt;'T&gt;<br />&#160;&#160;implements: IDisposable<br />
<br /><br /><em>A convenience type alias for 'MailboxProcessor&lt;T&gt;' type</em><br /></div>
<div class="tip" id="fsbla2">type MailboxProcessor&lt;'Msg&gt; =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;interface IDisposable<br />&#160;&#160;&#160;&#160;new : body:(MailboxProcessor&lt;'Msg&gt; -&gt; Async&lt;unit&gt;) * ?cancellationToken:CancellationToken -&gt; MailboxProcessor&lt;'Msg&gt;<br />&#160;&#160;&#160;&#160;member Post : message:'Msg -&gt; unit<br />&#160;&#160;&#160;&#160;member PostAndAsyncReply : buildMessage:(AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg) * ?timeout:int -&gt; Async&lt;'Reply&gt;<br />&#160;&#160;&#160;&#160;member PostAndReply : buildMessage:(AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg) * ?timeout:int -&gt; 'Reply<br />&#160;&#160;&#160;&#160;member PostAndTryAsyncReply : buildMessage:(AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg) * ?timeout:int -&gt; Async&lt;'Reply option&gt;<br />&#160;&#160;&#160;&#160;member Receive : ?timeout:int -&gt; Async&lt;'Msg&gt;<br />&#160;&#160;&#160;&#160;member Scan : scanner:('Msg -&gt; Async&lt;'T&gt; option) * ?timeout:int -&gt; Async&lt;'T&gt;<br />&#160;&#160;&#160;&#160;member Start : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member TryPostAndReply : buildMessage:(AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg) * ?timeout:int -&gt; 'Reply option<br />&#160;&#160;&#160;&#160;member TryReceive : ?timeout:int -&gt; Async&lt;'Msg option&gt;<br />&#160;&#160;&#160;&#160;member TryScan : scanner:('Msg -&gt; Async&lt;'T&gt; option) * ?timeout:int -&gt; Async&lt;'T option&gt;<br />&#160;&#160;&#160;&#160;member add_Error : Handler&lt;Exception&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;member CurrentQueueLength : int<br />&#160;&#160;&#160;&#160;member DefaultTimeout : int<br />&#160;&#160;&#160;&#160;member Error : IEvent&lt;Exception&gt;<br />&#160;&#160;&#160;&#160;member remove_Error : Handler&lt;Exception&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;member DefaultTimeout : int with set<br />&#160;&#160;&#160;&#160;static member Start : body:(MailboxProcessor&lt;'Msg&gt; -&gt; Async&lt;unit&gt;) * ?cancellationToken:CancellationToken -&gt; MailboxProcessor&lt;'Msg&gt;<br />&#160;&#160;end<br /><br />Full name: Microsoft.FSharp.Control.MailboxProcessor&lt;_&gt;<br /><br />&#160;&#160;type: MailboxProcessor&lt;'Msg&gt;<br />&#160;&#160;implements: IDisposable<br /></div>
<div class="tip" id="fsbla3">type internal BlockingAgentMessage&lt;'T&gt; =<br />&#160;&#160;| Add of 'T * AsyncReplyChannel&lt;unit&gt;<br />&#160;&#160;| Get of AsyncReplyChannel&lt;'T&gt;<br /><br />Full name: Untitled.BlockingAgentMessage&lt;_&gt;<br /><br />&#160;&#160;type: BlockingAgentMessage&lt;'T&gt;<br />&#160;&#160;implements: IEquatable&lt;BlockingAgentMessage&lt;'T&gt;&gt;<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />
<br /><br /><em>Type of messages internally used by 'BlockingQueueAgent&lt;T&gt;'</em><br /></div>
<div class="tip" id="fsbla4">union case BlockingAgentMessage.Add: 'T * AsyncReplyChannel&lt;unit&gt; -&gt; BlockingAgentMessage&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla5">type AsyncReplyChannel&lt;'Reply&gt;<br />with<br />&#160;&#160;member Reply : value:'Reply -&gt; unit<br />end<br /><br />Full name: Microsoft.FSharp.Control.AsyncReplyChannel&lt;_&gt;<br /></div>
<div class="tip" id="fsbla6">type unit = Unit<br /><br />Full name: Microsoft.FSharp.Core.unit<br /><br />&#160;&#160;type: unit<br />&#160;&#160;implements: IComparable<br /></div>
<div class="tip" id="fsbla7">union case BlockingAgentMessage.Get: AsyncReplyChannel&lt;'T&gt; -&gt; BlockingAgentMessage&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla8">type BlockingQueueAgent&lt;'T&gt; =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : maxLength:int -&gt; BlockingQueueAgent&lt;'T&gt;<br />&#160;&#160;&#160;&#160;member AsyncAdd : v:'T * ?timeout:int -&gt; Async&lt;unit&gt;<br />&#160;&#160;&#160;&#160;member AsyncGet : ?timeout:int -&gt; Async&lt;'T&gt;<br />&#160;&#160;&#160;&#160;member Count : int<br />&#160;&#160;end<br /><br />Full name: Untitled.BlockingQueueAgent&lt;_&gt;
<br /><br /><em>Agent that implements an asynchronous blocking queue</em><br /></div>
<div class="tip" id="fsbla9">val maxLength : int<br /><br />&#160;&#160;type: int<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: IFormattable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;int&gt;<br />&#160;&#160;implements: IEquatable&lt;int&gt;<br />&#160;&#160;inherits: ValueType<br /></div>
<div class="tip" id="fsbla10">do <br />&#160;&#160;if maxLength &lt;= 0 then <br />&#160;&#160;&#160;&#160;invalidArg &quot;maxLenght&quot; &quot;Maximal length of the queue should be positive.&quot;<br /><br />// We keep the number of elements in the queue in a local field to<br />// make it immediately available (so that 'Count' property doesn't <br />// have to use messages - which would be a bit slower)<br />[&lt;VolatileField&gt;]<br />let mutable count = 0<br /></div>
<div class="tip" id="fsbla11">val agent : MailboxProcessor&lt;BlockingAgentMessage&lt;'T&gt;&gt;<br /><br />&#160;&#160;type: MailboxProcessor&lt;BlockingAgentMessage&lt;'T&gt;&gt;<br />&#160;&#160;implements: IDisposable<br /></div>
<div class="tip" id="fsbla12">static member MailboxProcessor.Start : body:(MailboxProcessor&lt;'Msg&gt; -&gt; Async&lt;unit&gt;) * ?cancellationToken:CancellationToken -&gt; MailboxProcessor&lt;'Msg&gt;<br /></div>
<div class="tip" id="fsbla13">val queue : Queue&lt;'T&gt;<br /><br />&#160;&#160;type: Queue&lt;'T&gt;<br />&#160;&#160;implements: seq&lt;'T&gt;<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fsbla14">type Queue&lt;'T&gt; =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : unit -&gt; System.Collections.Generic.Queue&lt;'T&gt;<br />&#160;&#160;&#160;&#160;new : int -&gt; System.Collections.Generic.Queue&lt;'T&gt;<br />&#160;&#160;&#160;&#160;new : System.Collections.Generic.IEnumerable&lt;'T&gt; -&gt; System.Collections.Generic.Queue&lt;'T&gt;<br />&#160;&#160;&#160;&#160;member Clear : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Contains : 'T -&gt; bool<br />&#160;&#160;&#160;&#160;member CopyTo : 'T [] * int -&gt; unit<br />&#160;&#160;&#160;&#160;member Count : int<br />&#160;&#160;&#160;&#160;member Dequeue : unit -&gt; 'T<br />&#160;&#160;&#160;&#160;member Enqueue : 'T -&gt; unit<br />&#160;&#160;&#160;&#160;member GetEnumerator : unit -&gt; Enumerator&lt;'T&gt;<br />&#160;&#160;&#160;&#160;member Peek : unit -&gt; 'T<br />&#160;&#160;&#160;&#160;member ToArray : unit -&gt; 'T []<br />&#160;&#160;&#160;&#160;member TrimExcess : unit -&gt; unit<br />&#160;&#160;&#160;&#160;type Enumerator =<br />&#160;&#160;&#160;&#160;&#160;&#160;struct<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;member Current : 'T<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;member Dispose : unit -&gt; unit<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;member MoveNext : unit -&gt; bool<br />&#160;&#160;&#160;&#160;&#160;&#160;end<br />&#160;&#160;end<br /><br />Full name: System.Collections.Generic.Queue&lt;_&gt;<br /><br />&#160;&#160;type: Queue&lt;'T&gt;<br />&#160;&#160;implements: seq&lt;'T&gt;<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fsbla15">val pending : Queue&lt;'T * AsyncReplyChannel&lt;unit&gt;&gt;<br /><br />&#160;&#160;type: Queue&lt;'T * AsyncReplyChannel&lt;unit&gt;&gt;<br />&#160;&#160;implements: seq&lt;'T * AsyncReplyChannel&lt;unit&gt;&gt;<br />&#160;&#160;implements: Collections.ICollection<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fsbla16">val emptyQueue : (unit -&gt; Async&lt;'a&gt;)<br /></div>
<div class="tip" id="fsbla17">agent.Scan(fun msg -&gt;<br />&#160;&#160;match msg with <br />&#160;&#160;| Add(value, reply) -&gt; Some &lt;| async {<br />&#160;&#160;&#160;&#160;&#160;&#160;queue.Enqueue(value)<br />&#160;&#160;&#160;&#160;&#160;&#160;count &lt;- queue.Count<br />&#160;&#160;&#160;&#160;&#160;&#160;reply.Reply()<br />&#160;&#160;&#160;&#160;&#160;&#160;return! nonEmptyQueue() }<br />&#160;&#160;| _ -&gt; None )<br /></div>
<div class="tip" id="fsbla18">val nonEmptyQueue : (unit -&gt; Async&lt;'a&gt;)<br /></div>
<div class="tip" id="fsbla19">async {<br />&#160;&#160;let! msg = agent.Receive()<br />&#160;&#160;match msg with <br />&#160;&#160;| Add(value, reply) -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;// Add immediately if possibley, otherwise block caller<br />&#160;&#160;&#160;&#160;&#160;&#160;if queue.Count &lt; maxLength then <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;queue.Enqueue(value)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count &lt;- queue.Count<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reply.Reply()<br />&#160;&#160;&#160;&#160;&#160;&#160;else <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pending.Enqueue(value, reply) <br />&#160;&#160;&#160;&#160;&#160;&#160;return! nonEmptyQueue()<br />&#160;&#160;| Get(reply) -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;let item = queue.Dequeue()<br />&#160;&#160;&#160;&#160;&#160;&#160;// Unblock some blocked callers as we have some space now<br />&#160;&#160;&#160;&#160;&#160;&#160;while queue.Count &lt; maxLength &amp;&amp; pending.Count &gt; 0 do<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let itm, caller = pending.Dequeue()<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;queue.Enqueue(itm)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;caller.Reply()<br />&#160;&#160;&#160;&#160;&#160;&#160;count &lt;- queue.Count<br />&#160;&#160;&#160;&#160;&#160;&#160;reply.Reply(item)<br />&#160;&#160;&#160;&#160;&#160;&#160;// If the queue is empty then switch the state, otherwise loop<br />&#160;&#160;&#160;&#160;&#160;&#160;if queue.Count = 0 then return! emptyQueue()<br />&#160;&#160;&#160;&#160;&#160;&#160;else return! nonEmptyQueue() }<br /></div>
<div class="tip" id="fsbla20">val x : BlockingQueueAgent&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla21">member BlockingQueueAgent.Count : int<br /><br />Full name: Untitled.BlockingQueueAgent`1.Count
<br /><br /><em>Returns the number of items in the queue (immediately)</em><br /></div>
<div class="tip" id="fsbla22">val mutable count : int<br /><br />&#160;&#160;type: int<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: IFormattable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;int&gt;<br />&#160;&#160;implements: IEquatable&lt;int&gt;<br />&#160;&#160;inherits: ValueType<br /></div>
<div class="tip" id="fsbla23">member BlockingQueueAgent.AsyncAdd : v:'T * ?timeout:int -&gt; Async&lt;unit&gt;<br /><br />Full name: Untitled.BlockingQueueAgent`1.AsyncAdd
<br /><br /><em>Asynchronously adds item; blocks if queue is full</em><br /></div>
<div class="tip" id="fsbla24">val v : 'T<br /></div>
<div class="tip" id="fsbla25">val timeout : int option<br /><br />&#160;&#160;type: int option<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: IComparable&lt;Option&lt;int&gt;&gt;<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: Collections.IStructuralComparable<br /></div>
<div class="tip" id="fsbla26">member MailboxProcessor.PostAndAsyncReply : buildMessage:(AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg) * ?timeout:int -&gt; Async&lt;'Reply&gt;<br /></div>
<div class="tip" id="fsbla27">val ch : AsyncReplyChannel&lt;unit&gt;<br /></div>
<div class="tip" id="fsbla28">member BlockingQueueAgent.AsyncGet : ?timeout:int -&gt; Async&lt;'T&gt;<br /><br />Full name: Untitled.BlockingQueueAgent`1.AsyncGet
<br /><br /><em>Asynchronously gets item; blocks if queue is empty</em><br /></div>
<div class="tip" id="fsbla29">member MailboxProcessor.Scan : scanner:('Msg -&gt; Async&lt;'T&gt; option) * ?timeout:int -&gt; Async&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla30">val msg : BlockingAgentMessage&lt;'T&gt;<br /><br />&#160;&#160;type: BlockingAgentMessage&lt;'T&gt;<br />&#160;&#160;implements: IEquatable&lt;BlockingAgentMessage&lt;'T&gt;&gt;<br />&#160;&#160;implements: Collections.IStructuralEquatable<br /></div>
<div class="tip" id="fsbla31">val value : 'T<br /></div>
<div class="tip" id="fsbla32">val reply : AsyncReplyChannel&lt;unit&gt;<br /></div>
<div class="tip" id="fsbla33">union case Option.Some: 'T -&gt; Option&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla34">val async : AsyncBuilder<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.async<br /></div>
<div class="tip" id="fsbla35">Queue.Enqueue(item: 'T) : unit<br /></div>
<div class="tip" id="fsbla36">property Queue.Count: int<br /></div>
<div class="tip" id="fsbla37">member AsyncReplyChannel.Reply : value:'Reply -&gt; unit<br /></div>
<div class="tip" id="fsbla38">union case Option.None: Option&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla39">member MailboxProcessor.Receive : ?timeout:int -&gt; Async&lt;'Msg&gt;<br /></div>
<div class="tip" id="fsbla40">Queue.Enqueue(item: 'T * AsyncReplyChannel&lt;unit&gt;) : unit<br /></div>
<div class="tip" id="fsbla41">val reply : AsyncReplyChannel&lt;'T&gt;<br /></div>
<div class="tip" id="fsbla42">val item : 'T<br /></div>
<div class="tip" id="fsbla43">Queue.Dequeue() : 'T<br /></div>
<div class="tip" id="fsbla44">val itm : 'T<br /></div>
<div class="tip" id="fsbla45">val caller : AsyncReplyChannel&lt;unit&gt;<br /></div>
<div class="tip" id="fsbla46">Queue.Dequeue() : 'T * AsyncReplyChannel&lt;unit&gt;<br /></div>

    <div class="info">
    <p class="share">
        <a target="_blank" href="https://twitter.com/intent/tweet?url=http%3a%2f%2ftomasp.net%2fblog%2fparallel-extra-blockingagent.aspx%2f&amp;text=F%23+Parallel+Extras+(II.)%3a+Agent-based+blocking+queuevia+%40tomaspetricek">
          <i class="fab fa-twitter-square"></i></a>
        <a target="_blank" href="https://www.facebook.com/sharer.php?u=http%3a%2f%2ftomasp.net%2fblog%2fparallel-extra-blockingagent.aspx%2f">
          <i class="fab fa-facebook-square"></i></a>
        <a href="http://www.reddit.com/submit?url=http%3a%2f%2ftomasp.net%2fblog%2fparallel-extra-blockingagent.aspx%2f&title=F%23+Parallel+Extras+(II.)%3a+Agent-based+blocking+queue">
          <i class="fab fa-reddit-square"></i></a>
        <a href="mailto:?subject=F%23%20Parallel%20Extras%20(II.)%3a%20Agent-based%20blocking%20queue&body=%20In%20this%20article%2c%20we%27ll%20look%20at%20type%20that%20implements%20an%20(asynchronous)%20blocking%20queue%20using%20F%23%20agents.%20This%20can%20be%20used%2c%20for%20example%2c%20when%20implementing%20the%20pipeline%20pattern%20as%20demonstrated%20in%20the%20previous%20article.%0a%0aSee%3a%20http%3a%2f%2ftomasp.net%2fblog%2fparallel-extra-blockingagent.aspx%2f">
          <i class="fa fa-envelope"></i></a>
    </p>
    <p class="details">
      <strong>Published:</strong> Wednesday, 27 October 2010, 11:12 AM<br />
      <strong>Author:</strong> Tomas Petricek<br />
      <strong>Typos:</strong> <a href="http://github.com/tpetricek/tomasp.net">Send me a pull request</a>!<br />
      
        <strong>Tags:</strong> <a
          href="/blog/tag/functional/">functional</a>, <a
          href="/blog/tag/parallel/">parallel</a>, <a
          href="/blog/tag/asynchronous/">asynchronous</a>, <a
          href="/blog/tag/fsharp/">f#</a></span><br />
      
    </p>
    </div>
  </article>


  <footer>
  <div class="footer-body">
    <div class="fl70"><div class="fmr">
      <h4><a href="http://tomasp.net/rss.xml"><i class="fa fa-rss" style="margin-right:5px;"></i></a> Blog archives</h4>
      <p>
      
      <a href="/blog/archive/february_2025/">February 2025 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2023/">December 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2023/">February 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2022/">September 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2022/">April 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2021/">October 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2021/">April 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2020/">October 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2020/">July 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2020/">April 2020 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2019/">December 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2019/">February 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2018/">November 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2018/">October 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2018/">May 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2017/">September 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2017/">June 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2017/">April 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2017/">March 2017 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2017/">January 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2016/">October 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2016/">September 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/august_2016/">August 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2016/">July 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2016/">May 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2016/">April 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2015/">December 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2015/">November 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2015/">September 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2015/">July 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2015/">June 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2015/">May 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2015/">April 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2015/">March 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2015/">February 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2015/">January 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2014/">December 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2014/">May 2014 (3)</a>,&nbsp;
      
      <a href="/blog/archive/april_2014/">April 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2014/">March 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2014/">January 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2013/">December 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2013/">November 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2013/">October 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2013/">September 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2013/">August 2013 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2013/">May 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2013/">April 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2013/">March 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2013/">February 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2013/">January 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2012/">December 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/october_2012/">October 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2012/">August 2012 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2012/">June 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2012/">April 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2012/">March 2012 (4)</a>,&nbsp;
      
      <a href="/blog/archive/february_2012/">February 2012 (5)</a>,&nbsp;
      
      <a href="/blog/archive/january_2012/">January 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2011/">November 2011 (5)</a>,&nbsp;
      
      <a href="/blog/archive/august_2011/">August 2011 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2011/">July 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/june_2011/">June 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2011/">May 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2011/">March 2011 (4)</a>,&nbsp;
      
      <a href="/blog/archive/december_2010/">December 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2010/">November 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2010/">October 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/september_2010/">September 2010 (4)</a>,&nbsp;
      
      <a href="/blog/archive/july_2010/">July 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2010/">June 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2010/">May 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2010/">February 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2010/">January 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/december_2009/">December 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2009/">July 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2009/">June 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2009/">May 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2009/">April 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2009/">March 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2009/">February 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2008/">December 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2008/">November 2008 (5)</a>,&nbsp;
      
      <a href="/blog/archive/october_2008/">October 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2008/">September 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2008/">June 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2008/">March 2008 (3)</a>,&nbsp;
      
      <a href="/blog/archive/february_2008/">February 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2007/">December 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2007/">November 2007 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2007/">October 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2007/">September 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2007/">August 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2007/">July 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2007/">April 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2007/">March 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2007/">February 2007 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2007/">January 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2006/">November 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2006/">October 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/august_2006/">August 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/july_2006/">July 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2006/">June 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2006/">May 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2006/">April 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2005/">December 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2005/">July 2005 (4)</a>,&nbsp;
      
      <a href="/blog/archive/june_2005/">June 2005 (5)</a>,&nbsp;
      
      <a href="/blog/archive/may_2005/">May 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2005/">April 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2005/">March 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2005/">January 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2004/">December 2004 (3)</a>,&nbsp;
      
      <a href="/blog/archive/november_2004/">November 2004 (2)</a>,&nbsp;
      
      </p>
    </div></div>
    <div class="fr30"><div class="fmr">
      <h4>License and about</h4>
      <p>All articles on this site are licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share Alike</a>.
        All source code samples are licensed under the MIT License.
      </p>
      <p>This site is hosted on GitHub and is generated using <a href="https://github.com/tpetricek/FSharp.Formatting">F# Formatting</a>
        and <a href="http://dotliquidmarkup.org/">DotLiquid</a>.
        For more info, see the <a href="https://github.com/tpetricek/tomasp.net">website source on GitHub</a>.
      </p>
      <p>Please submit issues &amp; corrections on GitHub. Use pull requests for minor corrections only.</p>
      <ul>
        <li><i class="fab fa-twitter"></i> Twitter: <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a></li>
        <li><i class="fab fa-github"></i> GitHub: <a href="https://github.com/tpetricek">@tpetricek</a></li>
        <li><i class="fa fa-envelope"></i> Email: <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a></li>
      </ul>
      <p style="text-align:center;margin-top:15px;"><img src="https://tomasp.net/img/cc-sa.png" alt="CC License logo" /></p>
    </div></div>
  </div>
  </footer>

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-1561220-1']);
    _gaq.push(['_trackPageview']);
    (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</body>
</html>
