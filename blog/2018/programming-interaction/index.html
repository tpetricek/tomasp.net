<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <meta name=viewport content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Droid+Sans+Mono&family=Kreon:wght@300;400;500;600&family=PT+Sans:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet"> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" integrity="sha512-HK5fgLBL+xu6dm/Ii3z4xhlSUyZgTT9tuc/hSrtw6uzJOvgRr2a9jyxxT1ely+B+xFAmJKVSTbpM/CuL7qxO8w==" crossorigin="anonymous" />
  <link rel="alternate" type="application/rss+xml" title="Latest news from Tomas Petricek" href="/rss.xml" />
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>  
  <link href="/custom/style.css" rel="stylesheet">
  <link href="/custom/tooltips.css" rel="stylesheet">
  <script src="/custom/tooltips.js" type="text/javascript"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon-big.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/img/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/img/favicon-big.png">
  <meta name="msapplication-TileColor" content="#004C6B">
  <meta name="msapplication-TileImage" content="/img/favicon-big.png">
  <meta name="theme-color" content="#004C6B">    
  
  <title>Programming as interaction: A new perspective for programming language research - Tomas Petricek</title>

  <meta name="description" content=" In programming research, we say a lot about programs and languages, but very little
about the actual process of programming. One simple trick that will make programming language
research significantly more interesting is to think about programs not as expressions, but as
a result of a sequence of interactions that create it. This includes usual things such as
writing code and refactoring, but if we also include, say, running a part of the program,
we become capable of saying many more interesting things and building new powerful programming tools." />
  <meta name="keywords" content="academic, research, programming languages, data science, " />  
  <meta name="author" content="Tomas Petricek" />
  <meta name="copyright" content="Tomas Petricek" />
  
  <meta property="og:title" content="Programming as interaction: A new perspective for programming language research" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://tomasp.net/blog/2018/programming-interaction/" />
  <meta property="og:image" content="http://tomasp.net/blog/2018/programming-interaction/kent-sq.png" />
  <meta property="og:description" content=" In programming research, we say a lot about programs and languages, but very little
about the actual process of programming. One simple trick that will make programming language
research significantly more interesting is to think about programs not as expressions, but as
a result of a sequence of interactions that create it. This includes usual things such as
writing code and refactoring, but if we also include, say, running a part of the program,
we become capable of saying many more interesting things and building new powerful programming tools." />
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:site" content="@tomaspetricek">
  <meta name="twitter:creator" content="@tomaspetricek">  
  <meta name="twitter:title" content="Programming as interaction: A new perspective for programming language research" />
  <meta name="twitter:image" content="http://tomasp.net/blog/2018/programming-interaction/kent-sq.png" />
  <meta name="twitter:description" content=" In programming research, we say a lot about programs and languages, but very little
about the actual process of programming. One simple trick that will make programming language
research significantly more interesting is to think about programs not as expressions, but as
a result of a sequence of interactions that create it. This includes usual things such as
writing code and refactoring, but if we also include, say, running a part of the program,
we become capable of saying many more interesting things and building new powerful programming tools." />
    
  <script type="application/ld+json">
  {
  	"@context": "http:\/\/schema.org",
  	"@type": "Article",
  	"name": "Programming as interaction: A new perspective for programming language research",
    "headline": "Programming as interaction: A new perspective for programming language research",
  	"description": " In programming research, we say a lot about programs and languages, but very little
about the actual process of programming. One simple trick that will make programming language
research significantly more interesting is to think about programs not as expressions, but as
a result of a sequence of interactions that create it. This includes usual things such as
writing code and refactoring, but if we also include, say, running a part of the program,
we become capable of saying many more interesting things and building new powerful programming tools.",
  	"url": "http://tomasp.net/blog/2018/programming-interaction/",
  	"author": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	},
  	"creator": ["Tomas Petricek"],
  	"dateCreated": "2018-10-08T13:22:57.7521867+02:00",
  	"datePublished": "2018-10-08T13:22:57.7521867+02:00",
    "dateModified": "2018-10-08T13:22:57.7521867+02:00",
    "mainEntityOfPage": "http://tomasp.net/blog/2018/programming-interaction/",
  	"image": "http://tomasp.net/blog/2018/programming-interaction/kent-sq.png",
  	"thumbnailUrl": "http://tomasp.net/blog/2018/programming-interaction/kent-sq.png",
  	"keywords": ["academic", "research", "programming languages", "data science",  "tomas", "petricek"],
  	"inLanguage": "en-us",
  	"publisher": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
      "logo": "http://tomasp.net/img/favicon-big.png",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	}
  }  
  </script>
  
</head>
<body class="default">  
    
  <span class="tplink"><a href="/">TP</a></span>

  <article class='article''>
    <h1><span class="hm">Programming as interaction</span><span class="hs"> A new perspective for programming language research</span></h1>
<p>In May, I joined the <a href="https://www.cs.kent.ac.uk/">School of Computing</a> at the <a href="https://www.kent.ac.uk/">University of
Kent</a> as a Lecturer (equivalent of Assistant Professor in some other countries).
When applying for the job, I spent a lot of time thinking about how to best explain the kind of
research that I would like to do. This blog post is a brief summary of my ideas. I'm interested
in way too many things, including <a href="http://tomasp.net/blog/tag/philosophy/">philosophy and design</a> and
<a href="http://tomasp.net/blog/tag/data-journalism/">data journalism</a>, but this post will be mainly about
programming language research. After all, I'm a member of the <a href="https://www.cs.kent.ac.uk/research/groups/plas/">Programming Languages
and Systems group</a>!</p>
<img src="http://tomasp.net/blog/2018/programming-interaction/kent.png" class="rdecor-sm" style="max-width:250px"/>
<p>Unlike some of my <a href="http://tomasp.net/blog/2016/thinking-unthinkable/">other posts about programming languages</a>,
I won't try to convince you that we should be studying programming languages completely differently this
time. Instead, I want to describe <em>one simple trick that will make current programming language
research much more interesting</em>!</p>
<p>A lot of programming language papers today talk about programs and program properties. In
statically typed programming languages, we can check that a program <span class="math">\(e\)</span> has certain type <span class="math">\(\tau\)</span>,
which means that, when the program is run, it will only produce values of the type.
This is very nice, but it misses a fundamental thing about programming. How was this program
<span class="math">\(e\)</span> actually constructed?</p>
<p>When programming, you spend most of your time working with programs that are <em>unfinished</em>. This
means that they do not do what they are supposed to be (eventually) doing and, very often, they
are not well-typed or even syntactically invalid. However, that does not mean that we can afford
to ignore them. In many cases, programmers can even run those programs (using REPL or using a
notebook environment). In other words, programming language research should not study <em>programs</em>,
but should instead study <em>programming</em>!</p>
<blockquote>
<p><em><i class="fa fa-hand-o-right" style="font-size:110%;margin:0px 5px 0px 0px"></i></em>
I'm also writing this because I'll soon be looking for collaborators and PhD students,
so if the ideas in this blog post sound interesting to you or if you've been working on
something related, please let me know! You can get in touch at <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a>
or email <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a>.</p>
<p>We'll have funding for PhD students from September 2019 and I'm also working on getting money
for a post-doc position. All of these are open ended, so if the blog post made you curious
(and you wouldn't mind living in Canterbury or London), definitely reach out!</p>
</blockquote>
<h2>Why we should study programming as interaction</h2>
<p>What do I mean when I say that we should <em>study programming</em>? When you are programming, you are not
writing code by starting on the first line, furiously typing and ending on the last line.
(If a theoretician says, <em>given a program <span class="math">\(e\)</span></em>, this might well be how the program came to existence.)
Instead, you start by writing some small piece of code, then test it, refine it, add some more
code and so on. You also typically use various modern editor tools such as auto-complete.
Let's look at a simple example using F#.</p>
<div class="wdecor container">
<div class="row">
  <div class="col-md-9">
    <img src="dice.gif" style="display:none" id="img1a" />
    <img src="dice-still.png" style="cursor:pointer;max-width:100%;margin-bottom:10px" id="img1b" /><br />
    <script type="text/javascript">
      var p1 = false;
      document.getElementById("img1b").onclick = function() {
        document.getElementById("img1b").src = p1 ? "dice-still.png" : document.getElementById("img1a").src;
        p1 = !p1;
      }
    </script>
  </div>
  <div class="col-md-3" style="text-align:left;">
<p><strong>Example 1.</strong> Writing a function that models a dice using F# and F# interactive REPL to run
parts of code interactively during the development.</p>
<p>(Click on the image to play it and then click again to stop it or <a href="dice.gif">open the image in a new window</a>.)</p>
<p></div>
</div>
</div></p>
<p>I intentionally picked a very basic example, but even this illustrates a number of interactions
that happen during programming. Now, imagine that they were not just interactions with the
editor, but actually something that the programming language understands!</p>
<ul>
<li>
<p><strong>Code completion.</strong> The demo uses auto-completion to enter some long names. All modern
editors do this, but few language designers think about this. Selecting an item from a list
is way easier than typing a name or a piece of code. How could we design a language that
makes as much as possible available through <em>selection</em>? (I did a bit of work on this in
my <a href="http://tomasp.net/academic/papers/pivot/">dot-driven data exploration</a> paper.)</p>
</li>
<li>
<p><strong>Running code in REPL.</strong> In the demo, I use REPL to check that my code returns values in
the correct range. In F#, you can do this by selecting block of code and evaluating it, but
alternative model is to type directly into the REPL console. Again, this is just an editor
feature and the language does not understand it. What if it helped me to make sure that the
code I select will run?</p>
</li>
<li>
<p><strong>Introducing a function.</strong> After testing the code, I wrap it in a function. Many editors
have a refactoring for doing this, but again, the language does not know how the function
was created. If it knew that, could it then suggest that the value 6 might be a good example
input for the parameter <code>sides</code> and perhaps even use it automatically when I try to run
the body in REPL? (I wrote about <a href="http://tomasp.net/blog/2016/no-functions/">problems with functions</a>
on this blog before.)</p>
</li>
</ul>
<p>My first example was writing extremely basic piece of code in a statically typed functional
language. When creating a service or an application, you want to produce a program as the final
result, even though you may use REPL, auto-complete and refactoring tools along the way. Things
get even more interesting if we look at typical data science workflow. In data science, the end
result is often not the program, but instead some insight, model, or a visualization.</p>
<p>This needs a more interactive environment that makes it easy to run snippets of code on the fly
and see results immediately, which is why notebooks systems such as <a href="http://jupyter.org/">Jupyter</a>
became so popular. When writing code in notebooks, there is even more room for studying programming
interactions. The following is a small example of loading CSV file into F# notebook hosted on
<a href="https://notebooks.azure.com">Azure Notebooks</a>.</p>
<div class="wdecor container">
<div class="row">
  <div class="col-md-9">
    <img src="jupyter.gif" style="display:none" id="img2a" />
    <img src="jupyter-still.png" style="cursor:pointer;max-width:100%" id="img2b" /><br />
    <script type="text/javascript">
      var p2 = false;
      document.getElementById("img2b").onclick = function() {
        document.getElementById("img2b").src = p2 ? "jupyter-still.png" : document.getElementById("img2a").src;
        p2 = !p2;
      }
    </script>
  </div>
  <div class="col-md-3" style="text-align:left;">
<p><strong>Example 2.</strong> Running code that loads stock data and calculates an average opening price
using an F# data frame library in Jupyter notebook.</p>
<p>(Click on the image to play it and then click again to stop it or <a href="jupyter.gif">open the image in a new window</a>.)</p>
<p></div>
</div>
</div></p>
<p>The example uses the <a href="http://fslab.org/Deedle">Deedle library</a> together with a CSV parser to
read data from the internet and do a simple calculation with it. I first run a bit of code I
wrote before and then try to write some new code to perform a simple calculation. There is
a couple of interesting things happening in notebook systems.</p>
<ul>
<li>
<p><strong>Understanding the dependencies.</strong> I run cells from top to bottom, but that's not always
required. You can go back and rerun an earlier cell. What your program returns depends on
how you interact with it! Could a better data science language understand the dependencies
between cells and recommend what interactions are reasonable and which are not? And could
the system also remember how we interact to make the results reproducible? (Our work on
<a href="http://tomasp.net/academic/papers/wrattler/">Wrattler</a> in the Alan Turing Institute is
looking into this.)</p>
</li>
<li>
<p><strong>Live previews and editors.</strong> An inherent part of any notebook system is that it displays
previews of results such as the data frame in this demo. In Jupyter, this happens only when
you explicitly run the program, but what if the previews were created on the fly as you write
code? How do we design programming interactions so that code always has a valid preview?
And how do we design libraries that allow us to gradually construct results, such as data
visualizations? (Live previews in <a href="https://thegamma.net/">TheGamma</a> do some of this.)</p>
</li>
<li>
<p><strong>Typing for notebooks.</strong> In the example, the type of the <code>ms</code> data frame is
<code>Frame&lt;DateTime, string&gt;</code>. This says that rows are indexed by <code>DateTime</code> and columns are
indexed by <code>string</code>, but the type does not know anything about the names and types of the
columns in the data frame. This is hardly surprising, because the data come from a live URL!
Consequently, we have to write rather ugly <code>ms.GetColumn&lt;float&gt;("Open")</code> rather than just
<code>ms.Open</code>. However, what if running the cell that loads the data gave the type checker more
information about the data frame and the type in a later cell was refined based on this
information?</p>
</li>
</ul>
<h2>Theory of programming interactions</h2>
<p>There are many kinds of programming interactions that happen during programming. Some of those
have been studied in programming language research already. For example, my new colleagues are
building <a href="http://gow.epsrc.ac.uk/NGBOViewGrant.aspx?GrantRef=EP/N028759/1">verified refactorings</a>.
However, this is still treating programs just as lines of source code or parsed expressions and
the refactoring happens on the side by transforming one program into another.</p>
<p>I believe that we can achieve more interesting things if we stop thinking about programs as
code (or expressions), but instead think of them as <em>results of series of interactions</em>.
This representation will make us think about programming differently, because the key entity will
no longer be a <em>program</em>, but the <em>programming</em> process. However, having a record of how the
program was constructed will also let us build new programming tools.</p>
<h3>Different kinds of interactions</h3>
<p>What kinds of interactions can be used to create a program? I do not have a complete list, but
the following are some of the interactions I find important:</p>
<ul>
<li>
<em>Editing</em> - There will always be some basic coding interactions that will just modify some
part of the source code or edit some part of the expression tree.
</li>
<li><em>Selection</em> - Selecting from an auto-complete should be treated as a separate kind of interaction.</li>
<li>
<em>Evaluation</em> - When you run some part of the code in REPL, we should remember this happened, 
because it gives us useful information that we can use later.
</li>
<li>
<em>Copy and paste</em> - Copy and paste is frowned upon, but it's often the easier and more readable
than using complex abstractions. Knowing how it was used lets us solve some of the problems
attributed to it.
</li>
<li>
<em>Refactoring</em> - All the different refactorings that exist should also be treated as recorded
interactions that were used to construct the program.
</li>
</ul>
<p>This list is mostly based on what usual editors these days offer. The list does not even include
different kind of interactions that might happen in more sophisticated notebook systems.
Very likely, new programming languages and new editors will make it possible to have even more
fine-grained information about different interactions. However, treating a program as a result
of a series of the above interactions (as opposed to just the final text) already makes it
possible to implement a number of interesting tools!</p>
<h3>What new tools could offer</h3>
<p>Let's say that our programming environment keeps a list of interactions (such as those above)
that happened during programming. Similar pattern keeps appearing in many places in software.
If you wish, you can think of this as a very fine-grained version control system (storing a diff,
with a commit after each interaction). Alternatively, you can think of this as an editor based on
the idea of event-sourcing or a system following the Elm-style architecture. What kind of new
things would this enable?</p>
<ul>
<li>
<p><strong>Reliable copy and paste.</strong> If copy and paste was an interaction, the environment would know
that a certain part of code is copied from somewhere else. If you changed it in one place, the
editor could ask whether you want this change to happen just in this one place or in all other
places where the code appears. (The <a href="http://www.subtext-lang.org">Subtext programming language</a>
treats copy and paste in this way.)</p>
</li>
<li>
<p><strong>Interaction-based typing.</strong> Type checking can also be done over the interaction list, rather
than over the expression tree of a program at one point in time. This means that a type can
be, in part, based on earlier interactions including running a part of code. It can, for example,
be based on the structure of data loaded in earlier steps (as in notebooks) or even use sample
values from REPL to give a probabilistic type (floating-point number with values that are
typically in a certain range).</p>
</li>
<li>
<p><strong>Direct program manipulation.</strong> This is a more fancy idea that could be very useful in the
data science context. If we can give preview of a data frame as a table, could we also allow
the user to edit data in the data frame? This could be tracked as another kind of interaction
(making the program reproducible), but it should also play well with <em>extract function</em>
refactoring, which would produce a function that applies the same edit operation to a given input.</p>
</li>
<li>
<p><strong>Automatic selection correction.</strong> Let's say that you write a program and select a member
<code>Substr</code> but then the library author renames the member to <code>Substring</code> using the <em>rename</em>
refactoring. If the library is also a list of interactions, we can automatically suggest
a fix for the user code using the library. If the library is opaque, we could at least go through
all selection interactions that fail against the new version and ask the programmer to make
their own choice.</p>
</li>
<li>
<p><strong>Semantic merging.</strong> Finally, we could also have a more clever merging algorithm than just
diff3. Given two sequences of interactions that diverge at some point, we would need to find a
way to append all the new interactions so that the resulting program makes sense. This could,
for example, mean that refactoring done in one branch (and recorded as an interaction) will not
conflict with manual edit of the refactored code in another branch.</p>
</li>
</ul>
<p>All of these ideas are based on the simple list of interactions above, but I suspect that once
someone actually implements a programming language based on these ideas, it will become much
easier to imagine other kinds of interactions and other kinds of new tools and operations this
would enable.</p>
<h3>Related work and historical notes</h3>
<p>As I mentioned throughout the blog post, there is a number of related ideas. The <a href="https://guide.elm-lang.org/architecture/">Elm
architecture</a> (also known as the Model-Update-View pattern)
follows a similar idea by having a list of events and computing the current state from the history
of events. In an enterprise architecture, similar idea appeared as <a href="https://martinfowler.com/eaaDev/EventSourcing.html">Event
sourcing</a>. Here, you all actions done in a
system are recorded as events and the system state can be obtained by replaying the events.
Treating programs as list of interactions is very similar to these. We store the list (history) of
interactions that were used to construct the program.</p>
<p>Focusing on interactions is not a new idea either. The <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk system</a>
is a great example of a programming environment that focused on the human interaction. Different
kinds of interactions have also been developed and studied in the past, including REPLs
(Read-Eval-Print loops) and refactorings. However, these are typically treated as external tools
that work on programs, rather than an inherent part of the programming language itself.
Perhaps the closest work to the idea described in the blog post is the <a href="http://www.subtext-lang.org/">Subtext
language</a> by Jonathan Edwards. Among other things, it
has a first-class support for <a href="http://www.subtext-lang.org/OOPSLA06.pdf">copy and paste</a>.</p>
<p>A curious reference that is well worth reading is the 1983 paper <a href="https://www.semanticscholar.org/paper/First-Steps-Towards-Inferential-Programming-Scherlis-Scott/c07a69e65cabfa015d19730a02d2140cc9709a56">First Steps Towards Inferential
Programming</a> by William Scherlis and Dana Scott. As far as I can tell, nobody ever took the
next steps. The paper shares the motivation with this blog post. To quote
<em>"Our basic premise is that the ability to construct and modify programs will not improve without
a new and comprehensive look at the entire programming process."</em> The authors note that existing
work often looks at individual programs but that <em>"little has been done (...) to develop a sound
understanding of the process of programming - the process by which programs evolve in concept and
in practice."</em> The authors have a slightly different take on the subject and focus how you could
co-develop a specification of a program with the program itself (by refining both via a series
of interactions), but it is very interesting to see that the idea appeared already in 1980s!</p>
<h2>Conclusions</h2>
<p>Modern programming language research has certainly produced some useful programming tools,
but I believe that we are a <a href="http://tomasp.net/blog/2016/thinking-unthinkable/">bit stuck in thinking about programming languages in one
particular way</a>. There are many alternatives
worth exploring. Most fundamentally, mathematical approach to computer science is just one
approach and I think we are <a href="http://tomasp.net/blog/2017/programming-mythology/">using it in ways that might, in the future, appear
unreasonable</a>. Many good ideas could be learned
from <a href="http://tomasp.net/blog/2017/design-side-of-pl/">design</a>, urban planning, sociology and
other disciplines.</p>
<p>That said, this blog post advocates a much less revolutionary research idea. To borrow a much
hated online advertising phrase, I talked about <em>one simple trick that will make current programming
language research much more interesting</em>. The trick is that we should not be looking at <em>programs</em>
or <em>programming languages</em>, but instead, we should be thinking about the <em>programming process</em>.
This can still be done mathematically. Rather than treating programs as syntactic expressions,
we should treat programs as <em>results of a series of interactions</em> that were used to create the
program. Those interactions include writing code, but also refactoring, copy and paste or running
a bit of program in REPL or a notebook system. By considering these as part of the process, we can
create a richer notion of programming language that lets us focus on making programming easier.</p>
<blockquote>
<img src="kent-gs.png" style="float:right;width:120px; margin:5px 0px 20px 30px" />
<p><em><i class="fa fa-hand-o-right" style="font-size:110%;margin:0px 5px 0px 0px"></i></em>
I recently joined the fantastic Programming Languages and Systems group at the <a href="https://www.cs.kent.ac.uk">University of Kent</a>.
We are always looking for PhD students and I'm also working on getting money for a post-doc
position, so if any of the ideas in this blog post sound interesting to you, please get in touch!</p>
<p>All of these are open ended and there are many forms this could take. I'm also interested in
hearing from anyone who has done something related or knows of references that I missed!
You can ping me at <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a>
or send an email to <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a>.</p>
</blockquote>




    <div class="info">
    <p class="share">
        <a target="_blank" href="https://twitter.com/intent/tweet?url=http%3a%2f%2ftomasp.net%2fblog%2f2018%2fprogramming-interaction%2f&amp;text=Programming+as+interaction%3a+A+new+perspective+for+programming+language+researchvia+%40tomaspetricek">
          <i class="fab fa-twitter-square"></i></a>
        <a target="_blank" href="https://www.facebook.com/sharer.php?u=http%3a%2f%2ftomasp.net%2fblog%2f2018%2fprogramming-interaction%2f">
          <i class="fab fa-facebook-square"></i></a>
        <a href="http://www.reddit.com/submit?url=http%3a%2f%2ftomasp.net%2fblog%2f2018%2fprogramming-interaction%2f&title=Programming+as+interaction%3a+A+new+perspective+for+programming+language+research">
          <i class="fab fa-reddit-square"></i></a>
        <a href="mailto:?subject=Programming%20as%20interaction%3a%20A%20new%20perspective%20for%20programming%20language%20research&body=%20In%20programming%20research%2c%20we%20say%20a%20lot%20about%20programs%20and%20languages%2c%20but%20very%20little%0d%0aabout%20the%20actual%20process%20of%20programming.%20One%20simple%20trick%20that%20will%20make%20programming%20language%0d%0aresearch%20significantly%20more%20interesting%20is%20to%20think%20about%20programs%20not%20as%20expressions%2c%20but%20as%0d%0aa%20result%20of%20a%20sequence%20of%20interactions%20that%20create%20it.%20This%20includes%20usual%20things%20such%20as%0d%0awriting%20code%20and%20refactoring%2c%20but%20if%20we%20also%20include%2c%20say%2c%20running%20a%20part%20of%20the%20program%2c%0d%0awe%20become%20capable%20of%20saying%20many%20more%20interesting%20things%20and%20building%20new%20powerful%20programming%20tools.%0a%0aSee%3a%20http%3a%2f%2ftomasp.net%2fblog%2f2018%2fprogramming-interaction%2f">
          <i class="fa fa-envelope"></i></a>
    </p>
    <p class="details">
      <strong>Published:</strong> Monday, 8 October 2018, 1:22 PM<br />
      <strong>Author:</strong> Tomas Petricek<br />
      <strong>Typos:</strong> <a href="http://github.com/tpetricek/tomasp.net">Send me a pull request</a>!<br />
      
        <strong>Tags:</strong> <a
          href="/blog/tag/academic/">academic</a>, <a
          href="/blog/tag/research/">research</a>, <a
          href="/blog/tag/programming-languages/">programming languages</a>, <a
          href="/blog/tag/data-science/">data science</a></span><br />
      
    </p>
    </div>
  </article>

  
  <footer>
  <div class="footer-body">
    <div class="fl70"><div class="fmr">
      <h4><a href="http://tomasp.net/rss.xml"><i class="fa fa-rss" style="margin-right:5px;"></i></a> Blog archives</h4>
      <p>
      
      <a href="/blog/archive/september_2022/">September 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2022/">April 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2021/">October 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2021/">April 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2020/">October 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2020/">July 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2020/">April 2020 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2019/">December 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2019/">February 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2018/">November 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2018/">October 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2018/">May 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2017/">September 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2017/">June 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2017/">April 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2017/">March 2017 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2017/">January 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2016/">October 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2016/">September 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/august_2016/">August 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2016/">July 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2016/">May 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2016/">April 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2015/">December 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2015/">November 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2015/">September 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2015/">July 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2015/">June 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2015/">May 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2015/">April 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2015/">March 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2015/">February 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2015/">January 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2014/">December 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2014/">May 2014 (3)</a>,&nbsp;
      
      <a href="/blog/archive/april_2014/">April 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2014/">March 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2014/">January 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2013/">December 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2013/">November 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2013/">October 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2013/">September 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2013/">August 2013 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2013/">May 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2013/">April 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2013/">March 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2013/">February 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2013/">January 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2012/">December 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/october_2012/">October 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2012/">August 2012 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2012/">June 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2012/">April 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2012/">March 2012 (4)</a>,&nbsp;
      
      <a href="/blog/archive/february_2012/">February 2012 (5)</a>,&nbsp;
      
      <a href="/blog/archive/january_2012/">January 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2011/">November 2011 (5)</a>,&nbsp;
      
      <a href="/blog/archive/august_2011/">August 2011 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2011/">July 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/june_2011/">June 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2011/">May 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2011/">March 2011 (4)</a>,&nbsp;
      
      <a href="/blog/archive/december_2010/">December 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2010/">November 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2010/">October 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/september_2010/">September 2010 (4)</a>,&nbsp;
      
      <a href="/blog/archive/july_2010/">July 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2010/">June 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2010/">May 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2010/">February 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2010/">January 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/december_2009/">December 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2009/">July 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2009/">June 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2009/">May 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2009/">April 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2009/">March 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2009/">February 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2008/">December 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2008/">November 2008 (5)</a>,&nbsp;
      
      <a href="/blog/archive/october_2008/">October 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2008/">September 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2008/">June 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2008/">March 2008 (3)</a>,&nbsp;
      
      <a href="/blog/archive/february_2008/">February 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2007/">December 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2007/">November 2007 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2007/">October 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2007/">September 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2007/">August 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2007/">July 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2007/">April 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2007/">March 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2007/">February 2007 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2007/">January 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2006/">November 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2006/">October 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/august_2006/">August 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/july_2006/">July 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2006/">June 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2006/">May 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2006/">April 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2005/">December 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2005/">July 2005 (4)</a>,&nbsp;
      
      <a href="/blog/archive/june_2005/">June 2005 (5)</a>,&nbsp;
      
      <a href="/blog/archive/may_2005/">May 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2005/">April 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2005/">March 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2005/">January 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2004/">December 2004 (3)</a>,&nbsp;
      
      <a href="/blog/archive/november_2004/">November 2004 (2)</a>,&nbsp;
      
      </p>
    </div></div>
    <div class="fr30"><div class="fmr">
      <h4>License and about</h4>
      <p>All articles on this site are licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share Alike</a>.
        All source code samples are licensed under the MIT License.
      </p>
      <p>This site is hosted on GitHub and is generated using <a href="https://github.com/tpetricek/FSharp.Formatting">F# Formatting</a>
        and <a href="http://dotliquidmarkup.org/">DotLiquid</a>.
        For more info, see the <a href="https://github.com/tpetricek/tomasp.net">website source on GitHub</a>.
      </p>
      <p>Please submit issues &amp; corrections on GitHub. Use pull requests for minor corrections only.</p>
      <ul>
        <li><i class="fab fa-twitter"></i> Twitter: <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a></li>
        <li><i class="fab fa-github"></i> GitHub: <a href="https://github.com/tpetricek">@tpetricek</a></li>
        <li><i class="fa fa-envelope"></i> Email: <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a></li>
      </ul>
      <p style="text-align:center;margin-top:15px;"><img src="http://tomasp.net/img/cc-sa.png" alt="CC License logo" /></p>
    </div></div>
  </div>
  </footer>

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-1561220-1']);
    _gaq.push(['_trackPageview']);
    (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</body>
</html>
