<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <meta name=viewport content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Droid+Sans+Mono&family=Kreon:wght@300;400;500;600&family=PT+Sans:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="alternate" type="application/rss+xml" title="Latest news from Tomas Petricek" href="/rss.xml" />
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <link href="/custom/style.css" rel="stylesheet">
  <link href="/custom/tooltips.css" rel="stylesheet">
  <script src="/custom/tooltips.js" type="text/javascript"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon-big.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/img/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/img/favicon-big.png">
  <meta name="msapplication-TileColor" content="#004C6B">
  <meta name="msapplication-TileImage" content="/img/favicon-big.png">
  <meta name="theme-color" content="#004C6B">
  
  <title>What should a Software Engineering course look like? - Tomas Petricek</title>

  <meta name="description" content=" Is there any fundamental knowledge about software engineering that will remain
relevant in the next 100 years? In this blog post, I discuss why teaching software engineering
in a university environment is difficult. I also suggest how we can design a more useful
software engineering course that will not go out of date with the next shift in technologies
and methodologies. The key idea is that we need to focus on the motivation behind software
engineering and the reasoning that leads to the adoption of particular software engineering
methods in the face of particular problems that the software industry is attempting to address." />
  <meta name="keywords" content="academic, teaching, philosophy, " />  
  <meta name="author" content="Tomas Petricek" />
  <meta name="copyright" content="Tomas Petricek" />
  
  <meta property="og:title" content="What should a Software Engineering course look like?" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://tomasp.net/blog/2019/software-engineering/" />
  <meta property="og:image" content="http://tomasp.net/blog/2019/software-engineering/sdi.jpg" />
  <meta property="og:description" content=" Is there any fundamental knowledge about software engineering that will remain
relevant in the next 100 years? In this blog post, I discuss why teaching software engineering
in a university environment is difficult. I also suggest how we can design a more useful
software engineering course that will not go out of date with the next shift in technologies
and methodologies. The key idea is that we need to focus on the motivation behind software
engineering and the reasoning that leads to the adoption of particular software engineering
methods in the face of particular problems that the software industry is attempting to address." />
  
  <meta name="twitter:card" content="summary_large_image">
  
  <meta name="twitter:site" content="@tomaspetricek">
  <meta name="twitter:creator" content="@tomaspetricek">  
  <meta name="twitter:title" content="What should a Software Engineering course look like?" />
  <meta name="twitter:image" content="http://tomasp.net/blog/2019/software-engineering/sdi.jpg" />
  <meta name="twitter:description" content=" Is there any fundamental knowledge about software engineering that will remain
relevant in the next 100 years? In this blog post, I discuss why teaching software engineering
in a university environment is difficult. I also suggest how we can design a more useful
software engineering course that will not go out of date with the next shift in technologies
and methodologies. The key idea is that we need to focus on the motivation behind software
engineering and the reasoning that leads to the adoption of particular software engineering
methods in the face of particular problems that the software industry is attempting to address." />
    
  <script type="application/ld+json">
  {
  	"@context": "http:\/\/schema.org",
  	"@type": "Article",
  	"name": "What should a Software Engineering course look like?",
    "headline": "What should a Software Engineering course look like?",
  	"description": " Is there any fundamental knowledge about software engineering that will remain
relevant in the next 100 years? In this blog post, I discuss why teaching software engineering
in a university environment is difficult. I also suggest how we can design a more useful
software engineering course that will not go out of date with the next shift in technologies
and methodologies. The key idea is that we need to focus on the motivation behind software
engineering and the reasoning that leads to the adoption of particular software engineering
methods in the face of particular problems that the software industry is attempting to address.",
  	"url": "http://tomasp.net/blog/2019/software-engineering/",
  	"author": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	},
  	"creator": ["Tomas Petricek"],
  	"dateCreated": "2019-02-08T12:22:57.7521867+01:00",
  	"datePublished": "2019-02-08T12:22:57.7521867+01:00",
    "dateModified": "2019-02-08T12:22:57.7521867+01:00",
    "mainEntityOfPage": "http://tomasp.net/blog/2019/software-engineering/",
  	"image": "http://tomasp.net/blog/2019/software-engineering/sdi.jpg",
  	"thumbnailUrl": "http://tomasp.net/blog/2019/software-engineering/sdi.jpg",
  	"keywords": ["academic", "teaching", "philosophy",  "tomas", "petricek"],
  	"inLanguage": "en-us",
  	"publisher": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
      "logo": "http://tomasp.net/img/favicon-big.png",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	}
  }  
  </script>

</head>
<body class="default">
    
  <span class="tplink"><a href="/">TP</a></span>

  <article class='article''>
    <h1><span class="hmq">What should a Software Engineering course look like</span><span class="hs"></span></h1>
<p>When I joined the <a href="https://www.cs.kent.ac.uk/">School of Computing</a> at the <a href="https://www.kent.ac.uk/">University of
Kent</a>, I was asked what subjects I wanted to teach. One of the topics
I chose was <em>Software Engineering</em>. I spent quite a lot of time reading about the history of
software engineering when working on my paper <a href="/academic/papers/failures/index.html">on programming
errors</a> and I go to a fair number of <a href="http://github.com/tpetricek/Talks">professional
programming conferences</a>, so I thought I can come up
with a good way of teaching it! Yet, I was not quite sure how to go about it or even what
<em>software engineering</em> actually means.</p>
<p>In this blog post, I share my thought process on deciding what to cover in my Software
Engineering module and also a rough list of topics. The introduction explaining <em>why</em> I chose
these and <em>how</em> I structure them is perhaps more important than the list itself, but it
is fairly long, so if you just want to see a list you can
<a href="http://tomasp.net/blog/2019/software-engineering/#fund">skip ahead to Section 2</a> (but please read the
introduction if you want to comment on the list!) I also add a brief reflection on why I think
this is a good approach, referencing a couple of ideas from philosophy of science in <a href="#phil">Section 3</a>.</p>
<img src="ncrafts.jpg" style="float:right;max-height:100px;margin:10px 20px 10px 30px"/>
<blockquote>
<p>I will be doing a talk based on some of the ideas in this blog post at the <a href="http://ncrafts.io">NewCrafts
conference</a> on 16-17 May in Paris, a software development conference
for professional developers who care about quality code and bettering their practices.
If you want to chat about these ideas, NewCrafts will be a perfect opportunity!</p>
</blockquote>
<h2>1. The problem with Software Engineering</h2>
<p>Many universities treat <em>software engineering</em> as a course where they should give students some
directly practical useful skills that future employers will ask for. Although we believe that topics
typically covered by the computer science curriculum (such as algorithms, complexity analysis, logic,
but also compilers or theories of human computer interaction) are important, we also recognize that
most students will go on to work as software developers and companies hiring them will be very happy if
students know some of the practices, tools and methodologies that they are using.</p>
<div style="max-width:550px;padding:10px" class="rdecor">
<img src="ibm.jpg" style="border:solid 6px black;width:100%" />
</div>
<p>Consequently, <em>software engineering</em> becomes just a course trying to cover <em>whatever methods and
tools the industry needs</em>. This is something that universities cannot, in principle, teach
very well. The tools of choice and even popular methodologies keep changing quite quickly.
The trend of the day is no longer object-oriented modelling, but event sourcing; three-tier
architecture gets replaced by microservices with tools like Kubernetes; heavyweight processes
get replaced by Agile methods, and even (some aspects of) these are frequently being questioned.
Even if a university designs an up-to-date course it will be obsolete in 5 years.</p>
<p>Should we try keeping up with industry? Should we just give up and let students learn current
methods and tools on the job? Or is there something else we can do with the dreaded software
engineering course?</p>
<h3>1.1 Why teach Software Engineering at all</h3>
<p>If we see <em>software engineering</em> just as <em>whatever methods and tools the industry needs</em>,
then we can just say that this is not something the university needs to be teaching at all.
We teach algorithms, complexity theory and other computer science subjects because they will
largely remain valid in 100 years. They might not be directly applicable in many programming jobs,
but at least they capture a valid body of knowledge that we have collectively accumulated.
Programmers need to learn new methods and tools all the time, so teaching them the first
one they'll need after they finish university is not adding a huge amount of value anyway.
(We might still do this because some universities confuse themselves with vocational training
centres, but that's another topic.)</p>
<p>The question is, is there something about software engineering that is capturing knowledge that
will (likely) still be relevant in 100 years?</p>
<p>There certainly should be <em>something</em>. Most computer science topics are rooted in more scientific
applications of computers, and later ones in problems arising within computer science itself.
However, computers are only ubiquitous because they stopped being a tool used by scientists and
the military and became tools for business data processing throughout the 1950s and 1960s. This
introduced completely new kinds of problems - around addressing business needs, team work,
processes and reliability - that professional software developers still face today.</p>
<p>The problem is that (academic) computer scientists found the nice fundamental concept of an
<em>algorithm</em> and focused their efforts around this concept. In contrast, the data processing
industry never quite found good foundations for its use of computers. In a 1960 letter to the editor,
an ACM member complained (quoted in <a href="https://amzn.to/2EhHq1V" title="Nathan Ensmenger (2010). The Computer Boys Take Over: Computers, Programmers, and the Politics of Technical Expertise">Computer Boys Take Over</a>):</p>
<blockquote>
<p>All of us, I am sure, have read non-ACM articles on business data processing and found them
lacking. They suffer, I believe, from one basic fault: They fail to report fundamental
research in the data processing field. The question of 'fundamentalness’ is all-important
(...) [It provides] a technique for getting the field of business data processing on a firm
theoretical footing.</p>
</blockquote>
<p>I think that a good Software Engineering curriculum needs to address this issue. What are
<em>fundamental</em> insights about software development? Computer science, with its focus on algorithms
and mathematization, found one possible answer to this question, but definitely not the only one.
Part of the reason why I'm interested in teaching Software Engineering is that I think the course
provides a nice opportunity to find other possible interpretations of what <em>fundamental</em> might
mean...</p>
<h3>1.2 Where Software Engineering comes from</h3>
<div style="max-width:600px;padding:10px" class="rdecor">
<img src="nato.jpg" style="border:solid 6px black;width:100%" />
</div>
<p>In the 1960s programming appeared to be a black art. Some programmers were good at it, but there was no
clear way of recognising who had the necessary skills, training new people, or scaling the
production process to a large system. The <a href="http://homepages.cs.ncl.ac.uk/brian.randell/NATO/index.html" title="The NATO Software Engineering Conferences">NATO Conference on Software Engineering</a> in 1968
had a goal of <em>"turning the black art of programming into a proper engineering discipline"</em> and
it also introduced the term <em>Software Engineering</em>.</p>
<p>The attendees at the conference were a diverse group including computer scientists, managers and
military officials. Everybody agreed on what the problem was, but there was little agreement on
how it should be addressed. The next <a href="http://homepages.cs.ncl.ac.uk/brian.randell/NATO/index.html" title="The NATO Software Engineering Conferences">NATO Conference</a> a year later is widely regarded as a
complete failure for this reason. Computer scientists advocated use of mathematics and proofs,
managers advocated a factory model of organization, while the military was more used to achieving
reliability via over-engineering. In the following years, the term <em>Software Engineering</em> largely
became the name for a managerial approach to the challenge and came to cover things such as
requirements gathering, producing specifications, cost and time estimation, and detailed up-front
modelling of software architecture.</p>
<p>The challenge of turning the black art of programming into a proper engineering discipline still
remains (although we might phrase it a bit differently these days). We still have not solved the
problem and new ideas and methods appear and disappear over time. Many of the ideas that are
traditionally associated with <em>Software Engineering</em> are products of the 1970s and 1980s (or 1990s,
if we're lucky). Some of those are, no doubt, interesting, but they are not very relevant in
modern software development. More recent methods that address the problem (such as Agile) do
not favour the "software engineering" term, but they certainly fall into the same general space.</p>
<p>The problem is, if we just replace 1970s and 1980s content with 2000s content, we are not
developing any more fundamental knowledge. We're just replacing one, already obsolete, idea
with another, soon-to-be-obsolete idea.</p>
<a name="fund"></a>
<h2>2. Fundamental Software Engineering knowledge</h2>
<p>Universities need to teach Software Engineering knowledge that is fundamental in the sense that
it does not become obsolete in the next 5 years and in the sense that it captures some unchanging
principles of Software Engineering. Heavyweight software engineering methods from the 1970s and 1980s
are not this, but more modern methods like Scrum and Agile programming are not this kind of
knowledge either.</p>
<p>What I believe <em>is</em> unchanging is the motivation behind software engineering and the reasoning that
led to those particular methods and tools in the face of particular problems that the industry
was attempting to address. In other words, we should not teach Waterfall, UML, Scrum or TDD.
We should teach how different circumstances, problems and goals motivate these, why the various
methods are a reasonable response to the challenge (even for Waterfall!), and circumstances where
they do <em>not</em> work.</p>
<p>This also gives us a good answer when we ask what practical value does a Software Engineering
course like this have. We might not cover the favourite tools and methods of the day, but we
can help students think about the motivations for and limitations of the tools and methods.
When they work for a company that follows a particular methodology, they should be able to
recognize whether the methodology is actually suitable given the problems, motivation, and other
circumstances.</p>
<p>I believe such <em>historically situated analysis</em> of Software Engineering is fundamental knowledge.
It is also a valuable thing that universities can teach, because it is hard to learn on the job.
It requires a historical perspective and an additional level of reflection. It is worth noting that
what I'm advocating here is quite different from, say, fundamental knowledge that computer science
collects about algorithms. It is historical, technical and sociological rather than mathematical,
but that does not mean it is any less <em>fundamental</em>. It's just a different kind of knowledge.</p>
<h3>2.1 Historically situated Software Engineering</h3>
<div style="max-width:550px;padding:10px" class="rdecor">
<img src="snowbird.jpg" style="border:solid 6px black;width:100%" />
</div>
<p>If you came here for a list of topics that I think we should teach in a software engineering
course, you finally reached the right section! You'll notice that many of the technical topics
I want to cover are, actually, topics that are covered by typical software engineering courses.
The key difference is that I think we should spend about third of the time on the actual technical
details and two thirds on the history and critical analysis.</p>
<h4>Methodologies and approaches in context</h4>
<p>Today, outdated software engineering courses teach a variant of the <em>waterfall</em> development
methodology while more up-to-date courses teach <em>agile</em> or <em>scrum</em>. Both of these are wrong.
Even with agile, the way it is practiced differs significantly across companies and so the
particular practices an academic course might cover will not really be directly relevant.
Instead, we should teach:</p>
<ul>
<li>
<p>What are the motivations that led to ideas such as waterfall and agile? For waterfall, the
context was a more general managerial culture of the 1970s, rising complexity and costs of software,
and the fact that programmers were "hackers" who were hard to hire, train and replace.
For agile, the context was faster innovation that led to changing requirements and the need
for more rapid response. Looking at both actually teaches us something - given <em>any business
context</em> and <em>any methodology</em>, students should be able to understand whether the methodology is
appropriate.</p>
</li>
<li>
<p>The history of development methodologies often provides an excellent background for understanding
them. Memorizing the <a href="https://agilemanifesto.org/" title="Manifesto for Agile Software Development">Agile manifesto</a> will teach you a particular response to a problem
without teaching you what the problem was; reading <a href="https://link.springer.com/chapter/10.1007/978-94-011-1793-7_11" title="Christiane Floyd (1993). Outline of a Paradigm Change in Software Engineering">Outline of a Paradigm Change in Software
Engineering</a> by Christiane Floyd will give you the context (and, incidentally, also
illustrate that she made a very similar point about 15 years earlier).</p>
</li>
</ul>
<h4>Modelling in context</h4>
<p>Another topic that is often featured in software engineering courses is UML. I do not often meet
people who actually use UML in their work, but the general idea of somehow capturing key ideas
about a system in a more readable form is definitely worth discussing. Again, I think the particular
methods need to be discussed with an appropriate context that explains when they work.</p>
<div style="max-width:600px;padding:10px" class="rdecor">
<img src="pattern.jpg" style="border:solid 6px black;width:100%" />
</div>
<ul>
<li>
<p>What was the context in which UML appeared and how does it compare to other methods such as
using algebraic data types (ADTs) in functional languages? Both are responses to a particular context.
In the case of UML, this was the rise of Java-like object-oriented programming and the metaphor of
an "architect" who designs a master plan for a system. In the case of ADTs, the context is treating
programs as mathematical entities. Both of these ideas have interesting motivations, techniques
and limitations!</p>
</li>
<li>
<p>Speaking of modelling, I think that <em>event sourcing</em> is another idea worth discussing. This is
more recent, but it gives a really interesting complementary perspective that has very clear
motivations (need to have a detailed log of what has happened in financial systems). I also
think it is a good opportunity to show how the same problem can be viewed from very different
perspectives (both valid).</p>
</li>
<li>
<p>One cross-cutting concern that all forms of modelling are dealing with is whether the model
can be kept in sync with the actual system, and also, how detailed and precise the model is.
Considering this from a historical perspective, we can see that this is a problem we've been
worried about since the early days of formal specifications in the 1960s, through the 1980s idea of
<a href="https://link.springer.com/chapter/10.1007/978-94-011-1793-7_6" title="William Scherlis, Dana Scott (1993). First Steps Towards Inferential Programming">inferential programming</a>, all the way to UML and functional programming. UML is quite
interesting as it can be used as an informal whiteboard tool, but there were also many
(largely failed) attempts to generate code from diagrams and vice versa.</p>
</li>
</ul>
<h4>Software architectures in context</h4>
<p>Many software engineering courses also include the <a href="https://amzn.to/2BHeONy" title="John Vlissides, Ralph Johnson, Richard Helm, Erich Gamma (1994). Design Patterns: Elements of Reusable Object-Oriented Software">Gang of Four Design Patterns</a>. I suppose
those are often presented as an answer to some problems arising in software architecture, but
really, most of them are very technical and address limitations of C++ and later Java-like
languages. I think there is a useful lesson to be learned from GoF patterns if we add context,
but we can also consider software architecture issues more broadly.</p>
<ul>
<li>
<p>The Gang of Four design patterns are a response to particular problems of Java. This is not
because Java is bad, but because every language has things that are hard to express!
However, GoF patterns are also just one outcome of the patterns movement, which is taking
inspiration from architecture and this historical context gives not only a more useful idea
of <em>patterns</em>, but also awareness of where software engineering ideas might come from.</p>
</li>
<li>
<p>Talking about software architecture more generally, I think there are a few patterns that are
sufficiently timeless to be worth mentioning - one example might be UNIX pipes, which also
exists in the form of function composition in functional languages. This gives us the opportunity
to show that the same idea can look very different in different contexts.</p>
</li>
</ul>
<p>Finally, one reference that I have not yet read, but which could be an other useful source of material for
discussing software architecture in context is <a href="https://amzn.to/2GRZMbe" title="Amy Brown (ed.) (2011). The Architecture Of Open Source Applications">The Architecture of Open Source Applications</a> book.</p>
<h4>Current hot topics</h4>
<p>I think the core of a software engineering course should cover <em>fundamental principles</em> that do not
go out of date and I think that critical historical reflection on different methodologies and
architectures achieves that. However, I recognise that we also need to cover some practically useful
<em>hot topics</em> and I like teaching some of those myself! Fortunately, the <em>historically situated</em>
approach to software engineering allows that:</p>
<ul>
<li>
The practical topics I cover this year include git, GitHub and continuous integration. These
are useful practical skills, but in the software engineering module we should avoid teaching them
as cargo cults. GitHub and git can teach us interesting things about the social side of software,
and continuous integration is a response to <a href="https://tpetricek.github.io/Teaching/software-engineering/collaborative.html" title="Tools for collaborative development (CO886)">changes in the way software is built</a>. Even if
we end up building software differently in a couple of years this will still be relevant as a
case of response to a particular context.
</li>
</ul>
<h3>2.2 Unchanging principles of Software Engineering</h3>
<p>Aside from historically situated perspectives on different contexts and software engineering
approaches responding to them, there are a few more things we should teach. In computer science,
the <em>halting problem</em> is a fundamental piece of knowledge, because it captures the limits of what
can theoretically be done. Are there similar fundamental limitations in software engineering?
Given that software engineering is an essentially human discipline, the answer will not be
mathematical. There are not many similar principles, but there are some:</p>
<div style="max-width:500px;padding:10px" class="rdecor">
<img src="sdi.jpg" style="border:solid 6px black;width:100%" />
</div>
<ul>
<li>
<p>One principle has been described in Fred Brooks' essay <a href="https://dl.acm.org/citation.cfm?id=26441" title="Fred Brooks (1987). No Silver Bullet Essence and Accidents of Software Engineering">No Silver Bullet</a>. The
idea is that software systems face <em>accidental</em> and <em>essential</em> complexity. The essential
complexity is part of their nature and cannot be eliminated while accidental complexity is
something that, say, better programming languages can eliminate. I believe this is one key
point about software engineering.</p>
</li>
<li>
<p>Another interesting problem is where does the complexity of software systems come from.
David Parnas' essay <a href="https://dl.acm.org/citation.cfm?id=214961" title="David Parnas (1985). Software Aspects of Strategic Defense Systems">Software Aspects of Strategic Defense Systems</a> reflects on the
development of anti-ballistic missile software systems, but also discusses why software systems
are complex: unlike analog systems, digital systems don't implement continuous functions.
Unlike, say, digital CPUs, software is not formed by repeated instances of the same unit.
Again, I think this idea gets to the core of what makes software engineering a challenge!</p>
</li>
<li>
<p>Another principle documented in the <a href="https://amzn.to/2XhsGqY" title="Rebecca Slayton (2013). Arguments that Count: Physics, Computing, and Missile Defense, 1949-2012">Arguments that Count</a> book (also mentioned by
Parnas in the context of missile defense) is that software systems develop through continual
adaptation in a forgiving environment. This means that certain systems, such as an effective
missile defense can be impossible to build, because they exist in a hostile environment that
can change at a more rapid pace (e.g. it will take you longer to build a defense system than
your opponent needs to build a missile that will circumvent the defense)</p>
</li>
</ul>
<h3>2.3 Where Software Engineering ideas come from</h3>
<p>Finally, I think that another topic worth our attention in a Software Engineering course is the
diversity of sources that are useful for understanding software engineering. Good software
engineering relies on broad interdisciplinary understanding and I think it's not a surprise that
interesting ideas about how software should be built borrow ideas not just from engineering, but
also from urban planning, architecture, or even gardening:</p>
<ul>
<li>
<p>I said earlier that the motivation for the birth of "Software Engineering" in 1968 was to
turn programming into a proper engineering discipline. But what does that actually mean?
To answer this, we should look at documented engineering principles - one reference (which I
have not yet read, but that comes highly recommended) is the <a href="https://amzn.to/2Ejc5LW" title="Jeffrey Liker (2011). The Toyota Way to Lean Leadership: Achieving and Sustaining Excellence through Leadership Development">Toyota Way</a>, which
was also the source of ideas for "lean" startup and software development methodologies.</p>
</li>
<li>
<p>The design patterns movement (mentioned earlier) borrows ideas from architecture. Looking at
how this process happened, both from the historical perspective, but also analysing what
insights we lost in the process would be another interesting lesson. I also think it points to
a valuable source of software engineering ideas. For example, I find that <a href="https://amzn.to/2V5oAAz" title="Jane Jacobs (1961). The Death and Life of Great American Cities">books about urban
planning</a> often contain inspiring ideas applicable to software!</p>
</li>
</ul>
<a name="phil"></a>
<h2>3. Is this still Software Engineering?</h2>
<p>You might be wondering if what I'm advocating as <em>Software Engineering</em> in this blog post is still
computer science, or whether I'm saying that we should replace "normal" Software Engineering courses
with something more akin to history and philosophy of software engineering.</p>
<p>Historically, software engineering is following the tradition of the data processing industry which
has never quite become the same thing as computer science. This is also apparent in the present-day
debates about whether programming job interviews should involve computer science questions (say, the <span class="math">\(O\)</span> notation).
If we are teaching Software Engineering, we need to expand our focus and also our methods,
because a good Software Engineering course will need to be different.</p>
<div style="max-width:300px;padding:10px" class="rdecor">
<img src="modern.jpg" style="border:solid 6px black;width:100%" />
</div>
<p>If learning software engineering at a university taught you the same things as learning software
engineering on the job, then I think universities should not bother teaching it. (Universities are
not, or at least should not be, training centres.) However, I believe
that teaching what I called <em>historically situated</em> software engineering does give students
something very valuable that they will not get through work experience. It provides a framework for
critical thinking about software engineering, and past examples to guide this thinking.</p>
<p>The approach that I'm advocating is somewhat akin to Bruno Latour's position presented in the
<a href="https://amzn.to/2EiDzBv" title="Bruno Latour (1993). We Have Never Been Modern">We Have Never Been Modern</a> book. To quote from the <a href="https://en.wikipedia.org/wiki/We_Have_Never_Been_Modern">summary on Wikipedia</a>:</p>
<blockquote>
<p>[Latour] claims [that] we must rework our thinking to conceive of a "Parliament of Things"
wherein natural phenomena, social phenomena and the discourse about them are not seen as
separate objects to be studied by specialists, but as hybrids made and scrutinized by the
public interaction of people, things and concepts.</p>
</blockquote>
<p>I think this is a perfect summary of what I think is a good way of thinking about and also
teaching software engineering. The technological aspects of software engineering such as
source control or design patterns need to be linked with the social phenomena surrounding them,
including the business context that motivates them, but also with critical reflection on
those entities and their contexts.</p>
<p><strong>Acknowledgements.</strong> Thanks to Richard Jones for feedback on earlier version of the post and
to Roger Turner for catching and correcting some of my typos.</p>
<h2>References</h2>
<ol>
<li><a href='https://amzn.to/2EhHq1V'>Nathan Ensmenger (2010). The Computer Boys Take Over: Computers, Programmers, and the Politics of Technical Expertise</a></li>
<li><a href='http://homepages.cs.ncl.ac.uk/brian.randell/NATO/index.html'>The NATO Software Engineering Conferences</a></li>
<li><a href='https://link.springer.com/chapter/10.1007/978-94-011-1793-7_11'>Christiane Floyd (1993). Outline of a Paradigm Change in Software Engineering</a></li>
<li><a href='https://agilemanifesto.org/'>Manifesto for Agile Software Development</a></li>
<li><a href='https://link.springer.com/chapter/10.1007/978-94-011-1793-7_6'>William Scherlis, Dana Scott (1993). First Steps Towards Inferential Programming</a></li>
<li><a href='https://amzn.to/2BHeONy'>John Vlissides, Ralph Johnson, Richard Helm, Erich Gamma (1994). Design Patterns: Elements of Reusable Object-Oriented Software</a></li>
<li><a href='https://amzn.to/2GRZMbe'>Amy Brown (ed.) (2011). The Architecture Of Open Source Applications</a></li>
<li><a href='https://tpetricek.github.io/Teaching/software-engineering/collaborative.html'>Tools for collaborative development (CO886)</a></li>
<li><a href='https://dl.acm.org/citation.cfm?id=26441'>Fred Brooks (1987). No Silver Bullet Essence and Accidents of Software Engineering</a></li>
<li><a href='https://dl.acm.org/citation.cfm?id=214961'>David Parnas (1985). Software Aspects of Strategic Defense Systems</a></li>
<li><a href='https://amzn.to/2XhsGqY'>Rebecca Slayton (2013). Arguments that Count: Physics, Computing, and Missile Defense, 1949-2012</a></li>
<li><a href='https://amzn.to/2Ejc5LW'>Jeffrey Liker (2011). The Toyota Way to Lean Leadership: Achieving and Sustaining Excellence through Leadership Development</a></li>
<li><a href='https://amzn.to/2V5oAAz'>Jane Jacobs (1961). The Death and Life of Great American Cities</a></li>
<li><a href='https://amzn.to/2EiDzBv'>Bruno Latour (1993). We Have Never Been Modern</a></li>
</ol>


    <div class="info">
    <p class="share">
        <a target="_blank" href="https://twitter.com/intent/tweet?url=http%3a%2f%2ftomasp.net%2fblog%2f2019%2fsoftware-engineering%2f&amp;text=What+should+a+Software+Engineering+course+look+like%3fvia+%40tomaspetricek">
          <i class="fab fa-twitter-square"></i></a>
        <a target="_blank" href="https://www.facebook.com/sharer.php?u=http%3a%2f%2ftomasp.net%2fblog%2f2019%2fsoftware-engineering%2f">
          <i class="fab fa-facebook-square"></i></a>
        <a href="http://www.reddit.com/submit?url=http%3a%2f%2ftomasp.net%2fblog%2f2019%2fsoftware-engineering%2f&title=What+should+a+Software+Engineering+course+look+like%3f">
          <i class="fab fa-reddit-square"></i></a>
        <a href="mailto:?subject=What%20should%20a%20Software%20Engineering%20course%20look%20like%3f&body=%20Is%20there%20any%20fundamental%20knowledge%20about%20software%20engineering%20that%20will%20remain%0d%0arelevant%20in%20the%20next%20100%20years%3f%20In%20this%20blog%20post%2c%20I%20discuss%20why%20teaching%20software%20engineering%0d%0ain%20a%20university%20environment%20is%20difficult.%20I%20also%20suggest%20how%20we%20can%20design%20a%20more%20useful%0d%0asoftware%20engineering%20course%20that%20will%20not%20go%20out%20of%20date%20with%20the%20next%20shift%20in%20technologies%0d%0aand%20methodologies.%20The%20key%20idea%20is%20that%20we%20need%20to%20focus%20on%20the%20motivation%20behind%20software%0d%0aengineering%20and%20the%20reasoning%20that%20leads%20to%20the%20adoption%20of%20particular%20software%20engineering%0d%0amethods%20in%20the%20face%20of%20particular%20problems%20that%20the%20software%20industry%20is%20attempting%20to%20address.%0a%0aSee%3a%20http%3a%2f%2ftomasp.net%2fblog%2f2019%2fsoftware-engineering%2f">
          <i class="fa fa-envelope"></i></a>
    </p>
    <p class="details">
      <strong>Published:</strong> Friday, 8 February 2019, 12:22 PM<br />
      <strong>Author:</strong> Tomas Petricek<br />
      <strong>Typos:</strong> <a href="http://github.com/tpetricek/tomasp.net">Send me a pull request</a>!<br />
      
        <strong>Tags:</strong> <a
          href="/blog/tag/academic/">academic</a>, <a
          href="/blog/tag/teaching/">teaching</a>, <a
          href="/blog/tag/philosophy/">philosophy</a></span><br />
      
    </p>
    </div>
  </article>


  <footer>
  <div class="footer-body">
    <div class="fl70"><div class="fmr">
      <h4><a href="http://tomasp.net/rss.xml"><i class="fa fa-rss" style="margin-right:5px;"></i></a> Blog archives</h4>
      <p>
      
      <a href="/blog/archive/february_2025/">February 2025 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2023/">December 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2023/">February 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2022/">September 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2022/">April 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2021/">October 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2021/">April 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2020/">October 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2020/">July 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2020/">April 2020 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2019/">December 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2019/">February 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2018/">November 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2018/">October 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2018/">May 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2017/">September 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2017/">June 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2017/">April 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2017/">March 2017 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2017/">January 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2016/">October 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2016/">September 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/august_2016/">August 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2016/">July 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2016/">May 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2016/">April 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2015/">December 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2015/">November 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2015/">September 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2015/">July 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2015/">June 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2015/">May 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2015/">April 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2015/">March 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2015/">February 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2015/">January 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2014/">December 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2014/">May 2014 (3)</a>,&nbsp;
      
      <a href="/blog/archive/april_2014/">April 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2014/">March 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2014/">January 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2013/">December 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2013/">November 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2013/">October 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2013/">September 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2013/">August 2013 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2013/">May 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2013/">April 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2013/">March 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2013/">February 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2013/">January 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2012/">December 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/october_2012/">October 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2012/">August 2012 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2012/">June 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2012/">April 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2012/">March 2012 (4)</a>,&nbsp;
      
      <a href="/blog/archive/february_2012/">February 2012 (5)</a>,&nbsp;
      
      <a href="/blog/archive/january_2012/">January 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2011/">November 2011 (5)</a>,&nbsp;
      
      <a href="/blog/archive/august_2011/">August 2011 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2011/">July 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/june_2011/">June 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2011/">May 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2011/">March 2011 (4)</a>,&nbsp;
      
      <a href="/blog/archive/december_2010/">December 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2010/">November 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2010/">October 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/september_2010/">September 2010 (4)</a>,&nbsp;
      
      <a href="/blog/archive/july_2010/">July 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2010/">June 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2010/">May 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2010/">February 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2010/">January 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/december_2009/">December 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2009/">July 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2009/">June 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2009/">May 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2009/">April 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2009/">March 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2009/">February 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2008/">December 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2008/">November 2008 (5)</a>,&nbsp;
      
      <a href="/blog/archive/october_2008/">October 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2008/">September 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2008/">June 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2008/">March 2008 (3)</a>,&nbsp;
      
      <a href="/blog/archive/february_2008/">February 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2007/">December 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2007/">November 2007 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2007/">October 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2007/">September 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2007/">August 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2007/">July 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2007/">April 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2007/">March 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2007/">February 2007 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2007/">January 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2006/">November 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2006/">October 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/august_2006/">August 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/july_2006/">July 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2006/">June 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2006/">May 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2006/">April 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2005/">December 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2005/">July 2005 (4)</a>,&nbsp;
      
      <a href="/blog/archive/june_2005/">June 2005 (5)</a>,&nbsp;
      
      <a href="/blog/archive/may_2005/">May 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2005/">April 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2005/">March 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2005/">January 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2004/">December 2004 (3)</a>,&nbsp;
      
      <a href="/blog/archive/november_2004/">November 2004 (2)</a>,&nbsp;
      
      </p>
    </div></div>
    <div class="fr30"><div class="fmr">
      <h4>License and about</h4>
      <p>All articles on this site are licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share Alike</a>.
        All source code samples are licensed under the MIT License.
      </p>
      <p>This site is hosted on GitHub and is generated using <a href="https://github.com/tpetricek/FSharp.Formatting">F# Formatting</a>
        and <a href="http://dotliquidmarkup.org/">DotLiquid</a>.
        For more info, see the <a href="https://github.com/tpetricek/tomasp.net">website source on GitHub</a>.
      </p>
      <p>Please submit issues &amp; corrections on GitHub. Use pull requests for minor corrections only.</p>
      <ul>
        <li><i class="fab fa-twitter"></i> Twitter: <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a></li>
        <li><i class="fab fa-github"></i> GitHub: <a href="https://github.com/tpetricek">@tpetricek</a></li>
        <li><i class="fa fa-envelope"></i> Email: <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a></li>
      </ul>
      <p style="text-align:center;margin-top:15px;"><img src="https://tomasp.net/img/cc-sa.png" alt="CC License logo" /></p>
    </div></div>
  </div>
  </footer>

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-1561220-1']);
    _gaq.push(['_trackPageview']);
    (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</body>
</html>
