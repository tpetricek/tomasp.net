<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <meta name=viewport content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Droid+Sans+Mono&family=Kreon:wght@300;400;500;600&family=PT+Sans:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha512-xh6O/CkQoPOWDdYTDqeRdPCVd1SpvCA9XXcUnZS2FmJNp1coAFzvtCN9BmamE+4aHK8yyUHUSCcJHgXloTyT2A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="alternate" type="application/rss+xml" title="Latest news from Tomas Petricek" href="/rss.xml" />
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <link href="/custom/style.css" rel="stylesheet">
  <link href="/custom/tooltips.css" rel="stylesheet">
  <script src="/custom/tooltips.js" type="text/javascript"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon-big.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/img/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/img/favicon-big.png">
  <meta name="msapplication-TileColor" content="#004C6B">
  <meta name="msapplication-TileImage" content="/img/favicon-big.png">
  <meta name="theme-color" content="#004C6B">
  
  <title>Philosophical questions about programming - Tomas Petricek</title>

  <meta name="description" content=" Combining philosophy and computer science might appear a bit odd, but the fact that the disciplines do not overlap might very well be the reason why putting them together is interesting - the antidisciplinary field that opens presents a number of important questions about programming language research and computer science in general!" />
  <meta name="keywords" content="philosophy, programming languages, " />  
  <meta name="author" content="Tomas Petricek" />
  <meta name="copyright" content="Tomas Petricek" />
  
  <meta property="og:title" content="Philosophical questions about programming" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://tomasp.net/blog/2016/philopl-questions/" />
  <meta property="og:image" content="http://tomasp.net/blog/2016/philopl-questions/thinker-sq.jpg" />
  <meta property="og:description" content=" Combining philosophy and computer science might appear a bit odd, but the fact that the disciplines do not overlap might very well be the reason why putting them together is interesting - the antidisciplinary field that opens presents a number of important questions about programming language research and computer science in general!" />
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:site" content="@tomaspetricek">
  <meta name="twitter:creator" content="@tomaspetricek">  
  <meta name="twitter:title" content="Philosophical questions about programming" />
  <meta name="twitter:image" content="http://tomasp.net/blog/2016/philopl-questions/thinker-sq.jpg" />
  <meta name="twitter:description" content=" Combining philosophy and computer science might appear a bit odd, but the fact that the disciplines do not overlap might very well be the reason why putting them together is interesting - the antidisciplinary field that opens presents a number of important questions about programming language research and computer science in general!" />
    
  <script type="application/ld+json">
  {
  	"@context": "http:\/\/schema.org",
  	"@type": "Article",
  	"name": "Philosophical questions about programming",
    "headline": "Philosophical questions about programming",
  	"description": " Combining philosophy and computer science might appear a bit odd, but the fact that the disciplines do not overlap might very well be the reason why putting them together is interesting - the antidisciplinary field that opens presents a number of important questions about programming language research and computer science in general!",
  	"url": "http://tomasp.net/blog/2016/philopl-questions/",
  	"author": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	},
  	"creator": ["Tomas Petricek"],
  	"dateCreated": "2016-05-26T14:33:26.1498716+02:00",
  	"datePublished": "2016-05-26T14:33:26.1498716+02:00",
    "dateModified": "2016-05-26T14:33:26.1498716+02:00",
    "mainEntityOfPage": "http://tomasp.net/blog/2016/philopl-questions/",
  	"image": "http://tomasp.net/blog/2016/philopl-questions/thinker-sq.jpg",
  	"thumbnailUrl": "http://tomasp.net/blog/2016/philopl-questions/thinker-sq.jpg",
  	"keywords": ["philosophy", "programming languages",  "tomas", "petricek"],
  	"inLanguage": "en-us",
  	"publisher": {
  		"@type": "Person",
  		"name": "Tomas Petricek",
  		"url": "http://tomasp.net",
      "logo": "http://tomasp.net/img/favicon-big.png",
  		"sameAs": ["http://twitter.com/tomaspetricek"]
  	}
  }  
  </script>

</head>
<body class="default">
    
  <span class="tplink"><a href="/">TP</a></span>

  <article class='article''>
    <h1>Philosophical questions about programming</h1>
<p>Combining philosophy and computer science might appear a bit odd. The disciplines have very little
overlap. Both philosophers and computer scientists get taught formal logic at some point in their
undergraduate courses, but that's probably as close as they get.</p>
<p>But the fact that the disciplines do not overlap much might very well be the reason why putting them
together is interesting. In an article about <a href="http://jods.mitpress.mit.edu/pub/designandscience">Design and Science</a>,
Joichi Ito (from MIT Media Lab), describes the term <em>antidisciplinary</em> and nicely
summarizes why looking at such unusual combinations is worthwhile:</p>
<blockquote>
<p>Interdisciplinary work is when people from different disciplines work together. But
<em>antidisciplinary</em> is something very different; it's about working in spaces that
simply do not fit into any existing academic discipline.</p>
<p>[When focusing on disciplines, it] takes more and more effort and resources to make a
unique contribution. While the space between and beyond the disciplines can be academically
risky, it (...) requires fewer resources to try promising, unorthodox
approaches; and provides the potential to have tremendous impact (...).</p>
</blockquote>
<p>As you can see from some of my <a href="http://tomasp.net/blog/tag/philosophy/">earlier blog posts</a>,
I think the space between philosophy and computer science is an interesting area. In this article,
I'll explain why. Unlike some of the previous posts (about <a href="http://tomasp.net/blog/2015/failures/index.html">miscomputation</a>,
<a href="http://tomasp.net/blog/2015/against-types/index.html">types</a> and <a href="http://tomasp.net/blog/2014/philosophy-pl/index.html">philosophy of
science</a>), this post is quite broad and
does not go into much detail.</p>
<p>At the danger of sounding like a collection of random rants, I look at a number of
questions that arise when you look at computer science from the philosophical perspective,
but I won't attempt to answer them. You can see this article as a research proposal too -
and I hope to write more about some of the questions in the future.
I wish antidisciplinary work was more common and I believe looking
into such questions could have the tremendous impact that Joichi Ito mentioned.</p>
<blockquote>
<p><strong>Thoughts? Comments?</strong> This is very much a draft and I am very interested in feedback! To make
this easier, I also <a href="http://www.pubpub.org/pub/philosophy-of-programming">posted the article on PubPub</a>,
which is a nice platform for reviewing and commenting. Please share your thoughts there!</p>
</blockquote>
<h2>How we work</h2>
<img src="http://tomasp.net/blog/2016/philopl-questions/ghosts.jpg" style="width:150px;float:right;margin:0px 0px 15px 15px" />
<p>I grouped the questions into three fairly general categories. The first one is mostly a
philosophical reflection on how research is done in computer science with, given my own background,
focus on programming languages research.</p>
<p>This is perhaps where combining philosophy and computer science could have the most direct
influence. If we take a step back and think about what is it that we are doing, perhaps we can
discover that our ordinary way of working is not the only (or the best!) option.</p>
<h3>How do you tell (computer) science from pseudoscience?</h3>
<p>The question how to distinguish between science and pseudoscience is known as the
<a href="https://en.wikipedia.org/wiki/Demarcation_problem">Demarcation problem</a>. This is harder than it
seems - programming language research is published in academic conferences or journals, but
the criteria for this is that other scientists <em>think</em> it is scientific. Saying that "scientific"
is what is "scientific" is not particularly helpful!</p>
<p>Typical programming language paper might include a performance evaluation (if it is
implementing something, like a garbage collector) or it might include simple mathematical model
of a language feature with a proof (programs in the model do not have certain bugs). Those might
be the most common ways of evaluating work in programming language research - but many other
disciplines work differently.</p>
<p>Perhaps more importantly, did we choose the above criteria of being scientific because we think that
this is what science should be, or did we choose them just because they are <em>easy to assess</em>?
Asking whether a programming language is more intuitive or easier to use is not "scientific" - but
is that just because our field (somehow) converged on demarcation criteria that exclude such
questions?</p>
<p>You could also ask differently - <a href="https://en.wikipedia.org/wiki/The_medium_is_the_message">medium is the message</a>
and the fact that computer science research is published as papers changes what questions we
ask, because we only worry about questions that can be answered in the paper format. Should
we be making <a href="http://www.future-programming.org/">screencasts and demos</a> or <a href="http://tomasp.net/coeffects/">interactive
essays</a> instead?</p>
<h3>What formal models tell us about the world?</h3>
<p>Work on programming and programming languages often involves three layers. There is some
<em>intuitive idea</em>, which is turned into <em>actual program</em> and formal reasoning is done about
a simplified <em>mathematical model</em>. In particular, programming language research often uses
simplified models (take a look at <a href="http://www.sigplan.org/Conferences/POPL/">every other POPL paper</a>
for example).</p>
<p>One question that is almost never asked is, what is the relationship between these three vertical
layers? We simply assume that proving properties in the mathematical model tells us
something about the (significantly more complex) program or perhaps even the original
idea - but this assumption is rarely made explicit. Is focusing on the <em>mathematical model</em> level
leaving out many important questions about the other levels?</p>
<p>In philosophy of mathematics, similar problem appears in the context of informal
mathematics and proofs (see <a href="http://tomasp.net/blog/2015/reading-list/">Proofs and Refutations</a>).
Informal entities allow only imprecise reasoning, while fully formal versions are precise, but
disconnected from the original entity. In computer science, we often sacrifice some of the
original intuition about problems in favor of working with formal entities that can be
treated more precisely. But do we lose something essential about the original problem by doing that?</p>
<h3>Unreasonable (in)effectiveness of mathematics</h3>
<p>In a famous paper <a href="https://en.wikipedia.org/wiki/The_Unreasonable_Effectiveness_of_Mathematics_in_the_Natural_Sciences">The Unreasonable Effectiveness of Mathematics in the Natural
Sciences</a>,
physicist Eugene Wigner points out how mathematics often works not just as a model, but also
leads to new discoveries in natural sciences like physics. In natural sciences, this is based on
a long history of the field.</p>
<p>In other disciplines <a href="https://en.wikipedia.org/wiki/Unreasonable_ineffectiveness_of_mathematics">such as economics</a>,
the effectiveness of mathematics has been a lot less unequivocal. In computer science, we also
often take the effectiveness of mathematics as granted, but we <em>use</em> it in a very different way than
physicists. We do not use mathematics as an <em>analysis tool</em>, but we try to use it as a <em>construction tool</em>.
And unlike physics, I'm not sure we have long enough history to support the idea that this method works well.</p>
<p>For example, one big difference between the use of mathematics in natural sciences and in
computer science is that physicists cannot <em>change the world</em> to make the mathematics work.
They have to tweak the models so that they get close to how reality works. In computer science,
when we build something that follows our intuition, but does not quite work mathematically, we
can just change it so that the mathematics works. But does this take us further from the
original idea, just because we choose mathematics as our construction tool?</p>
<h2>What we think</h2>
<img src="http://tomasp.net/blog/2016/philopl-questions/thinker.jpg" style="width:150px;float:right;margin:0px 0px 15px 15px" />
<p>The previous three questions were mostly reflections over how we (as computer scientists)
do things. Philosophy lets us take a step back and think why that is the case and whether
this is a good way (or, at least, what would be the alternatives).</p>
<p>In this section, I'll take one more step back and focus more at the thinking behind
what we are doing rather than at the concrete scientific outcomes. Just like <em>scientific
practice</em> has implicit assumptions (the "right way" of doing things), so does thinking have
its hidden assumptions.</p>
<h3>What we can <em>not</em> think?</h3>
<p>This will get a little meta - but when we think about a problem (or even when we think
what is a well-formed problem in the first place!) we rely on some broader underlying "apparatus"
that makes this thinking possible.</p>
<p>Our modern scientific thinking is certainly very different than the thinking of people in the
middle ages. This is not (just) because we are smarter - it is because our thoughts are based
on different foundations. In philosophy, <a href="https://en.wikipedia.org/wiki/Episteme">Michel Foucault calls this
episteme</a> and in science, the concept is similar to
<a href="https://en.wikipedia.org/wiki/Paradigm">Thomas Kuhn's paradigms</a>.</p>
<p>Why this matters? The interesting question is whether there are some things that we
<em>cannot even think</em> because they do not fit with our episteme. In computer science, our focus
on proofs, measurements and other forms of evaluation might be arising from a single episteme.
Would it be possible to think about problems differently? Perhaps in a way that would give
more space to linking the three vertical layers (ideas, implementation, mathematics) and less
space to moving horizontally (translating abstractions between different mathematical models
or comparing language features)?</p>
<h3>How we invent abstractions?</h3>
<p>One of the core ideas in computer science is <em>abstraction</em>. The idea that we can find common
patterns that are more general than a concrete structure, yet capture all its important properties.
(This thinking is very likely part of our <em>episteme</em>!) But one question that is almost never asked
is where do these abstractions come from? Are we just looking for structural patterns, or do
abstractions arise from some intuitive ideas?</p>
<p>Many common abstractions arise from intuitive metaphors. For example, in the <a href="https://en.wikipedia.org/wiki/First_Draft_of_a_Report_on_the_EDVAC">First Draft of a
Report on the EDVAC</a>, John
von Neumann described modern computer architecture. Rather than calling the individual units
<em>components</em> or <em>units</em>, he called them <em>organs</em>. You can see a biological metaphor here, right
at the foundations of modern computing! Similarly, how did we end up calling programming languages
<em>languages</em>? It is yet another metaphor - faithful in some respects and lacking in others.</p>
<p>If we want to understand abstractions, should we be <em>mathematicians</em>, or should we instead
become <em>literary critics</em>? And isn't category theory just a source of mathematical metaphors?</p>
<h3>Is computer science discovered or invented?</h3>
<p>The question whether mathematics is invented or discovered is a fundamental topic in <a href="https://en.wikipedia.org/wiki/Philosophy_of_mathematics">philosophy
of mathematics</a> (and there are several
other positions too). Are numbers abstract entities that exist independently of humans that we
discover? Or are they just things we constructed based on our environments?</p>
<p>You might think this does not have many practical consequences, but
I just had to put this question on the list after seeing Phil Wadler's talk
<a href="https://www.youtube.com/watch?v=aeRVdYN6fE8">Propositions as Types</a>. In the talk, he uses the
idea that some mathematical objects (lambda calculus, in particular) are <em>discovered</em> while other
programming models are <em>invented</em> to hint that the former are better.</p>
<p>The position in the talk is a bit unusual in that it mixes both philosophical positions on
mathematics into a single one (how exactly do we tell which programming model is invented and which
is discovered?), but nevertheless, it is an interesting idea that combines computer science
and philosophy. And if there was a sound philosophical argument for demarcating between two kinds
of objects, should we treat one kind as better than the other?</p>
<h2>Historical reflections</h2>
<img src="http://tomasp.net/blog/2016/philopl-questions/balzac.jpg" style="width:150px;float:right;margin:0px 0px 15px 15px" />
<p>In philosophy of science, many of the arguments about the success of particular scientific methods
are based on the history. By looking at the long history of natural sciences, we can understand
what makes the scientific method so effective and try to replicate the method in other disciplines.
Although the history of computer science is not very long, there is certainly enough interesting
material there that we can examine when searching for answers to some of the questions above.</p>
<h3>How we misinterpret the history?</h3>
<p>One thing makes looking at history very difficult. When we try to analyze history through our
modern perspective, it is easy to see it through the modern eyes and forget about the original
context in which the work was done.</p>
<p>For example, when we talk about Ada Lovelace as the first programmer, we are using a term that not
only did not <em>exist</em> in 19th century but, in fact, had a very different meaning even in 1950s when
first electronic computers were created! However, precisely because programming did not exist back
then, Ada Lovelace's work and thoughts were even more interesting! And if we see her in the
context of 19th century, it might be even more fascinating than through the modern perspective of
a "first programmer". (<a href="http://tomasp.net/blog/2015/reading-list/">Science of Operations</a> has a
great chapter on Babbage and Lovelace.)</p>
<p>The other important point when looking at history is that <em>our work is in the hands of its later
users</em> (see <a href="http://tomasp.net/blog/2015/reading-list/">Science in Action</a>). When you read a
foundational paper, it is important because of the work that <em>builds on top of it</em> which often
takes the idea in another direction - possibly quite different than what the author intended.
What would we learn about our discipline if we approached its history with respect to the
original context, rather than reinterpreting it through the modern perspective (using what
is known as <a href="https://en.wikipedia.org/wiki/Whig_history#In_the_history_of_science">Whig interpretation</a>)?</p>
<h3>How paradigms shape our thinking?</h3>
<p>History can also teach us about hidden assumptions in our thinking. Scientists (including computer
scientists) often do not question <em>all</em> assumptions in their work. When something does not work
as expected, we blame <em>auxiliary assumptions</em> rather than the <em>hard core</em> of the research. This
is the idea behind <a href="https://en.wikipedia.org/wiki/Research_program">Research programmes</a> as described
by Imre Lakatos.</p>
<p>In computer science, one example is the <em>Algol research programme</em> (again from <a href="http://tomasp.net/blog/2015/reading-list/">Science of
Operations</a>). While the Algol language never
got popular in practice, it defined a hugely influential set of core assumptions for academic
programming research - the idea of using mathematical logic for ensuring program correctness
can be traced back to Algol.</p>
<p>Seeing the "correctness through logic" idea as a core assumption of a particular research programme
explains why this is rarely questioned in programming language research, but it also makes it
easier to see alternative perspectives. For example, many of the <a href="http://www.future-programming.org/">Future Programming
Workshop</a> demos follow a different research programme. They
are not just early (not yet formalized) works - they are works that may never <em>need</em> to be
formalized.</p>
<h2>Conclusions</h2>
<p>As a scientific discipline, computer science often paints the picture that it is gradually
progressing towards some ideal goal - perfect programming language, provably correct programs
and so on. Academic papers support this illusion of continuity by building on previous work,
even when they completely change the direction of what the original author intended.</p>
<p>I believe that using the <em>antidisciplinary</em> method and combining computer science and philosophy
is a great way to bring more innovative ideas to the discipline - be it programming language
research or other areas.</p>
<p>A little background in philosophy lets us understand that things are not always as simple as they
seem. It is not that easy to distinguish between good and bad science; we often build models, but
rarely try to understand how and what they tell us about the world. We use certain methods without
worrying about the consequences they might have - both on the results we get, but also on
<em>questions we can ask</em>.</p>
<p>This article certainly does not aim to tell you that everything we are doing is wrong. That is
not at all what I believe. But I hope to inspire the readers to think about what we do in a
slightly different, more reflective, philosophical way. Reading <a href="http://tomasp.net/blog/2015/reading-list/">a great book on history of computing
or philosophy of science</a> is a great way to get started.</p>
<blockquote>
<p><strong>Thoughts? Comments?</strong> As mentioned at the beginning I am very interested in feedback! If you
have related ideas or comments related to this article, please <a href="http://www.pubpub.org/pub/philosophy-of-programming">add them to the PubPub
version of this article</a>!</p>
</blockquote>




    <div class="info">
    <p class="share">
        <a target="_blank" href="https://twitter.com/intent/tweet?url=http%3a%2f%2ftomasp.net%2fblog%2f2016%2fphilopl-questions%2f&amp;text=Philosophical+questions+about+programmingvia+%40tomaspetricek">
          <i class="fab fa-twitter-square"></i></a>
        <a target="_blank" href="https://www.facebook.com/sharer.php?u=http%3a%2f%2ftomasp.net%2fblog%2f2016%2fphilopl-questions%2f">
          <i class="fab fa-facebook-square"></i></a>
        <a href="http://www.reddit.com/submit?url=http%3a%2f%2ftomasp.net%2fblog%2f2016%2fphilopl-questions%2f&title=Philosophical+questions+about+programming">
          <i class="fab fa-reddit-square"></i></a>
        <a href="mailto:?subject=Philosophical%20questions%20about%20programming&body=%20Combining%20philosophy%20and%20computer%20science%20might%20appear%20a%20bit%20odd%2c%20but%20the%20fact%20that%20the%20disciplines%20do%20not%20overlap%20might%20very%20well%20be%20the%20reason%20why%20putting%20them%20together%20is%20interesting%20-%20the%20antidisciplinary%20field%20that%20opens%20presents%20a%20number%20of%20important%20questions%20about%20programming%20language%20research%20and%20computer%20science%20in%20general!%0a%0aSee%3a%20http%3a%2f%2ftomasp.net%2fblog%2f2016%2fphilopl-questions%2f">
          <i class="fa fa-envelope"></i></a>
    </p>
    <p class="details">
      <strong>Published:</strong> Thursday, 26 May 2016, 2:33 PM<br />
      <strong>Author:</strong> Tomas Petricek<br />
      <strong>Typos:</strong> <a href="http://github.com/tpetricek/tomasp.net">Send me a pull request</a>!<br />
      
        <strong>Tags:</strong> <a
          href="/blog/tag/philosophy/">philosophy</a>, <a
          href="/blog/tag/programming-languages/">programming languages</a></span><br />
      
    </p>
    </div>
  </article>


  <footer>
  <div class="footer-body">
    <div class="fl70"><div class="fmr">
      <h4><a href="http://tomasp.net/rss.xml"><i class="fa fa-rss" style="margin-right:5px;"></i></a> Blog archives</h4>
      <p>
      
      <a href="/blog/archive/february_2025/">February 2025 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2023/">December 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2023/">February 2023 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2022/">September 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2022/">April 2022 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2021/">October 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2021/">April 2021 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2020/">October 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2020/">July 2020 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2020/">April 2020 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2019/">December 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2019/">February 2019 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2018/">November 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2018/">October 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2018/">May 2018 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2017/">September 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2017/">June 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2017/">April 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2017/">March 2017 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2017/">January 2017 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2016/">October 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2016/">September 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/august_2016/">August 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2016/">July 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2016/">May 2016 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2016/">April 2016 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2015/">December 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2015/">November 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2015/">September 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2015/">July 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2015/">June 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2015/">May 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2015/">April 2015 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2015/">March 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2015/">February 2015 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2015/">January 2015 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2014/">December 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/may_2014/">May 2014 (3)</a>,&nbsp;
      
      <a href="/blog/archive/april_2014/">April 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2014/">March 2014 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2014/">January 2014 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2013/">December 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2013/">November 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2013/">October 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2013/">September 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2013/">August 2013 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2013/">May 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2013/">April 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2013/">March 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2013/">February 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/january_2013/">January 2013 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2012/">December 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/october_2012/">October 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2012/">August 2012 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2012/">June 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2012/">April 2012 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2012/">March 2012 (4)</a>,&nbsp;
      
      <a href="/blog/archive/february_2012/">February 2012 (5)</a>,&nbsp;
      
      <a href="/blog/archive/january_2012/">January 2012 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2011/">November 2011 (5)</a>,&nbsp;
      
      <a href="/blog/archive/august_2011/">August 2011 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2011/">July 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/june_2011/">June 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2011/">May 2011 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2011/">March 2011 (4)</a>,&nbsp;
      
      <a href="/blog/archive/december_2010/">December 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2010/">November 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2010/">October 2010 (6)</a>,&nbsp;
      
      <a href="/blog/archive/september_2010/">September 2010 (4)</a>,&nbsp;
      
      <a href="/blog/archive/july_2010/">July 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/june_2010/">June 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/may_2010/">May 2010 (1)</a>,&nbsp;
      
      <a href="/blog/archive/february_2010/">February 2010 (2)</a>,&nbsp;
      
      <a href="/blog/archive/january_2010/">January 2010 (3)</a>,&nbsp;
      
      <a href="/blog/archive/december_2009/">December 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/july_2009/">July 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2009/">June 2009 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2009/">May 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2009/">April 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2009/">March 2009 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2009/">February 2009 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2008/">December 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/november_2008/">November 2008 (5)</a>,&nbsp;
      
      <a href="/blog/archive/october_2008/">October 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2008/">September 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2008/">June 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/march_2008/">March 2008 (3)</a>,&nbsp;
      
      <a href="/blog/archive/february_2008/">February 2008 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2007/">December 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2007/">November 2007 (6)</a>,&nbsp;
      
      <a href="/blog/archive/october_2007/">October 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/september_2007/">September 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/august_2007/">August 2007 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2007/">July 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2007/">April 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/march_2007/">March 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/february_2007/">February 2007 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2007/">January 2007 (2)</a>,&nbsp;
      
      <a href="/blog/archive/november_2006/">November 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/october_2006/">October 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/august_2006/">August 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/july_2006/">July 2006 (1)</a>,&nbsp;
      
      <a href="/blog/archive/june_2006/">June 2006 (3)</a>,&nbsp;
      
      <a href="/blog/archive/may_2006/">May 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/april_2006/">April 2006 (2)</a>,&nbsp;
      
      <a href="/blog/archive/december_2005/">December 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/july_2005/">July 2005 (4)</a>,&nbsp;
      
      <a href="/blog/archive/june_2005/">June 2005 (5)</a>,&nbsp;
      
      <a href="/blog/archive/may_2005/">May 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/april_2005/">April 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/march_2005/">March 2005 (3)</a>,&nbsp;
      
      <a href="/blog/archive/january_2005/">January 2005 (1)</a>,&nbsp;
      
      <a href="/blog/archive/december_2004/">December 2004 (3)</a>,&nbsp;
      
      <a href="/blog/archive/november_2004/">November 2004 (2)</a>,&nbsp;
      
      </p>
    </div></div>
    <div class="fr30"><div class="fmr">
      <h4>License and about</h4>
      <p>All articles on this site are licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share Alike</a>.
        All source code samples are licensed under the MIT License.
      </p>
      <p>This site is hosted on GitHub and is generated using <a href="https://github.com/tpetricek/FSharp.Formatting">F# Formatting</a>
        and <a href="http://dotliquidmarkup.org/">DotLiquid</a>.
        For more info, see the <a href="https://github.com/tpetricek/tomasp.net">website source on GitHub</a>.
      </p>
      <p>Please submit issues &amp; corrections on GitHub. Use pull requests for minor corrections only.</p>
      <ul>
        <li><i class="fab fa-twitter"></i> Twitter: <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a></li>
        <li><i class="fab fa-github"></i> GitHub: <a href="https://github.com/tpetricek">@tpetricek</a></li>
        <li><i class="fa fa-envelope"></i> Email: <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a></li>
      </ul>
      <p style="text-align:center;margin-top:15px;"><img src="https://tomasp.net/img/cc-sa.png" alt="CC License logo" /></p>
    </div></div>
  </div>
  </footer>

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-1561220-1']);
    _gaq.push(['_trackPageview']);
    (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</body>
</html>
